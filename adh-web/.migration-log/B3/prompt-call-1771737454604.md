Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/AuthenticationPage.test.tsx.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
AuthenticationPage - Loading State displays loading state when isLoading is true: TestingLibraryElementError: Unable to find an element with the text: R√©cup√©ration en cours.... This could be because the text is broken up by multiple elements. In this case, you can provide a functio
AuthenticationPage - Loading State disables inputs when loading: Error: [2mexpect([22m[31melement[39m[2m).toBeDisabled()[22m

Received element is not disabled:
  [31m<input
  class="flex h-9 w-full rounded-md border border-border bg-surface px-3 py-1 text-sm
AuthenticationPage - Error State displays error message when error exists: TestingLibraryElementError: Unable to find an element with the text: Utilisateur introuvable. This could be because the text is broken up by multiple elements. In this case, you can provide a function
AuthenticationPage - Success State displays matricule when retrieved successfully: TestingLibraryElementError: Unable to find an element with the text: Matricule:. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your tex

CURRENT TEST FILE:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';

const mockNavigate = vi.fn();
const mockGetMatricule = vi.fn();
const mockSetMatricule = vi.fn();
const mockSetError = vi.fn();
const mockReset = vi.fn();

vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom');
  return {
    ...actual,
    useNavigate: () => mockNavigate,
  };
});

vi.mock('@/stores/authenticationStore', () => ({
  useAuthenticationStore: (selector: (state: unknown) => unknown) => {
    const state = {
      matricule: null,
      isLoading: false,
      error: null,
      getMatricule: mockGetMatricule,
      setMatricule: mockSetMatricule,
      setError: mockSetError,
      reset: mockReset,
    };
    return selector(state);
  },
}));

import { AuthenticationPage } from '@/pages/AuthenticationPage';

const renderWithRouter = (component: React.ReactElement) => {
  return render(<BrowserRouter>{component}</BrowserRouter>);
};

describe('AuthenticationPage', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders without crashing', () => {
    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByText('Authentification')).toBeInTheDocument();
    expect(screen.getByPlaceholderText('Saisir le login')).toBeInTheDocument();
  });

  it('displays form elements correctly', () => {
    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByLabelText('Login')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Retour' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'R√©cup√©rer matricule' })).toBeInTheDocument();
  });

  it('handles login input change', () => {
    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login') as HTMLInputElement;
    
    fireEvent.change(input, { target: { value: 'test.user' } });
    expect(input.value).toBe('test.user');
  });

  it('disables submit button when login is empty', () => {
    renderWithRouter(<AuthenticationPage />);
    const submitButton = screen.getByRole('button', { name: 'R√©cup√©rer matricule' });
    expect(submitButton).toBeDisabled();
  });

  it('enables submit button when login is filled', () => {
    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login');
    const submitButton = screen.getByRole('button', { name: 'R√©cup√©rer matricule' });

    fireEvent.change(input, { target: { value: 'test.user' } });
    expect(submitButton).not.toBeDisabled();
  });

  it('calls getMatricule on form submit with valid login', async () => {
    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login');
    const submitButton = screen.getByRole('button', { name: 'R√©cup√©rer matricule' });

    fireEvent.change(input, { target: { value: 'test.user' } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(mockGetMatricule).toHaveBeenCalledWith('test.user');
    });
  });

  it('shows error when submitting empty login', async () => {
    renderWithRouter(<AuthenticationPage />);
    const form = screen.getByRole('button', { name: 'R√©cup√©rer matricule' }).closest('form');

    fireEvent.submit(form!);

    await waitFor(() => {
      expect(mockSetError).toHaveBeenCalledWith('Le login est requis');
    });
  });

  it('trims whitespace from login before submission', async () => {
    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login');
    const submitButton = screen.getByRole('button', { name: 'R√©cup√©rer matricule' });

    fireEvent.change(input, { target: { value: '  test.user  ' } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(mockGetMatricule).toHaveBeenCalledWith('test.user');
    });
  });

  it('navigates back when Retour button is clicked', () => {
    renderWithRouter(<AuthenticationPage />);
    const backButton = screen.getByRole('button', { name: 'Retour' });

    fireEvent.click(backButton);
    expect(mockNavigate).toHaveBeenCalledWith('/caisse/menu');
  });

  it('calls reset on unmount', () => {
    const { unmount } = renderWithRouter(<AuthenticationPage />);
    unmount();
    expect(mockReset).toHaveBeenCalled();
  });
});

describe('AuthenticationPage - Loading State', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('displays loading state when isLoading is true', () => {
    vi.mocked(vi.importActual('@/stores/authenticationStore')).then((mod) => {
      vi.spyOn(mod as { useAuthenticationStore: (selector: (state: unknown) => unknown) => unknown }, 'useAuthenticationStore').mockImplementation((selector) => {
        const state = {
          matricule: null,
          isLoading: true,
          error: null,
          getMatricule: mockGetMatricule,
          setMatricule: mockSetMatricule,
          setError: mockSetError,
          reset: mockReset,
        };
        return selector(state);
      });
    });

    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByText('R√©cup√©ration en cours...')).toBeInTheDocument();
  });

  it('disables inputs when loading', () => {
    vi.mocked(vi.importActual('@/stores/authenticationStore')).then((mod) => {
      vi.spyOn(mod as { useAuthenticationStore: (selector: (state: unknown) => unknown) => unknown }, 'useAuthenticationStore').mockImplementation((selector) => {
        const state = {
          matricule: null,
          isLoading: true,
          error: null,
          getMatricule: mockGetMatricule,
          setMatricule: mockSetMatricule,
          setError: mockSetError,
          reset: mockReset,
        };
        return selector(state);
      });
    });

    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login');
    expect(input).toBeDisabled();
  });
});

describe('AuthenticationPage - Error State', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('displays error message when error exists', () => {
    vi.mocked(vi.importActual('@/stores/authenticationStore')).then((mod) => {
      vi.spyOn(mod as { useAuthenticationStore: (selector: (state: unknown) => unknown) => unknown }, 'useAuthenticationStore').mockImplementation((selector) => {
        const state = {
          matricule: null,
          isLoading: false,
          error: 'Utilisateur introuvable',
          getMatricule: mockGetMatricule,
          setMatricule: mockSetMatricule,
          setError: mockSetError,
          reset: mockReset,
        };
        return selector(state);
      });
    });

    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByText('Utilisateur introuvable')).toBeInTheDocument();
  });
});

describe('AuthenticationPage - Success State', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('displays matricule when retrieved successfully', () => {
    vi.mocked(vi.importActual('@/stores/authenticationStore')).then((mod) => {
      vi.spyOn(mod as { useAuthenticationStore: (selector: (state: unknown) => unknown) => unknown }, 'useAuthenticationStore').mockImplementation((selector) => {
        const state = {
          matricule: 'MAT12345',
          isLoading: false,
          error: null,
          getMatricule: mockGetMatricule,
          setMatricule: mockSetMatricule,
          setError: mockSetError,
          reset: mockReset,
        };
        return selector(state);
      });
    });

    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByText('Matricule:')).toBeInTheDocument();
    expect(screen.getByText('MAT12345')).toBeInTheDocument();
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Input, Button } from '@/components/ui';
import { useAuthenticationStore } from '@/stores/authenticationStore';

export const AuthenticationPage = () => {
  const navigate = useNavigate();

  const matricule = useAuthenticationStore((s) => s.matricule);
  const isLoading = useAuthenticationStore((s) => s.isLoading);
  const error = useAuthenticationStore((s) => s.error);
  const getMatricule = useAuthenticationStore((s) => s.getMatricule);
  const setMatricule = useAuthenticationStore((s) => s.setMatricule);
  const setError = useAuthenticationStore((s) => s.setError);
  const reset = useAuthenticationStore((s) => s.reset);

  const [login, setLogin] = useState('');

  useEffect(() => {
    return () => reset();
  }, [reset]);

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      if (!login.trim()) {
        setError('Le login est requis');
        return;
      }
      await getMatricule(login.trim());
    },
    [login, getMatricule, setError],
  );

  const handleBack = useCallback(() => {
    navigate('/caisse/menu');
  }, [navigate]);

  return (
    <ScreenLayout>
      <div className="space-y-6 max-w-md mx-auto">
        <div>
          <h2 className="text-xl font-semibold">Authentification</h2>
          <p className="text-on-surface-muted text-sm mt-1">
            R√©cup√©ration du matricule par login
          </p>
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md text-sm">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="login" className="block text-sm font-medium mb-1">
              Login
            </label>
            <Input
              id="login"
              type="text"
              value={login}
              onChange={(e) => setLogin(e.target.value)}
              placeholder="Saisir le login"
              disabled={isLoading}
            />
          </div>

          {matricule && (
            <div className="bg-green-50 border border-green-200 px-4 py-3 rounded-md">
              <p className="text-sm font-medium text-green-800">
                Matricule: <span className="font-mono">{matricule}</span>
              </p>
            </div>
          )}

          <div className="flex gap-3 justify-between">
            <Button
              type="button"
              onClick={handleBack}
              variant="secondary"
              disabled={isLoading}
            >
              Retour
            </Button>
            <Button type="submit" disabled={isLoading || !login.trim()}>
              {isLoading ? 'Chargement...' : 'R√©cup√©rer matricule'}
            </Button>
          </div>
        </form>

        {isLoading && (
          <div className="text-center">
            <div className="inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-primary border-r-transparent" />
            <p className="text-sm text-on-surface-muted mt-2">R√©cup√©ration en cours...</p>
          </div>
        )}
      </div>
    </ScreenLayout>
  );
};
```

Output the COMPLETE fixed test file. Do not omit any tests.