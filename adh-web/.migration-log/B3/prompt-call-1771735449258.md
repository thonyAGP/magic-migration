Generate a TypeScript types file for the "programDispatch" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

The file must export:
- An interface for each entity
- A State interface for the Zustand store
- Request/Response types for API endpoints
- Action types matching the store actions

ANALYSIS DOCUMENT:
{
  "domain": "programDispatch",
  "domainPascal": "ProgramDispatch",
  "complexity": "LOW",
  "entities": [],
  "stateFields": [
    {
      "name": "lastClickedControl",
      "type": "string | null",
      "default": "null"
    },
    {
      "name": "isDispatching",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "error",
      "type": "string | null",
      "default": "null"
    }
  ],
  "actions": [
    {
      "name": "dispatchToProgram",
      "params": [
        "controlId: string"
      ],
      "businessRules": [
        "Capture the last clicked control ID via LastClicked()",
        "Route to target program based on control key mapping",
        "Terminal program - no further downstream calls",
        "Single centralized dispatch logic for 21 callers"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "getLastClickedControl",
      "params": [],
      "businessRules": [
        "Retrieve the last clicked control identifier from UI context"
      ],
      "returns": "Promise<string | null>"
    },
    {
      "name": "clearDispatch",
      "params": [],
      "businessRules": [
        "Reset dispatch state after routing completes"
      ],
      "returns": "void"
    }
  ],
  "apiEndpoints": [
    {
      "method": "POST",
      "path": "/api/programDispatch/route",
      "queryParams": [
        "controlId"
      ],
      "response": "{ success: boolean, targetProgram?: string, error?: string }"
    },
    {
      "method": "GET",
      "path": "/api/programDispatch/lastClicked",
      "queryParams": [],
      "response": "{ controlId: string | null }"
    }
  ],
  "uiLayout": {
    "type": "headless",
    "sections": [],
    "description": "No visible UI - programmatic dispatch only"
  },
  "mockData": {
    "count": 0,
    "description": "No mock data required - routing logic is stateless"
  },
  "dependencies": {
    "stores": [],
    "sharedTypes": [],
    "externalApis": [],
    "notes": "Called by 21 programs (IDE 25, 40, 0, 111, 112, 168, 174, 217, 288, 317, 37, 69, 77, 86, 158, 163, 173, 190, 214, 242). Terminal program with no database access and no downstream calls."
  }
}

REFERENCE PATTERN (follow this structure):
// Change devises types (IDE 25)

export type ChangeOperationType = 'achat' | 'vente';

export interface Devise {
  code: string;
  libelle: string;
  symbole: string;
  tauxActuel: number;
  nbDecimales: number;
}

export interface DeviseStock {
  deviseCode: string;
  deviseLibelle: string;
  montant: number;
  nbOperations: number;
}

export interface ChangeOperation {
  id: number;
  type: ChangeOperationType;
  deviseCode: string;
  deviseLibelle: string;
  montant: number;
  taux: number;
  contreValeur: number;
  modePaiement: string;
  date: string;
  heure: string;
  operateur: string;
  annule: boolean;
}

export interface ChangeOperationSummary {
  totalAchats: number;
  totalVentes: number;
  nbOperations: number;
}
