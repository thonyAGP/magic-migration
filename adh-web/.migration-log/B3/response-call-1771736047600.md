```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useFacturationAppelStore } from '@/stores/facturationAppelStore';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type {
  HistoriqueAppel,
  FacturationRequest,
  GetHistoriqueAppelsResponse,
  GetCoefficientResponse,
  FacturerAppelResponse,
  GetClotureStatusResponse,
  DebloquerClotureResponse,
  MarquerGratuitResponse,
  AnnulerFacturationResponse,
} from '@/types/facturationAppel';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(() => ({ isRealApi: false })),
  },
}));

const MOCK_APPEL_NON_FACTURE: HistoriqueAppel = {
  id: 1,
  societe: 'SOC1',
  prefixe: 'CAI01',
  dateAppel: new Date('2026-02-20T09:15:00'),
  heureAppel: '09:15:23',
  numeroTel: '+33612345678',
  duree: '00:12:35',
  montant: 1.89,
  qualite: 'OK',
  gratuite: false,
  raisonGratuite: null,
  facture: false,
};

const MOCK_APPEL_FACTURE: HistoriqueAppel = {
  id: 2,
  societe: 'SOC1',
  prefixe: 'CAI01',
  dateAppel: new Date('2026-02-19T14:22:00'),
  heureAppel: '14:22:11',
  numeroTel: '+34912567890',
  duree: '00:05:18',
  montant: 0.80,
  qualite: 'OK',
  gratuite: false,
  raisonGratuite: null,
  facture: true,
  operationId: 10234,
};

const MOCK_APPEL_GRATUIT: HistoriqueAppel = {
  id: 4,
  societe: 'SOC1',
  prefixe: 'CAI02',
  dateAppel: new Date('2026-02-18T16:30:00'),
  heureAppel: '16:30:05',
  numeroTel: '+33145678901',
  duree: '00:02:15',
  montant: 0.34,
  qualite: 'OK',
  gratuite: true,
  raisonGratuite: 'Appel urgence medicale',
  facture: false,
};

const MOCK_HISTORIQUE: HistoriqueAppel[] = [
  MOCK_APPEL_NON_FACTURE,
  MOCK_APPEL_FACTURE,
  {
    id: 3,
    societe: 'SOC1',
    prefixe: 'CAI01',
    dateAppel: new Date('2026-02-19T11:05:00'),
    heureAppel: '11:05:47',
    numeroTel: '+1514555XXXX',
    duree: '00:45:12',
    montant: 35.80,
    qualite: 'Mauvaise',
    gratuite: false,
    raisonGratuite: null,
    facture: false,
  },
  MOCK_APPEL_GRATUIT,
];

describe('facturationAppelStore', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    useFacturationAppelStore.getState().reset();
    vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
  });

  describe('chargerHistoriqueAppels', () => {
    it('should load and filter historique by societe and prefixe in mock mode', async () => {
      const store = useFacturationAppelStore.getState();

      await store.chargerHistoriqueAppels('SOC1', 'CAI01');

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels).toHaveLength(3);
      expect(state.historiqueAppels.every((a) => a.societe === 'SOC1')).toBe(true);
      expect(state.historiqueAppels.every((a) => a.prefixe === 'CAI01')).toBe(true);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should filter by date range when provided', async () => {
      const store = useFacturationAppelStore.getState();
      const dateDebut = new Date('2026-02-19T00:00:00');
      const dateFin = new Date('2026-02-20T23:59:59');

      await store.chargerHistoriqueAppels('SOC1', 'CAI01', dateDebut, dateFin);

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels).toHaveLength(2);
      expect(state.historiqueAppels.every((a) => a.dateAppel >= dateDebut)).toBe(true);
      expect(state.historiqueAppels.every((a) => a.dateAppel <= dateFin)).toBe(true);
    });

    it('should sort historique by date and time descending', async () => {
      const store = useFacturationAppelStore.getState();

      await store.chargerHistoriqueAppels('SOC1', 'CAI01');

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels[0].dateAppel.getTime()).toBeGreaterThanOrEqual(
        state.historiqueAppels[1].dateAppel.getTime()
      );
    });

    it('should load historique from API in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);

      const mockResponse: GetHistoriqueAppelsResponse = {
        success: true,
        data: [MOCK_APPEL_NON_FACTURE],
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce({ data: mockResponse });

      const store = useFacturationAppelStore.getState();
      await store.chargerHistoriqueAppels('SOC1', 'CAI01');

      expect(apiClient.get).toHaveBeenCalledWith(
        expect.stringContaining('/api/facturation-appel/historique')
      );
      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels).toHaveLength(1);
      expect(state.error).toBeNull();
    });

    it('should handle API error when loading historique', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Network error'));

      const store = useFacturationAppelStore.getState();
      await store.chargerHistoriqueAppels('SOC1', 'CAI01');

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels).toHaveLength(0);
      expect(state.error).toBe('Network error');
      expect(state.isLoading).toBe(false);
    });
  });

  describe('recupererCoefficient', () => {
    it('should load coefficient in mock mode', async () => {
      const store = useFacturationAppelStore.getState();

      await store.recupererCoefficient();

      const state = useFacturationAppelStore.getState();
      expect(state.coefficientTelephone).toBe(0.15);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should load coefficient from API in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);

      const mockResponse: GetCoefficientResponse = {
        success: true,
        data: { coefficient: 0.20 },
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce({ data: mockResponse });

      const store = useFacturationAppelStore.getState();
      await store.recupererCoefficient();

      expect(apiClient.get).toHaveBeenCalledWith('/api/facturation-appel/coefficient');
      const state = useFacturationAppelStore.getState();
      expect(state.coefficientTelephone).toBe(0.20);
    });

    it('should handle API error when loading coefficient', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('API error'));

      const store = useFacturationAppelStore.getState();
      await store.recupererCoefficient();

      const state = useFacturationAppelStore.getState();
      expect(state.coefficientTelephone).toBeNull();
      expect(state.error).toBe('API error');
    });
  });

  describe('facturerAppel', () => {
    it('should reject facturation for gratuit appel', async () => {
      const store = useFacturationAppelStore.getState();
      const request: FacturationRequest = {
        appel: MOCK_APPEL_GRATUIT,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Appel gratuit - facturation non autorisée');
      expect(state.isLoading).toBe(false);
    });

    it('should block facturation when cloture is active', async () => {
      const store = useFacturationAppelStore.getState();
      vi.spyOn(store, 'verifierCloture').mockResolvedValueOnce(true);

      const request: FacturationRequest = {
        appel: MOCK_APPEL_NON_FACTURE,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Opération bloquée - clôture en cours');
    });

    it('should facturer appel successfully in mock mode', async () => {
      const store = useFacturationAppelStore.getState();
      useFacturationAppelStore.setState({ historiqueAppels: [MOCK_APPEL_NON_FACTURE] });
      vi.spyOn(store, 'verifierCloture').mockResolvedValueOnce(false);

      const request: FacturationRequest = {
        appel: MOCK_APPEL_NON_FACTURE,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      const updated = state.historiqueAppels.find((a) => a.id === MOCK_APPEL_NON_FACTURE.id);
      expect(updated?.facture).toBe(true);
      expect(updated?.operationId).toBeGreaterThan(0);
      expect(state.error).toBeNull();
    });

    it('should facturer appel via API in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);

      const store = useFacturationAppelStore.getState();
      useFacturationAppelStore.setState({ historiqueAppels: [MOCK_APPEL_NON_FACTURE] });
      vi.spyOn(store, 'verifierCloture').mockResolvedValueOnce(false);

      const mockResponse: FacturerAppelResponse = {
        success: true,
        data: { success: true, operationId: 99999 },
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: mockResponse });

      const request: FacturationRequest = {
        appel: MOCK_APPEL_NON_FACTURE,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      expect(apiClient.post).toHaveBeenCalledWith('/api/facturation-appel/facturer', request);
      const state = useFacturationAppelStore.getState();
      const updated = state.historiqueAppels.find((a) => a.id === MOCK_APPEL_NON_FACTURE.id);
      expect(updated?.facture).toBe(true);
      expect(updated?.operationId).toBe(99999);
    });

    it('should handle API error when facturant appel', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);

      const store = useFacturationAppelStore.getState();
      vi.spyOn(store, 'verifierCloture').mockResolvedValueOnce(false);
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Facturation failed'));

      const request: FacturationRequest = {
        appel: MOCK_APPEL_NON_FACTURE,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Facturation failed');
    });
  });

  describe('verifierCloture', () => {
    it('should return false in mock mode when cloture not active', async () => {
      const store = useFacturationAppelStore.getState();

      const result = await store.verifierCloture();

      expect(result).toBe(false);
      const state = useFacturationAppelStore.getState();
      expect(state.cloture?.cloture_enCours).toBe(false);
    });

    it('should verify cloture status via API in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);

      const mockResponse: GetClotureStatusResponse = {
        success: true,
        data: { cloture_enCours: true, testReseau: 'OK' },
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce({ data: mockResponse });

      const store = useFacturationAppelStore.getState();
      const result = await store.verifierCloture();

      expect(apiClient.get).toHaveBeenCalledWith('/api/facturation-appel/cloture-status');
      expect(result).toBe(true);
      const state = useFacturationAppelStore.getState();
      expect(state.cloture?.cloture_enCours).toBe(true);
    });

    it('should handle API error when verifying cloture', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Cloture check failed'));

      const store = useFacturationAppelStore.getState();
      const result = await store.verifierCloture();

      expect(result).toBe(false);
      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Cloture check failed');
      expect(state.cloture).toBeNull();
    });
  });

  describe('debloquerCloture', () => {
    it('should debloquer cloture in mock mode', async () => {
      useFacturationAppelStore.setState({
        cloture: { cloture_enCours: true, testReseau: 'OK' },
      });

      const store = useFacturationAppelStore.getState();
      await store.debloquerCloture();

      const state = useFacturationAppelStore.getState();
      expect(state.cloture?.cloture_enCours).toBe(false);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should debloquer cloture via API in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      useFacturationAppelStore.setState({
        cloture: { cloture_enCours: true, testReseau: 'OK' },
      });

      const mockResponse: DebloquerClotureResponse = {
        success: true,
        data: { success: true },
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: mockResponse });

      const store = useFacturationAppelStore.getState();
      await store.debloquerCloture();

      expect(apiClient.post).toHaveBeenCalledWith('/api/facturation-appel/debloquer-cloture');
      const state = useFacturationAppelStore.getState();
      expect(state.cloture?.cloture_enCours).toBe(false);
    });

    it('should handle API error when debloquing cloture', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Deblocage failed'));

      const store = useFacturationAppelStore.getState();
      await store.debloquerCloture();

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Deblocage failed');
    });
  });

  describe('marquerGratuit', () => {
    it('should mark appel as gratuit in mock mode', async () => {
      useFacturationAppelStore.setState({ historiqueAppels: [MOCK_APPEL_NON_FACTURE] });

      const store = useFacturationAppelStore.getState();
      await store.marquerGratuit(1, 'Erreur ligne');

      const state = useFacturationAppelStore.getState();
      const updated = state.historiqueAppels.find((a) => a.id === 1);
      expect(updated?.gratuite).toBe(true);
      expect(updated?.raisonGratuite).toBe('Erreur ligne');
      expect(state.error).toBeNull();
    });

    it('should mark appel as gratuit via API in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      useFacturationAppelStore.setState({ historiqueAppels: [MOCK_APPEL_NON_FACTURE] });

      const mockResponse: MarquerGratuitResponse = {
        success: true,
        data: { success: true },
      };
      vi.mocked(apiClient.put).mockResolvedValueOnce({ data: mockResponse });

      const store = useFacturationAppelStore.getState();
      await store.marquerGratuit(1, 'Urgence medicale');

      expect(apiClient.put).toHaveBeenCalledWith(
        '/api/facturation-appel/marquer-gratuit/1',
        { raison: 'Urgence medicale' }
      );
      const state = useFacturationAppelStore.getState();
      const updated = state.historiqueAppels.find((a) => a.id === 1);
      expect(updated?.gratuite).toBe(true);
      expect(updated?.raisonGratuite).toBe('Urgence medicale');
    });

    it('should handle API error when marking gratuit', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.put).mockRejectedValueOnce(new Error('Mark gratuit failed'));

      const store = useFacturationAppelStore.getState();
      await store.marquerGratuit(1, 'Raison');

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Mark gratuit failed');
    });
  });

  describe('annulerFacturation', () => {
    it('should cancel facturation in mock mode', async () => {
      useFacturationAppelStore.setState({ historiqueAppels: [MOCK_APPEL_FACTURE] });

      const store = useFacturationAppelStore.getState();
      await store.annulerFacturation(2);

      const state = useFacturationAppelStore.getState();
      const updated = state.historiqueAppels.find((a) => a.id === 2);
      expect(updated?.facture).toBe(false);
      expect(updated?.operationId).toBeUndefined();
      expect(state.error).toBeNull();
    });

    it('should cancel facturation via API in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      useFacturationAppelStore.setState({ historiqueAppels: [MOCK_APPEL_FACTURE] });

      const mockResponse: AnnulerFacturationResponse = {
        success: true,
        data: { success: true },
      };
      vi.mocked(apiClient.delete).mockResolvedValueOnce({ data: mockResponse });

      const store = useFacturationAppelStore.getState();
      await store.annulerFacturation(2);

      expect(apiClient.delete).toHaveBeenCalledWith('/api/facturation-appel/annuler/2');
      const state = useFacturationAppelStore.getState();
      const updated = state.historiqueAppels.find((a) => a.id === 2);
      expect(updated?.facture).toBe(false);
      expect(updated?.operationId).toBeUndefined();
    });

    it('should handle API error when canceling facturation', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.delete).mockRejectedValueOnce(new Error('Cancel failed'));

      const store = useFacturationAppelStore.getState();
      await store.annulerFacturation(2);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Cancel failed');
    });
  });

  describe('filters', () => {
    it('should update filterSociete', () => {
      const store = useFacturationAppelStore.getState();
      store.setFilterSociete('SOC2');

      const state = useFacturationAppelStore.getState();
      expect(state.filterSociete).toBe('SOC2');
    });

    it('should update filterDateDebut', () => {
      const date = new Date('2026-02-01');
      const store = useFacturationAppelStore.getState();
      store.setFilterDateDebut(date);

      const state = useFacturationAppelStore.getState();
      expect(state.filterDateDebut).toBe(date);
    });

    it('should update filterDateFin', () => {
      const date = new Date('2026-02-28');
      const store = useFacturationAppelStore.getState();
      store.setFilterDateFin(date);

      const state = useFacturationAppelStore.getState();
      expect(state.filterDateFin).toBe(date);
    });

    it('should reset all filters', () => {
      const store = useFacturationAppelStore.getState();
      store.setFilterSociete('SOC1');
      store.setFilterDateDebut(new Date('2026-02-01'));
      store.setFilterDateFin(new Date('2026-02-28'));

      store.resetFilters();

      const state = useFacturationAppelStore.getState();
      expect(state.filterSociete).toBe('');
      expect(state.filterDateDebut).toBeNull();
      expect(state.filterDateFin).toBeNull();
    });
  });

  describe('setError', () => {
    it('should set error message', () => {
      const store = useFacturationAppelStore.getState();
      store.setError('Custom error');

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Custom error');
    });

    it('should clear error message', () => {
      useFacturationAppelStore.setState({ error: 'Some error' });

      const store = useFacturationAppelStore.getState();
      store.setError(null);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      useFacturationAppelStore.setState({
        historiqueAppels: MOCK_HISTORIQUE,
        coefficientTelephone: 0.15,
        cloture: { cloture_enCours: true, testReseau: 'OK' },
        isLoading: true,
        error: 'Some error',
        filterSociete: 'SOC1',
        filterDateDebut: new Date(),
        filterDateFin: new Date(),
      });

      const store = useFacturationAppelStore.getState();
      store.reset();

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels).toHaveLength(0);
      expect(state.coefficientTelephone).toBeNull();
      expect(state.cloture).toBeNull();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.filterSociete).toBe('');
      expect(state.filterDateDebut).toBeNull();
      expect(state.filterDateFin).toBeNull();
    });
  });
});
```