Generate Vitest unit tests for the "reinitAffPyrStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  ReinitAffectationParams,
  ReinitAffectationResponse,
  AffectationStatusResponse,
  ReinitAffPyrState,
} from '@/types/reinitAffPyr';
import { useDataSourceStore } from './dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

interface ReinitAffPyrStore extends ReinitAffPyrState {
  reset: () => void;
}

const initialState: Omit<ReinitAffPyrState, 'reinitAffectationPyr' | 'resetAllAffectations' | 'getAffectationStatus' | 'clearError'> = {
  isProcessing: false,
  error: null,
  lastResetCount: 0,
};

const MOCK_HEBERGEMENT_RECORDS = [
  { societe: 'SOC1', compte: 1001, chambre: '101', affectationPyr: 'P' },
  { societe: 'SOC1', compte: 1001, chambre: '102', affectationPyr: 'H' },
  { societe: 'SOC1', compte: 1002, chambre: '201', affectationPyr: 'P' },
  { societe: 'SOC1', compte: 1002, chambre: '', affectationPyr: 'P' },
  { societe: 'SOC1', compte: 1003, chambre: '301', affectationPyr: null },
  { societe: 'SOC1', compte: 1004, chambre: '401', affectationPyr: 'P' },
  { societe: 'SOC1', compte: 1004, chambre: '', affectationPyr: 'H' },
  { societe: 'SOC2', compte: 2001, chambre: '501', affectationPyr: 'P' },
  { societe: 'SOC2', compte: 2001, chambre: '502', affectationPyr: '' },
  { societe: 'SOC2', compte: 2002, chambre: '', affectationPyr: null },
];

export const useReinitAffPyrStore = create<ReinitAffPyrStore>()((set) => ({
  ...initialState,

  reinitAffectationPyr: async (params: ReinitAffectationParams) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isProcessing: true, error: null });

    if (!isRealApi) {
      await new Promise((resolve) => setTimeout(resolve, 800));
      
      const filtered = MOCK_HEBERGEMENT_RECORDS.filter(
        (r) =>
          r.societe === params.societe &&
          r.compte === params.compte &&
          (params.chambre === undefined || r.chambre === params.chambre),
      );

      const affectedCount = filtered.length;
      
      set({ 
        isProcessing: false, 
        lastResetCount: affectedCount 
      });
      return affectedCount;
    }

    try {
      const queryParams = new URLSearchParams({
        societe: params.societe,
        compte: String(params.compte),
      });
      
      if (params.chambre !== undefined) {
        queryParams.append('chambre', params.chambre);
      }

      const response = await apiClient.post<ApiResponse<ReinitAffectationResponse>>(
        `/api/reinitAffPyr/reset?${queryParams.toString()}`,
      );

      const affectedCount = response.data.data?.affectedCount ?? 0;
      
      set({ 
        lastResetCount: affectedCount,
        isProcessing: false 
      });
      
      return affectedCount;
    } catch (e: unknown) {
      const error = e instanceof Error ? e : new Error('Erreur réinitialisation affectation PYR');
      set({ error, isProcessing: false });
      throw error;
    }
  },

  resetAllAffectations: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isProcessing: true, error: null });

    if (!isRealApi) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      
      const totalCount = MOCK_HEBERGEMENT_RECORDS.length;
      
      set({ 
        isProcessing: false, 
        lastResetCount: totalCount 
      });
      return totalCount;
    }

    try {
      const response = await apiClient.post<ApiResponse<ReinitAffectationResponse>>(
        '/api/reinitAffPyr/reset-all',
      );

      const affectedCount = response.data.data?.affectedCount ?? 0;
      
      set({ 
        lastResetCount: affectedCount,
        isProcessing: false 
      });
      
      return affectedCount;
    } catch (e: unknown) {
      const error = e instanceof Error ? e : new Error('Erreur réinitialisation globale');
      set({ error, isProcessing: false });
      throw error;
    }
  },

  getAffectationStatus: async (societe: string, compte: number) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      const filtered = MOCK_HEBERGEMENT_RECORDS.filter(
        (r) =>
          r.societe === societe &&
          r.compte === compte &&
          r.affectationPyr !== null &&
          r.affectationPyr !== '',
      );

      return {
        hasActiveAffectations: filtered.length > 0,
        count: filtered.length,
      };
    }

    try {
      const queryParams = new URLSearchParams({
        societe,
        compte: String(compte),
      });

      const response = await apiClient.get<ApiResponse<AffectationStatusResponse>>(
        `/api/reinitAffPyr/status?${queryParams.toString()}`,
      );

      return response.data.data ?? { hasActiveAffectations: false, count: 0 };
    } catch (e: unknown) {
      const error = e instanceof Error ? e : new Error('Erreur vérification statut');
      set({ error });
      throw error;
    }
  },

  clearError: () => set({ error: null }),

  reset: () => set({ ...initialState }),
}));

TYPES:
export interface HebergementRecord {
  societe: string;
  compte: number;
  chambre: string;
  affectationPyr: string | null;
}

export interface ReinitAffectationParams {
  societe: string;
  compte: number;
  chambre?: string;
}

export interface ReinitAffectationResponse {
  affectedCount: number;
}

export interface AffectationStatusResponse {
  hasActiveAffectations: boolean;
  count: number;
}

export interface ReinitAffPyrState {
  isProcessing: boolean;
  error: Error | null;
  lastResetCount: number;
  
  reinitAffectationPyr: (params: ReinitAffectationParams) => Promise<number>;
  resetAllAffectations: () => Promise<number>;
  getAffectationStatus: (societe: string, compte: number) => Promise<AffectationStatusResponse>;
  clearError: () => void;
}

export const AFFECTATION_VALUES = {
  EMPTY: '',
  PYR_MARKER: 'P',
  HEBERGEMENT: 'H',
} as const;

export type AffectationValue = typeof AFFECTATION_VALUES[keyof typeof AFFECTATION_VALUES];

ACTIONS TO COVER:
[
  {
    "name": "reinitAffectationPyr",
    "params": [
      "societe: string",
      "compte: number",
      "chambre?: string"
    ],
    "businessRules": [
      "RM-001: Si chambre vide (Trim=''), initialiser à '', sinon à 'P'",
      "Réinitialiser les marqueurs temporaires d'affectation PYR après deversement",
      "Mise à jour de masse sur table hebergement sans validation complexe",
      "Nettoyage automatique des flags d'affectation pour préparer prochaine transaction"
    ],
    "returns": "Promise<number>"
  },
  {
    "name": "resetAllAffectations",
    "params": [],
    "businessRules": [
      "Réinitialiser toutes les affectations PYR indépendamment des filtres",
      "Utilisé lors de clôture de caisse ou maintenance globale"
    ],
    "returns": "Promise<number>"
  }
]