Generate a React page component for the "MoyenPaiement" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

PAGE REQUIREMENTS:
- Use store via useMoyenPaiementStore()
- Destructure 20+ fields from store
- useCallback for event handlers
- useEffect for init + cleanup (call reset on unmount)
- ScreenLayout wrapper from @/components/layout (import { ScreenLayout } from "@/components/layout")
- ScreenLayout takes children + className props (no title prop)
- Tailwind v4 classes for styling
- Handle loading, error, and empty states

UI LAYOUT:
{
  "type": "utility-service",
  "sections": [
    {
      "name": "integration",
      "controls": [
        "Utilisé par les écrans de vente pour afficher le libellé du MOP",
        "Utilisé par les générateurs de tickets pour formatter les moyens de paiement",
        "Utilisé par les écrans de transaction pour valider les MOP saisis"
      ]
    }
  ]
}

STORE INTERFACE (actions and state available):
import { create } from 'zustand';
import type {
  MoyenPaiement,
  MOPInfo,
  TypeDevise,
  ClasseMOP,
} from '@/types/moyenPaiement';
import { useDataSourceStore } from './dataSourceStore';

interface MoyenPaiementState {
  moyensPaiement: MoyenPaiement[];
  selectedMOP: MoyenPaiement | null;
  isLoading: boolean;
  error: string | null;
}

interface MoyenPaiementActions {
  getMOPInfo: (
    codeMOP: string,
    typeDevise: TypeDevise,
  ) => Promise<{ classe: ClasseMOP; libelle: string; existe: boolean }>;
  checkMOPExists: (codeMOP: string, societe: string) => Promise<boolean>;
  getMOPByCode: (codeMOP: string) => Promise<MoyenPaiement | null>;
  setMoyensPaiement: (moyens: MoyenPaiement[]) => void;
  setSelectedMOP: (mop: MoyenPaiement | null) => void;
  setIsLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

type MoyenPaiementStore = MoyenPaiementState & MoyenPaiementActions;

const MOCK_MOYENS_PAIEMENT: MoyenPaiement[] = [
  {
    code: 'CB',
    libelle: 'Carte Bancaire',
    classe: 'UNI',
    typeDevise: 'UNI',
  },
  {
    code: 'ESP',
    libelle: 'Espèces',
    classe: 'UNI',
    typeDevise: 'UNI',
  },
  {
    code: 'CHQ',
    libelle: 'Chèque',
    classe: 'CHQ',
    typeDevise: 'UNI',
  },
  {
    code: 'VIR',
    libelle: 'Virement',
    classe: 'TRANSF',
    typeDevise: 'UNI',
  },
  {
    code: 'CHG',
    libelle: 'Change',
    classe: 'BI',
    typeDevise: 'BI',
  },
  {
    code: 'CBE',
    libelle: 'CB Étranger',
    classe: 'BI',
    typeDevise: 'BI',
  },
  {
    code: 'TRV',
    libelle: 'Chèques Voyage',
    classe: 'BI',
    typeDevise: 'BI',
  },
  {
    code: 'VAC',
    libelle: 'Chèques Vacances',
    classe: 'UNI',
    typeDevise: 'UNI',
  },
  {
    code: 'PRE',
    libelle: 'Prélèvement',
    classe: 'TRANSF',
    typeDevise: 'UNI',
  },
  {
    code: 'AVO',
    libelle: 'Avoir',
    classe: 'UNI',
    typeDevise: 'UNI',
  },
];

const initialState: MoyenPaiementState = {
  moyensPaiement: [],
  selectedMOP: null,
  isLoading: false,
  error: null,
};

export const useMoyenPaiementStore = create<MoyenPaiementStore>()((set) => ({
  ...initialState,

  getMOPInfo: async (codeMOP, typeDevise) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const mop = MOCK_MOYENS_PAIEMENT.find((m) => m.code === codeMOP);
      const result: MOPInfo = mop
        ? {
            classe: mop.classe,
            libelle: mop.libelle,
            existe: true,
          }
        : {
            classe: 'UNI',
            libelle: '',
            existe: false,
          };
      set({ isLoading: false });
      return result;
    }

    try {
      const params = new URLSearchParams({ code: codeMOP });
      if (typeDevise) {
        params.append('typeDevise', typeDevise);
      }

      const response = await fetch(
        `/api/moyenpaiement/info?${params.toString()}`,
      );
      if (!resp

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export type TypeDevise = "UNI" | "BI";
export type ClasseMOP = "UNI" | "BI" | "TRANSF" | "CHQ";

export interface MoyenPaiement {
  code: string;
  libelle: string;
  classe: ClasseMOP;
  typeDevise: TypeDevise;
}

export interface MoyenReglement {
  code: string;
  libelle: string;
}

export interface MOPInfo {
  classe: ClasseMOP;
  libelle: string;
  existe: boolean;
}

export interface MOPExistsResponse {
  existe: boolean;
}

export interface GetMOPInfoRequest {
  code: string;
  typeDevise?: TypeDevise;
}

export interface GetMOPInfoResponse extends ApiResponse {
  data: MOPInfo;
}

export interface CheckMOPExistsRequest {
  code: string;
  societe: string;
}

export interface CheckMOPExistsResponse extends ApiResponse {
  data: MOPExistsResponse;
}

export interface GetMOPByCodeRequest {
  code: string;
}

export interface GetMOPByCodeResponse extends ApiResponse {
  data: MoyenPaiement | null;
}

export interface MoyenPaiementState {
  moyensPaiement: MoyenPaiement[];
  selectedMOP: MoyenPaiement | null;
  isLoading: boolean;
  error: string | null;
}

export interface MoyenPaiementActions {
  getMOPInfo: (
    codeMOP: string,
    typeDevise: TypeDevise
  ) => Promise<{ classe: ClasseMOP; libelle: string; existe: boolean }>;
  checkMOPExists: (codeMOP: string, societe: string) => Promise<boolean>;
  getMOPByCode: (codeMOP: string) => Promise<MoyenPaiement | null>;
  setMoyensPaiement: (moyens: MoyenPaiement[]) => void;
  setSelectedMOP: (mop: MoyenPaiement | null) => void;
  setIsLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

export type MoyenPaiementStore = MoyenPaiementState & MoyenPaiementActions;

SPEC UI DESCRIPTION:
> **Structure**: 4 onglets (Resume | Ecrans | Donnees | Connexions)
| Taches | 3 (0 ecrans visibles) |
ADH IDE 152 - RECUP_CLASSE_MOP est un programme utilitaire critiquement utilisé dans la chaîne des ventes pour récupérer les informations de classification et de libellé d'un moyen de paiement (MOP) donné. Appelé par plus de 15 programmes différents (principalement des écrans de vente et d'impression), ce programme centralise la logique de lookup des MOP, évitant la duplication de code à travers les différents modules de transaction et d'édition. Il prend en entrée le code du MOP et retourne sa classification (UNI ou BI) ainsi que son libellé, informations essentielles pour le routage des transactions et l'affichage des reçus.
Le programme utilise deux tâches principales correspondant aux deux contextes d'utilisation : la tâche UNI pour les transactions en devise unique (opérations simples) et la tâche BI pour les transactions en devises multiples (change). Cette séparation permet une gestion différenciée des MOP selon que la transaction concerne une seule devise ou un échange. Les données proviennent de la table des moyens de paiement référencée (probablement dans REF.ecf), avec une architecture simple de type lookup sans calcul métier complexe, ce qui en fait un service de base robuste et performant pour toute la chaîne transactionnelle des ventes.
- **Appele par**: [ Print ticket vente (IDE 234)](ADH-IDE-234.md), [ Print ticket vente LEX (IDE 235)](ADH-IDE-235.md), [ Print ticket vente PMS-584 (IDE 236)](ADH-IDE-236.md), [ Print ticket vente LEX (IDE 285)](ADH-IDE-285.md), [ Print ticket vente (IDE 323)](ADH-IDE-323.md), [Transaction Nouv vente avec GP (IDE 237)](ADH-IDE-237.md), [Transaction Nouv vente PMS-584 (IDE 238)](ADH-IDE-238.md), [Transaction Nouv vente PMS-721 (IDE 239)](ADH-IDE-239.md), [Transaction Nouv vente PMS-710 (IDE 240)](ADH-IDE-240.md), [Saisie transaction 154  N.U (IDE 307)](ADH-IDE-307.md), [Saisie transaction Nouv vente (IDE 310)](ADH-IDE-310.md), [Saisie transaction Nouv vente (IDE 316)](ADH-IDE-316.md), [Controle fermeture caisse WS (IDE 155)](ADH-IDE-155.md), [Saisie transaction 154 N.U (IDE 300)](ADH-IDE-300.md), [Print ticket vente/OD N.U (IDE 306)](ADH-IDE-306.md)
<!-- TAB:Ecrans -->
## 8. ECRANS
*(Programme sans ecran visible)*
    INIT[Init controles]
Main -> ... -> [Controle fermeture caisse WS (IDE 155)](ADH-IDE-155.md) -> **Recup Classe et Lib du MOP (IDE 152)**
    CC155[155 Controle fermeture...]
| [155](ADH-IDE-155.md) | Controle fermeture caisse WS | 3 |
| Ecrans visibles | 0 | Ecran unique ou traitement batch |
#### Traitement (3 taches: 0 ecran, 3 traitements)

REFERENCE PATTERN:
```tsx
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import {
  ExtraitAccountSelector,
  ExtraitTransactionGrid,
  ExtraitFormatDialog,
} from '@/components/caisse/extrait';
import { EmailSendDialog } from '@/components/caisse/dialogs';
import { useExtraitStore } from '@/stores/extraitStore';
import { useAuthStore } from '@/stores';
import type { ExtraitAccountInfo, ExtraitPrintFormat } from '@/types/extrait';

type Phase = 'search' | 'extrait';

export function ExtraitPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);
  const societe = 'ADH';

  const selectedAccount = useExtraitStore((s) => s.selectedAccount);
  const transactions = useExtraitStore((s) => s.transactions);
  const summary = useExtraitStore((s) => s.summary);
  const searchResults = useExtraitStore((s) => s.searchResults);
  const isSearching = useExtraitStore((s) => s.isSearching);
  const isLoadingExtrait = useExtraitStore((s) => s.isLoadingExtrait);
  const isPrinting = useExtraitStore((s) => s.isPrinting);
  const error = useExtraitStore((s) => s.error);
  const searchAccount = useExtraitStore((s) => s.searchAccount);
  const selectAccount = useExtraitStore((s) => s.selectAccount);
  const loadExtrait = useExtraitStore((s) => s.loadExtrait);
  const printExtrait = useExtraitStore((s) => s.printExtrait);
  const reset = useExtraitStore((s) => s.reset);

  const [phase, setPhase] = useState<Phase>('search');
  const [showFormatDialog, setShowFormatDialog] = useState(false);
  const [showEmailDialog, setShowEmailDialog] = useState(false);

  useEffect(() => {
    return () => reset();
  }, [reset]);

  const handleSelectAccount = useCallback(
    (account: ExtraitAccountInfo) => {
      selectAccount(account);
      loadExtrait(societe, account.codeAdherent, account.filiation);
      setPhase('extrait');
    },
    [selectAccount, loadExtrait, societe],
  );

  const handlePrintFormat = useCallback(
    async (format: ExtraitPrintFormat) => {
      if (!selectedAccount) return;
      await printExtrait(
        societe,
        selectedAccount.codeAdherent,
        selectedAccount.filiation,
        format,
      );
      setShowFormatDialog(false);
    },
    [selectedAccount, printExtrait, societe],
  );

  const handleBack = () => {
    if (phase === 'extrait') {
      reset();
      setPhase('search');
    } else {
      navigate('/caisse/menu');
    }
  };

  return (
    <ScreenLayout>
      <div className="space-y-6 max-w-4xl mx-auto">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold">Extrait de compte</h2>
            <p className="text-on-surface-muted text-sm mt-1">
              {phase === 'search'
                ? 'Rechercher un compte adherent'
                : `Compte: ${selectedAccount?.nom} ${selectedAccount?.prenom} #${selectedAccount?.codeAdherent}`}
            </p>
          </div>
          {user && (
            <span className="text-xs text-on-surface-muted">
              {user.prenom} {user.nom}
            </span>
          )}
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md text-sm">
            {error}
          </div>
        )}

        {phase === 'search' && (
          <>
            <ExtraitAccountSelector
              onSelect={handleSelectAccount}
              onSearch={(q) => searchAccount(societe, q)}
              searchResults={searchResults}
              isSearching={isSearching}
              isLoading={isLoadingExtrait}
            />
            <div className="flex justify-start">
              <button
                onClick={handleBack}
                className="px-4 py-2 border border-border rounded-md text-on-surface hover:bg-surface-hover"
              >
                Retour au menu
              </button>
            </div>
          </>
        )}

        {phase === 'extrait' && (
          <>
            <ExtraitTransactionGrid
              transactions={transactions}
              summary={summary}
              isLoading={isLoadingExtrait}
            />

            <div className="flex gap-3 justify-between">
              <button
                onClick={handleBack}
                className="px-4 py-2 border border-border rounded-md text-on-surface hover:bg-surface-hover"
              >
                Nouvelle recherche
              </button>
              <div className="flex gap-3">
                <button
                  onClick={() => setShowEmailDialog(true)}
                  className="px-4 py-2 border border-border rounded-md text-on-surface hover:bg-surface-hover"
                >
                  Envoyer par email
                </button>
                <button
                  onClick={() => setShowFormatDialog(true)}
                  className="px-4 py-2 bg-primary text-white rounded-md hover:bg-primary-dark"
                >
                  Imprimer
                </button>
              </div>
            </div>

            <ExtraitFormatDialog
              open={showFormatDialog}
              onClose={() => setShowFormatDialog(false)}
              onSelectFormat={handlePrintFormat}
              isPrinting={isPrinting}
            />

            <EmailSendDialog
              open={showEmailDialog}
              onClose={() => setShowEmailDialog(false)}
              documentType="extrait"
              documentId={selectedAccount ? String(selectedAccount.codeAdherent) : ''}
            />
          </>
        )}
      </div>
    </ScreenLayout>
  );
}

```