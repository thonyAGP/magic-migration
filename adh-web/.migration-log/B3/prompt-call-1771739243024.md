Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/titleLookupStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
titleLookupStore loadTitles should set loading state while loading: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/titleLookupStore.test.ts:121:56
    at file:///D:/Projects/Lecteur_Magic/adh-web/

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useTitleLookupStore } from '@/stores/titleLookupStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import type { Title } from '@/types/titleLookup';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
  },
}));

const MOCK_TITLES: Title[] = [
  { code: 'M', label: 'M.', type: 'CA' },
  { code: 'MME', label: 'Mme', type: 'CA' },
  { code: 'MLLE', label: 'Mlle', type: 'CA' },
  { code: 'DR', label: 'Dr', type: 'CA' },
  { code: 'M', label: 'Mr', type: 'CB' },
  { code: 'MME', label: 'Mrs', type: 'CB' },
];

describe('titleLookupStore', () => {
  beforeEach(() => {
    useTitleLookupStore.getState().reset();
    useDataSourceStore.setState({ isRealApi: false });
    vi.clearAllMocks();
  });

  describe('getTitleByCode', () => {
    it('should return label from mock data when code exists (CA type)', async () => {
      const result = await useTitleLookupStore.getState().getTitleByCode('M', 'CA');

      expect(result).toBe('M.');
    });

    it('should return label from mock data when code exists (CB type)', async () => {
      const result = await useTitleLookupStore.getState().getTitleByCode('MME', 'CB');

      expect(result).toBe('Mrs');
    });

    it('should use CA as default programType when not provided (RM-001)', async () => {
      const result = await useTitleLookupStore.getState().getTitleByCode('MME');

      expect(result).toBe('Mme');
    });

    it('should return code when title not found in mock data', async () => {
      const result = await useTitleLookupStore.getState().getTitleByCode('UNKNOWN', 'CA');

      expect(result).toBe('UNKNOWN');
    });

    it('should call API with correct params when using real API', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<{ label: string }> = {
        success: true,
        data: { label: 'Monsieur' },
      };
      vi.mocked(apiClient.get).mockResolvedValue({ data: mockResponse });

      const result = await useTitleLookupStore.getState().getTitleByCode('M', 'CA');

      expect(apiClient.get).toHaveBeenCalledWith('/api/titles/M?programType=CA');
      expect(result).toBe('Monsieur');
    });

    it('should use CA as default programType in API call when not provided', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<{ label: string }> = {
        success: true,
        data: { label: 'Madame' },
      };
      vi.mocked(apiClient.get).mockResolvedValue({ data: mockResponse });

      await useTitleLookupStore.getState().getTitleByCode('MME');

      expect(apiClient.get).toHaveBeenCalledWith('/api/titles/MME?programType=CA');
    });

    it('should return code when API returns no data', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<{ label: string }> = {
        success: true,
        data: null,
      };
      vi.mocked(apiClient.get).mockResolvedValue({ data: mockResponse });

      const result = await useTitleLookupStore.getState().getTitleByCode('M', 'CA');

      expect(result).toBe('M');
    });

    it('should set error and return code when API call fails', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const error = new Error('Network error');
      vi.mocked(apiClient.get).mockRejectedValue(error);

      const result = await useTitleLookupStore.getState().getTitleByCode('M', 'CA');

      expect(result).toBe('M');
      expect(useTitleLookupStore.getState().error).toBe('Network error');
    });

    it('should set generic error message when error is not an Error instance', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValue('string error');

      const result = await useTitleLookupStore.getState().getTitleByCode('M', 'CA');

      expect(result).toBe('M');
      expect(useTitleLookupStore.getState().error).toBe('Erreur recherche titre');
    });
  });

  describe('loadTitles', () => {
    it('should set loading state while loading', async () => {
      const loadPromise = useTitleLookupStore.getState().loadTitles();
      
      expect(useTitleLookupStore.getState().isLoading).toBe(true);
      
      await loadPromise;
      
      expect(useTitleLookupStore.getState().isLoading).toBe(false);
    });

    it('should load mock titles when using mock data', async () => {
      await useTitleLookupStore.getState().loadTitles();

      expect(useTitleLookupStore.getState().titles).toHaveLength(8);
      expect(useTitleLookupStore.getState().titles[0]).toEqual({ code: 'M', label: 'M.', type: 'CA' });
    });

    it('should call API and set titles when using real API', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<Title[]> = {
        success: true,
        data: [
          { code: 'M', label: 'Monsieur', type: 'CA' },
          { code: 'MME', label: 'Madame', type: 'CA' },
        ],
      };
      vi.mocked(apiClient.get).mockResolvedValue({ data: mockResponse });

      await useTitleLookupStore.getState().loadTitles();

      expect(apiClient.get).toHaveBeenCalledWith('/api/titles');
      expect(useTitleLookupStore.getState().titles).toHaveLength(2);
      expect(useTitleLookupStore.getState().titles[0]).toEqual({ code: 'M', label: 'Monsieur', type: 'CA' });
    });

    it('should set empty array when API returns no data', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<Title[]> = {
        success: true,
        data: null,
      };
      vi.mocked(apiClient.get).mockResolvedValue({ data: mockResponse });

      await useTitleLookupStore.getState().loadTitles();

      expect(useTitleLookupStore.getState().titles).toEqual([]);
    });

    it('should clear error before loading', async () => {
      useTitleLookupStore.setState({ error: 'Previous error' });

      await useTitleLookupStore.getState().loadTitles();

      expect(useTitleLookupStore.getState().error).toBeNull();
    });

    it('should set error and empty titles when API call fails', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const error = new Error('API error');
      vi.mocked(apiClient.get).mockRejectedValue(error);

      await useTitleLookupStore.getState().loadTitles();

      expect(useTitleLookupStore.getState().error).toBe('API error');
      expect(useTitleLookupStore.getState().titles).toEqual([]);
      expect(useTitleLookupStore.getState().isLoading).toBe(false);
    });

    it('should set generic error message when error is not an Error instance', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValue('string error');

      await useTitleLookupStore.getState().loadTitles();

      expect(useTitleLookupStore.getState().error).toBe('Erreur chargement titres');
    });
  });

  describe('setTitles', () => {
    it('should update titles state', () => {
      const newTitles: Title[] = [
        { code: 'TEST', label: 'Test', type: 'CA' },
      ];

      useTitleLookupStore.getState().setTitles(newTitles);

      expect(useTitleLookupStore.getState().titles).toEqual(newTitles);
    });
  });

  describe('setIsLoading', () => {
    it('should update loading state to true', () => {
      useTitleLookupStore.getState().setIsLoading(true);

      expect(useTitleLookupStore.getState().isLoading).toBe(true);
    });

    it('should update loading state to false', () => {
      useTitleLookupStore.setState({ isLoading: true });

      useTitleLookupStore.getState().setIsLoading(false);

      expect(useTitleLookupStore.getState().isLoading).toBe(false);
    });
  });

  describe('setError', () => {
    it('should update error state', () => {
      useTitleLookupStore.getState().setError('Test error');

      expect(useTitleLookupStore.getState().error).toBe('Test error');
    });

    it('should clear error when set to null', () => {
      useTitleLookupStore.setState({ error: 'Previous error' });

      useTitleLookupStore.getState().setError(null);

      expect(useTitleLookupStore.getState().error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset state to initial values', () => {
      useTitleLookupStore.setState({
        titles: [{ code: 'M', label: 'M.', type: 'CA' }],
        isLoading: true,
        error: 'Some error',
      });

      useTitleLookupStore.getState().reset();

      expect(useTitleLookupStore.getState().titles).toEqual([]);
      expect(useTitleLookupStore.getState().isLoading).toBe(false);
      expect(useTitleLookupStore.getState().error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type { Title, TitleLookupState } from '@/types/titleLookup';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

const MOCK_TITLES: Title[] = [
  { code: 'M', label: 'M.', type: 'CA' },
  { code: 'MME', label: 'Mme', type: 'CA' },
  { code: 'MLLE', label: 'Mlle', type: 'CA' },
  { code: 'DR', label: 'Dr', type: 'CA' },
  { code: 'PR', label: 'Pr', type: 'CA' },
  { code: 'M', label: 'Mr', type: 'CB' },
  { code: 'MME', label: 'Mrs', type: 'CB' },
  { code: 'MLLE', label: 'Miss', type: 'CB' },
];

const initialState = {
  titles: [] as Title[],
  isLoading: false,
  error: null as string | null,
};

export const useTitleLookupStore = create<TitleLookupState>()((set, get) => ({
  ...initialState,

  getTitleByCode: async (code, programType) => {
    const { isRealApi } = useDataSourceStore.getState();
    const effectiveType = programType || 'CA';

    if (!isRealApi) {
      const title = MOCK_TITLES.find(
        (t) => t.code === code && t.type === effectiveType,
      );
      return title?.label ?? code;
    }

    try {
      const response = await apiClient.get<ApiResponse<{ label: string }>>(
        `/api/titles/${code}?programType=${effectiveType}`,
      );
      return response.data.data?.label ?? code;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur recherche titre';
      set({ error: message });
      return code;
    }
  },

  loadTitles: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({ titles: MOCK_TITLES, isLoading: false });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<Title[]>>('/api/titles');
      set({ titles: response.data.data ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement titres';
      set({ titles: [], error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  setTitles: (titles) => set({ titles }),

  setIsLoading: (loading) => set({ isLoading: loading }),

  setError: (error) => set({ error }),

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.