```typescript
import { create } from 'zustand';
import type {
  HistoriqueAppel,
  FacturationAppelFilters,
  CompteType,
  ChargerHistoriquesAppelsResponse,
  RecupererCoefficientResponse,
  VerifierClotureEnCoursResponse,
  DebloquerClotureResponse,
  CreerFactureAppelResponse,
  MarquerAppelGratuitResponse,
} from '@/types/facturationAppel';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface FacturationAppelState {
  historiquesAppels: HistoriqueAppel[];
  coefficientTelephone: number | null;
  clotureEnCours: boolean;
  testReseau: string;
  isLoading: boolean;
  error: string | null;
  filters: FacturationAppelFilters;
}

interface FacturationAppelActions {
  chargerHistoriquesAppels: (societe: string, dateDebut?: Date, dateFin?: Date) => Promise<void>;
  recupererCoefficient: (societe: string) => Promise<number>;
  verifierClotureEnCours: (societe: string) => Promise<boolean>;
  debloquerCloture: (societe: string) => Promise<void>;
  creerFactureAppel: (appel: HistoriqueAppel, typeCompte: CompteType) => Promise<void>;
  marquerAppelGratuit: (appelId: number, raison: string) => Promise<void>;
  setFilters: (filters: FacturationAppelFilters) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

type FacturationAppelStore = FacturationAppelState & FacturationAppelActions;

const MOCK_APPELS: HistoriqueAppel[] = [
  {
    id: 1,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-20T09:15:00'),
    heureAppel: '09:15:23',
    numeroTel: '+33612345678',
    duree: '00:12:45',
    montant: 5.25,
    qualite: 'Bonne',
    gratuite: false,
    raisonGratuite: null,
  },
  {
    id: 2,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-20T10:30:00'),
    heureAppel: '10:30:12',
    numeroTel: '+33687654321',
    duree: '00:05:30',
    montant: 2.75,
    qualite: 'Bonne',
    gratuite: false,
    raisonGratuite: null,
  },
  {
    id: 3,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-20T14:45:00'),
    heureAppel: '14:45:08',
    numeroTel: '+33698765432',
    duree: '00:00:45',
    montant: 0.50,
    qualite: 'Acceptable',
    gratuite: false,
    raisonGratuite: null,
  },
  {
    id: 4,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-19T11:20:00'),
    heureAppel: '11:20:55',
    numeroTel: '+33612348765',
    duree: '00:18:30',
    montant: 0,
    qualite: 'Bonne',
    gratuite: true,
    raisonGratuite: 'Erreur facturation',
  },
  {
    id: 5,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-19T15:10:00'),
    heureAppel: '15:10:42',
    numeroTel: '+33687651234',
    duree: '00:08:15',
    montant: 3.50,
    qualite: 'Mauvaise',
    gratuite: false,
    raisonGratuite: null,
  },
  {
    id: 6,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-19T16:25:00'),
    heureAppel: '16:25:18',
    numeroTel: '+33698761234',
    duree: '00:22:10',
    montant: 8.00,
    qualite: 'Bonne',
    gratuite: false,
    raisonGratuite: null,
  },
  {
    id: 7,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-18T09:05:00'),
    heureAppel: '09:05:33',
    numeroTel: '+33612347890',
    duree: '00:03:20',
    montant: 1.75,
    qualite: 'Acceptable',
    gratuite: false,
    raisonGratuite: null,
  },
  {
    id: 8,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-18T13:40:00'),
    heureAppel: '13:40:27',
    numeroTel: '+33687659876',
    duree: '00:15:00',
    montant: 0,
    qualite: 'Bonne',
    gratuite: true,
    raisonGratuite: 'Appel service',
  },
  {
    id: 9,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-18T17:15:00'),
    heureAppel: '17:15:49',
    numeroTel: '+33698754321',
    duree: '00:06:45',
    montant: 2.95,
    qualite: 'Bonne',
    gratuite: false,
    raisonGratuite: null,
  },
  {
    id: 10,
    societe: 'SOC1',
    dateAppel: new Date('2026-02-18T18:30:00'),
    heureAppel: '18:30:11',
    numeroTel: '+33612349876',
    duree: '00:11:30',
    montant: 4.75,
    qualite: 'Acceptable',
    gratuite: false,
    raisonGratuite: null,
  },
];

const MOCK_COEFFICIENT = 1.35;

const initialState: FacturationAppelState = {
  historiquesAppels: [],
  coefficientTelephone: null,
  clotureEnCours: false,
  testReseau: '',
  isLoading: false,
  error: null,
  filters: {},
};

export const useFacturationAppelStore = create<FacturationAppelStore>()((set, get) => ({
  ...initialState,

  chargerHistoriquesAppels: async (societe, dateDebut, dateFin) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      let filtered = [...MOCK_APPELS];
      
      if (dateDebut) {
        filtered = filtered.filter((a) => a.dateAppel >= dateDebut);
      }
      if (dateFin) {
        filtered = filtered.filter((a) => a.dateAppel <= dateFin);
      }
      
      const { numeroTel } = get().filters;
      if (numeroTel) {
        filtered = filtered.filter((a) =>
          a.numeroTel.toLowerCase().includes(numeroTel.toLowerCase()),
        );
      }

      filtered.sort((a, b) => {
        const dateCompare = b.dateAppel.getTime() - a.dateAppel.getTime();
        if (dateCompare !== 0) return dateCompare;
        return b.heureAppel.localeCompare(a.heureAppel);
      });

      set({ historiquesAppels: filtered, isLoading: false });
      return;
    }

    try {
      const params = new URLSearchParams({ societe });
      if (dateDebut) params.append('dateDebut', dateDebut.toISOString().split('T')[0]);
      if (dateFin) params.append('dateFin', dateFin.toISOString().split('T')[0]);
      const { numeroTel } = get().filters;
      if (numeroTel) params.append('numeroTel', numeroTel);

      const response = await apiClient.get<ApiResponse<ChargerHistoriquesAppelsResponse>>(
        `/api/facturation-appel/historiques?${params.toString()}`,
      );
      set({ historiquesAppels: response.data.data?.data ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement historiques appels';
      set({ historiquesAppels: [], error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  recupererCoefficient: async (societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({ coefficientTelephone: MOCK_COEFFICIENT, isLoading: false });
      return MOCK_COEFFICIENT;
    }

    try {
      const response = await apiClient.get<ApiResponse<RecupererCoefficientResponse>>(
        `/api/facturation-appel/coefficient/${societe}`,
      );
      const coefficient = response.data.data?.data.coefficient ?? 1.0;
      set({ coefficientTelephone: coefficient });
      return coefficient;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur récupération coefficient';
      set({ error: message, coefficientTelephone: 1.0 });
      return 1.0;
    } finally {
      set({ isLoading: false });
    }
  },

  verifierClotureEnCours: async (societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({ clotureEnCours: false, testReseau: 'OK', isLoading: false });
      return false;
    }

    try {
      const response = await apiClient.get<ApiResponse<VerifierClotureEnCoursResponse>>(
        `/api/facturation-appel/cloture-status/${societe}`,
      );
      const data = response.data.data?.data;
      const clotureEnCours = data?.clotureEnCours ?? false;
      const testReseau = data?.testReseau ?? '';
      set({ clotureEnCours, testReseau });
      return clotureEnCours;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur vérification clôture';
      set({ error: message, clotureEnCours: false, testReseau: '' });
      return false;
    } finally {
      set({ isLoading: false });
    }
  },

  debloquerCloture: async (societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({ clotureEnCours: false, testReseau: 'OK', isLoading: false });
      return;
    }

    try {
      await apiClient.post<ApiResponse<DebloquerClotureResponse>>(
        '/api/facturation-appel/debloquer-cloture',
        { societe },
      );
      set({ clotureEnCours: false, testReseau: 'OK' });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur déblocage clôture';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  creerFactureAppel: async (appel, typeCompte) => {
    const { isRealApi } = useDataSourceStore.getState();
    const { coefficientTelephone } = get();
    set({ isLoading: true, error: null });

    if (appel.gratuite) {
      set({ isLoading: false });
      return;
    }

    if (!isRealApi) {
      const montantFacture = appel.montant * (coefficientTelephone ?? 1.0);
      set({ isLoading: false });
      return;
    }

    try {
      await apiClient.post<ApiResponse<CreerFactureAppelResponse>>(
        '/api/facturation-appel/creer-facture',
        {
          appel,
          typeCompte,
          coefficientTelephone: coefficientTelephone ?? 1.0,
        },
      );
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur création facture';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  marquerAppelGratuit: async (appelId, raison) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const updated = get().historiquesAppels.map((a) =>
        a.id === appelId
          ? { ...a, gratuite: true, raisonGratuite: raison, montant: 0 }
          : a,
      );
      set({ historiquesAppels: updated, isLoading: false });
      return;
    }

    try {
      await apiClient.patch<ApiResponse<MarquerAppelGratuitResponse>>(
        `/api/facturation-appel/marquer-gratuit/${appelId}`,
        { raison },
      );
      
      const updated = get().historiquesAppels.map((a) =>
        a.id === appelId
          ? { ...a, gratuite: true, raisonGratuite: raison, montant: 0 }
          : a,
      );
      set({ historiquesAppels: updated });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur marquage appel gratuit';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  setFilters: (filters) => set({ filters }),

  setError: (error) => set({ error }),

  reset: () => set({ ...initialState }),
}));
```