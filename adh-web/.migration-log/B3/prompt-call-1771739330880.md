Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/villageAddressStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
villageAddressStore setVillageAddress should set loading state during operation: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/villageAddressStore.test.ts:108:59
    at file:///D:/Projects/Lecteur_Magic/adh-w
villageAddressStore setVillageAddress should handle null optional fields in API mode: AssertionError: expected { clubCode: 'CLUB002', …(8) } to not have property "phone"
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/villageAddressStore.test.ts:190:27
    at processTicksAndReje
villageAddressStore loadVillageAddress should set loading state during operation: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/villageAddressStore.test.ts:271:59
    at file:///D:/Projects/Lecteur_Magic/adh-w

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useVillageAddressStore } from '@/stores/villageAddressStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import type {
  VillageAddress,
  SetVillageAddressResponse,
  GetVillageAddressResponse,
} from '@/types/villageAddress';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    put: vi.fn(),
  },
}));

const MOCK_ADDRESS: VillageAddress = {
  clubCode: 'CLUB001',
  name: 'Village Principal',
  address1: '123 Rue de la Paix',
  address2: 'Bâtiment A',
  zipCode: '75001',
  phone: '+33123456789',
  email: 'contact@village.fr',
  siret: '12345678901234',
  vatNumber: 'FR12345678901',
};

const MOCK_ADDRESS_WITH_WHITESPACE: VillageAddress = {
  clubCode: 'CLUB001',
  name: 'Village Principal',
  address1: '123 Rue de la Paix',
  address2: 'Bâtiment A',
  zipCode: '  75001  ',
  phone: '  +33123456789  ',
  email: '  contact@village.fr  ',
  siret: '  12345678901234  ',
  vatNumber: '  FR12345678901  ',
};

const MOCK_ADDRESS_MINIMAL: VillageAddress = {
  clubCode: 'CLUB002',
  name: 'Village Minimal',
  address1: '456 Avenue du Soleil',
  address2: null,
  zipCode: '13001',
  phone: null,
  email: null,
  siret: null,
  vatNumber: null,
};

describe('villageAddressStore', () => {
  beforeEach(() => {
    useVillageAddressStore.setState({
      villageAddress: null,
      isLoading: false,
      error: null,
    });
    useDataSourceStore.setState({ isRealApi: false });
    vi.clearAllMocks();
  });

  describe('setVillageAddress', () => {
    it('should set village address in mock mode', async () => {
      const { setVillageAddress } = useVillageAddressStore.getState();

      await setVillageAddress(MOCK_ADDRESS);

      const state = useVillageAddressStore.getState();
      expect(state.villageAddress).toEqual(MOCK_ADDRESS);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should trim whitespace from optional fields in mock mode', async () => {
      const { setVillageAddress } = useVillageAddressStore.getState();

      await setVillageAddress(MOCK_ADDRESS_WITH_WHITESPACE);

      const state = useVillageAddressStore.getState();
      expect(state.villageAddress?.zipCode).toBe('75001');
      expect(state.villageAddress?.phone).toBe('+33123456789');
      expect(state.villageAddress?.email).toBe('contact@village.fr');
      expect(state.villageAddress?.siret).toBe('12345678901234');
      expect(state.villageAddress?.vatNumber).toBe('FR12345678901');
    });

    it('should handle address with null optional fields in mock mode', async () => {
      const { setVillageAddress } = useVillageAddressStore.getState();

      await setVillageAddress(MOCK_ADDRESS_MINIMAL);

      const state = useVillageAddressStore.getState();
      expect(state.villageAddress).toEqual(MOCK_ADDRESS_MINIMAL);
      expect(state.villageAddress?.phone).toBeNull();
      expect(state.villageAddress?.email).toBeNull();
      expect(state.villageAddress?.siret).toBeNull();
      expect(state.villageAddress?.vatNumber).toBeNull();
    });

    it('should set loading state during operation', async () => {
      const { setVillageAddress } = useVillageAddressStore.getState();

      const promise = setVillageAddress(MOCK_ADDRESS);
      expect(useVillageAddressStore.getState().isLoading).toBe(true);

      await promise;
      expect(useVillageAddressStore.getState().isLoading).toBe(false);
    });

    it('should set village address via API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.put).mockResolvedValueOnce({
        data: {
          success: true,
          data: { success: true, message: 'Adresse mise à jour' },
        },
      } as ApiResponse<SetVillageAddressResponse>);

      const { setVillageAddress } = useVillageAddressStore.getState();
      await setVillageAddress(MOCK_ADDRESS);

      expect(apiClient.put).toHaveBeenCalledWith('/api/village-address', {
        clubCode: 'CLUB001',
        name: 'Village Principal',
        address1: '123 Rue de la Paix',
        address2: 'Bâtiment A',
        zipCode: '75001',
        phone: '+33123456789',
        email: 'contact@village.fr',
        siret: '12345678901234',
        vatNumber: 'FR12345678901',
      });

      const state = useVillageAddressStore.getState();
      expect(state.villageAddress).toEqual(MOCK_ADDRESS);
      expect(state.error).toBeNull();
    });

    it('should trim whitespace before API call in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.put).mockResolvedValueOnce({
        data: {
          success: true,
          data: { success: true },
        },
      } as ApiResponse<SetVillageAddressResponse>);

      const { setVillageAddress } = useVillageAddressStore.getState();
      await setVillageAddress(MOCK_ADDRESS_WITH_WHITESPACE);

      expect(apiClient.put).toHaveBeenCalledWith(
        '/api/village-address',
        expect.objectContaining({
          zipCode: '75001',
          phone: '+33123456789',
          email: 'contact@village.fr',
          siret: '12345678901234',
          vatNumber: 'FR12345678901',
        }),
      );
    });

    it('should handle null optional fields in API mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.put).mockResolvedValueOnce({
        data: {
          success: true,
          data: { success: true },
        },
      } as ApiResponse<SetVillageAddressResponse>);

      const { setVillageAddress } = useVillageAddressStore.getState();
      await setVillageAddress(MOCK_ADDRESS_MINIMAL);

      expect(apiClient.put).toHaveBeenCalledWith(
        '/api/village-address',
        expect.objectContaining({
          clubCode: 'CLUB002',
          name: 'Village Minimal',
          address1: '456 Avenue du Soleil',
          zipCode: '13001',
        }),
      );

      const payload = vi.mocked(apiClient.put).mock.calls[0][1];
      expect(payload).not.toHaveProperty('phone');
      expect(payload).not.toHaveProperty('email');
      expect(payload).not.toHaveProperty('siret');
      expect(payload).not.toHaveProperty('vatNumber');
    });

    it('should handle API error response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.put).mockResolvedValueOnce({
        data: {
          success: false,
          error: 'Code club invalide',
        },
      } as ApiResponse<SetVillageAddressResponse>);

      const { setVillageAddress } = useVillageAddressStore.getState();
      await setVillageAddress(MOCK_ADDRESS);

      const state = useVillageAddressStore.getState();
      expect(state.error).toBe('Code club invalide');
      expect(state.villageAddress).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should handle API network error', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.put).mockRejectedValueOnce(
        new Error('Network error'),
      );

      const { setVillageAddress } = useVillageAddressStore.getState();
      await setVillageAddress(MOCK_ADDRESS);

      const state = useVillageAddressStore.getState();
      expect(state.error).toBe('Network error');
      expect(state.isLoading).toBe(false);
    });

    it('should handle unknown error type', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.put).mockRejectedValueOnce('Unknown error');

      const { setVillageAddress } = useVillageAddressStore.getState();
      await setVillageAddress(MOCK_ADDRESS);

      const state = useVillageAddressStore.getState();
      expect(state.error).toBe('Erreur mise à jour adresse');
      expect(state.isLoading).toBe(false);
    });

    it('should clear previous error on new request', async () => {
      useVillageAddressStore.setState({ error: 'Previous error' });

      const { setVillageAddress } = useVillageAddressStore.getState();
      await setVillageAddress(MOCK_ADDRESS);

      const state = useVillageAddressStore.getState();
      expect(state.error).toBeNull();
    });
  });

  describe('loadVillageAddress', () => {
    it('should load mock data in mock mode', async () => {
      const { loadVillageAddress } = useVillageAddressStore.getState();

      const result = await loadVillageAddress();

      expect(result).toBeDefined();
      expect(result?.clubCode).toBe('CLUB001');
      expect(result?.name).toBe('Village Principal');

      const state = useVillageAddressStore.getState();
      expect(state.villageAddress).toEqual(result);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should set loading state during operation', async () => {
      const { loadVillageAddress } = useVillageAddressStore.getState();

      const promise = loadVillageAddress();
      expect(useVillageAddressStore.getState().isLoading).toBe(true);

      await promise;
      expect(useVillageAddressStore.getState().isLoading).toBe(false);
    });

    it('should load data from API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const apiResponse: GetVillageAddressResponse = {
        ...MOCK_ADDRESS,
        retrievedAt: '2026-02-21T10:00:00Z',
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: {
          success: true,
          data: apiResponse,
        },
      } as ApiResponse<GetVillageAddressResponse>);

      const { loadVillageAddress } = useVillageAddressStore.getState();
      const result = await loadVillageAddress();

      expect(apiClient.get).toHaveBeenCalledWith('/api/village-address');
      expect(result).toEqual(MOCK_ADDRESS);

      const state = useVillageAddressStore.getState();
      expect(state.villageAddress).toEqual(MOCK_ADDRESS);
      expect(state.error).toBeNull();
    });

    it('should handle API error response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: {
          success: false,
          error: 'Adresse non trouvée',
        },
      } as ApiResponse<GetVillageAddressResponse>);

      const { loadVillageAddress } = useVillageAddressStore.getState();
      const result = await loadVillageAddress();

      expect(result).toBeNull();

      const state = useVillageAddressStore.getState();
      expect(state.error).toBe('Adresse non trouvée');
      expect(state.villageAddress).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should handle missing data in API response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: {
          success: true,
          data: null,
        },
      } as unknown as ApiResponse<GetVillageAddressResponse>);

      const { loadVillageAddress } = useVillageAddressStore.getState();
      const result = await loadVillageAddress();

      expect(result).toBeNull();

      const state = useVillageAddressStore.getState();
      expect(state.error).toBe('Aucune adresse village trouvée');
      expect(state.isLoading).toBe(false);
    });

    it('should handle API network error', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce(
        new Error('Connection timeout'),
      );

      const { loadVillageAddress } = useVillageAddressStore.getState();
      const result = await loadVillageAddress();

      expect(result).toBeNull();

      const state = useVillageAddressStore.getState();
      expect(state.error).toBe('Connection timeout');
      expect(state.isLoading).toBe(false);
    });

    it('should handle unknown error type', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce('Unknown error');

      const { loadVillageAddress } = useVillageAddressStore.getState();
      const result = await loadVillageAddress();

      expect(result).toBeNull();

      const state = useVillageAddressStore.getState();
      expect(state.error).toBe('Erreur chargement adresse');
      expect(state.isLoading).toBe(false);
    });

    it('should clear previous error on new request', async () => {
      useVillageAddressStore.setState({ error: 'Previous error' });

      const { loadVillageAddress } = useVillageAddressStore.getState();
      await loadVillageAddress();

      const stateAfter = useVillageAddressStore.getState();
      expect(stateAfter.error).toBeNull();
    });
  });

  describe('clearError', () => {
    it('should clear error state', () => {
      useVillageAddressStore.setState({ error: 'Test error' });

      const { clearError } = useVillageAddressStore.getState();
      clearError();

      const state = useVillageAddressStore.getState();
      expect(state.error).toBeNull();
    });

    it('should not affect other state properties', () => {
      useVillageAddressStore.setState({
        villageAddress: MOCK_ADDRESS,
        error: 'Test error',
        isLoading: true,
      });

      const { clearError } = useVillageAddressStore.getState();
      clearError();

      const state = useVillageAddressStore.getState();
      expect(state.error).toBeNull();
      expect(state.villageAddress).toEqual(MOCK_ADDRESS);
      expect(state.isLoading).toBe(true);
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', () => {
      useVillageAddressStore.setState({
        villageAddress: MOCK_ADDRESS,
        isLoading: true,
        error: 'Test error',
      });

      const { reset } = useVillageAddressStore.getState();
      reset();

      const state = useVillageAddressStore.getState();
      expect(state.villageAddress).toBeNull();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  VillageAddress,
  VillageAddressState,
  SetVillageAddressRequest,
  SetVillageAddressResponse,
  GetVillageAddressResponse,
} from '@/types/villageAddress';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

interface VillageAddressActions {
  setVillageAddress: (address: VillageAddress) => Promise<void>;
  loadVillageAddress: () => Promise<VillageAddress | null>;
  clearError: () => void;
  reset: () => void;
}

type VillageAddressStore = VillageAddressState & VillageAddressActions;

const MOCK_VILLAGE: VillageAddress = {
  clubCode: 'CLUB001',
  name: 'Village Principal',
  address1: '123 Rue de la Paix',
  address2: 'Bâtiment A',
  zipCode: '75001',
  phone: '+33123456789',
  email: 'contact@village.fr',
  siret: '12345678901234',
  vatNumber: 'FR12345678901',
};

const initialState: VillageAddressState = {
  villageAddress: null,
  isLoading: false,
  error: null,
  setVillageAddress: async () => {},
  loadVillageAddress: async () => null,
  clearError: () => {},
};

export const useVillageAddressStore = create<VillageAddressStore>()((set, get) => ({
  ...initialState,

  setVillageAddress: async (address) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const trimmedAddress: VillageAddress = {
        ...address,
        phone: address.phone?.trim() || null,
        email: address.email?.trim() || null,
        siret: address.siret?.trim() || null,
        vatNumber: address.vatNumber?.trim() || null,
        zipCode: address.zipCode.trim(),
      };
      set({
        villageAddress: trimmedAddress,
        isLoading: false,
      });
      return;
    }

    try {
      const payload: SetVillageAddressRequest = {
        clubCode: address.clubCode,
        name: address.name,
        address1: address.address1,
        address2: address.address2 || undefined,
        zipCode: address.zipCode.trim(),
        phone: address.phone?.trim() || undefined,
        email: address.email?.trim() || undefined,
        siret: address.siret?.trim() || undefined,
        vatNumber: address.vatNumber?.trim() || undefined,
      };

      const response = await apiClient.put<
        ApiResponse<SetVillageAddressResponse>
      >('/api/village-address', payload);

      if (!response.data.success) {
        throw new Error(response.data.error || 'Échec mise à jour adresse');
      }

      const trimmedAddress: VillageAddress = {
        ...address,
        phone: address.phone?.trim() || null,
        email: address.email?.trim() || null,
        siret: address.siret?.trim() || null,
        vatNumber: address.vatNumber?.trim() || null,
        zipCode: address.zipCode.trim(),
      };

      set({ villageAddress: trimmedAddress });
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur mise à jour adresse';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  loadVillageAddress: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({
        villageAddress: MOCK_VILLAGE,
        isLoading: false,
      });
      return MOCK_VILLAGE;
    }

    try {
      const response = await apiClient.get<
        ApiResponse<GetVillageAddressResponse>
      >('/api/village-address');

      if (!response.data.success || !response.data.data) {
        throw new Error(
          response.data.error || 'Aucune adresse village trouvée',
        );
      }

      const address: VillageAddress = {
        clubCode: response.data.data.clubCode,
        name: response.data.data.name,
        address1: response.data.data.address1,
        address2: response.data.data.address2,
        zipCode: response.data.data.zipCode,
        phone: response.data.data.phone,
        email: response.data.data.email,
        siret: response.data.data.siret,
        vatNumber: response.data.data.vatNumber,
      };

      set({ villageAddress: address });
      return address;
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur chargement adresse';
      set({ error: message });
      return null;
    } finally {
      set({ isLoading: false });
    }
  },

  clearError: () => set({ error: null }),

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.