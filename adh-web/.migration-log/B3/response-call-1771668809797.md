```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useIntegriteDatesStore } from '@/stores/integriteDatesStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import type { DateIntegrityCheck, DateComptable } from '@/types/integriteDates';
import { useDataSourceStore } from '@/stores/dataSourceStore';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(),
  },
}));

const MOCK_DATE_COMPTABLE: DateComptable = {
  checkType: 'O',
  societe: 'SOC1',
  controleOk: true,
  anomalieFermeture: false,
  dateComptable: '2026-02-20',
  delaiJours: 3,
};

const MOCK_VALIDATION_O: DateIntegrityCheck = {
  checkType: 'O',
  societe: 'SOC1',
  isValid: true,
  hasClosureAnomaly: false,
  timestamp: new Date().toISOString(),
};

const MOCK_VALIDATION_T: DateIntegrityCheck = {
  checkType: 'T',
  societe: 'SOC1',
  isValid: false,
  hasClosureAnomaly: false,
  errorMessage: 'Transaction timestamp invalide: session date/heure antérieure à maintenant',
  timestamp: new Date().toISOString(),
};

const MOCK_VALIDATION_F: DateIntegrityCheck = {
  checkType: 'F',
  societe: 'SOC1',
  isValid: false,
  hasClosureAnomaly: true,
  errorMessage: 'Anomalie détectée: fermeture bloquée',
  timestamp: new Date().toISOString(),
};

describe('integriteDatesStore', () => {
  beforeEach(() => {
    useIntegriteDatesStore.setState({
      checkType: 'O',
      societe: '',
      isLoading: false,
      error: null,
      validationResult: null,
      ouvertureValidation: null,
      transactionValidation: null,
      fermetureValidation: null,
    });
    vi.clearAllMocks();
  });

  describe('setCheckType', () => {
    it('should update checkType and clear error', () => {
      const store = useIntegriteDatesStore.getState();
      store.setError('previous error');
      
      store.setCheckType('T');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.checkType).toBe('T');
      expect(state.error).toBeNull();
    });
  });

  describe('setSociete', () => {
    it('should update societe and clear error', () => {
      const store = useIntegriteDatesStore.getState();
      store.setError('previous error');
      
      store.setSociete('SOC2');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.societe).toBe('SOC2');
      expect(state.error).toBeNull();
    });
  });

  describe('clearValidationResult', () => {
    it('should clear all validation results and error', () => {
      useIntegriteDatesStore.setState({
        validationResult: MOCK_VALIDATION_O,
        ouvertureValidation: { isValid: true, dateComptable: '2026-02-20', currentDate: '2026-02-21', delaiExceeded: false },
        error: 'some error',
      });
      
      const store = useIntegriteDatesStore.getState();
      store.clearValidationResult();
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toBeNull();
      expect(state.ouvertureValidation).toBeNull();
      expect(state.transactionValidation).toBeNull();
      expect(state.fermetureValidation).toBeNull();
      expect(state.error).toBeNull();
    });
  });

  describe('validateDateIntegrity', () => {
    it('should validate ouverture with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.validateDateIntegrity('O', 'SOC1');
      
      expect(result.checkType).toBe('O');
      expect(result.isValid).toBe(true);
      expect(result.hasClosureAnomaly).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toEqual(result);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should validate transaction with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.validateDateIntegrity('T', 'SOC1');
      
      expect(result.checkType).toBe('T');
      expect(result.isValid).toBe(false);
      expect(result.errorMessage).toBeDefined();
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toEqual(result);
      expect(state.isLoading).toBe(false);
    });

    it('should validate fermeture with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.validateDateIntegrity('F', 'SOC1');
      
      expect(result.checkType).toBe('F');
      expect(result.hasClosureAnomaly).toBe(true);
      expect(result.isValid).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toEqual(result);
    });

    it('should call API and update state when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: MOCK_VALIDATION_O,
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.validateDateIntegrity('O', 'SOC1');
      
      expect(apiClient.post).toHaveBeenCalledWith('/api/controles/integrite-dates', {
        checkType: 'O',
        societe: 'SOC1',
      });
      expect(result).toEqual(MOCK_VALIDATION_O);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toEqual(MOCK_VALIDATION_O);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should handle API error and set error state', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const error = new Error('API error');
      vi.mocked(apiClient.post).mockRejectedValue(error);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.validateDateIntegrity('O', 'SOC1')).rejects.toThrow('API error');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toBeNull();
      expect(state.error).toBe('API error');
      expect(state.isLoading).toBe(false);
    });

    it('should throw error when API returns invalid response', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: null as never,
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.validateDateIntegrity('O', 'SOC1')).rejects.toThrow('Réponse invalide du serveur');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.error).toBe('Réponse invalide du serveur');
    });
  });

  describe('checkOuverture', () => {
    it('should validate opening with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkOuverture('SOC1');
      
      expect(result).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.ouvertureValidation).toBeDefined();
      expect(state.ouvertureValidation?.dateComptable).toBe('2026-02-20');
      expect(state.isLoading).toBe(false);
    });

    it('should detect exceeded delay with mock data', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const pastDate = new Date();
      pastDate.setDate(pastDate.getDate() - 10);
      const mockPastData = {
        ...MOCK_DATE_COMPTABLE,
        dateComptable: pastDate.toISOString().split('T')[0],
      };
      
      useIntegriteDatesStore.setState({
        checkType: 'O',
        societe: 'SOC1',
        isLoading: false,
        error: null,
        validationResult: null,
        ouvertureValidation: null,
        transactionValidation: null,
        fermetureValidation: null,
      });
      
      const store = useIntegriteDatesStore.getState();
      const originalMock = MOCK_DATE_COMPTABLE.dateComptable;
      MOCK_DATE_COMPTABLE.dateComptable = mockPastData.dateComptable;
      
      const result = await store.checkOuverture('SOC1');
      
      MOCK_DATE_COMPTABLE.dateComptable = originalMock;
      
      expect(result).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.ouvertureValidation?.delaiExceeded).toBe(true);
    });

    it('should call API and validate against date comptable when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 5);
      const mockData: DateComptable = {
        ...MOCK_DATE_COMPTABLE,
        dateComptable: futureDate.toISOString().split('T')[0],
      };
      const mockResponse: ApiResponse<DateComptable> = {
        success: true,
        data: mockData,
      };
      vi.mocked(apiClient.get).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkOuverture('SOC1');
      
      expect(apiClient.get).toHaveBeenCalledWith('/api/controles/date-comptable', {
        params: { societe: 'SOC1', checkType: 'O' },
      });
      expect(result).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.ouvertureValidation?.isValid).toBe(true);
      expect(state.ouvertureValidation?.delaiExceeded).toBe(false);
    });

    it('should handle API error during ouverture check', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const error = new Error('Network error');
      vi.mocked(apiClient.get).mockRejectedValue(error);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.checkOuverture('SOC1')).rejects.toThrow('Network error');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.ouvertureValidation).toBeNull();
      expect(state.error).toBe('Network error');
    });
  });

  describe('checkTransaction', () => {
    it('should validate transaction timestamp with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const pastDate = new Date();
      pastDate.setHours(pastDate.getHours() - 1);
      const dateSession = pastDate.toISOString().split('T')[0];
      const heureSession = `${pastDate.getHours().toString().padStart(2, '0')}:${pastDate.getMinutes().toString().padStart(2, '0')}`;
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkTransaction('SOC1', dateSession, heureSession);
      
      expect(result).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.transactionValidation).toBeDefined();
      expect(state.transactionValidation?.isTimestampValid).toBe(true);
    });

    it('should detect invalid future timestamp with mock data', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const futureDate = new Date();
      futureDate.setHours(futureDate.getHours() + 2);
      const dateSession = futureDate.toISOString().split('T')[0];
      const heureSession = `${futureDate.getHours().toString().padStart(2, '0')}:${futureDate.getMinutes().toString().padStart(2, '0')}`;
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkTransaction('SOC1', dateSession, heureSession);
      
      expect(result).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.transactionValidation?.isValid).toBe(false);
    });

    it('should call API and validate transaction when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: { ...MOCK_VALIDATION_T, isValid: true },
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkTransaction('SOC1', '2026-02-20', '10:30');
      
      expect(apiClient.post).toHaveBeenCalledWith('/api/controles/integrite-dates', {
        checkType: 'T',
        societe: 'SOC1',
        dateSession: '2026-02-20',
        heureSession: '10:30',
      });
      expect(result).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.transactionValidation?.isValid).toBe(true);
    });

    it('should handle API error during transaction check', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const error = new Error('Validation failed');
      vi.mocked(apiClient.post).mockRejectedValue(error);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.checkTransaction('SOC1', '2026-02-20', '10:30')).rejects.toThrow('Validation failed');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.transactionValidation).toBeNull();
      expect(state.error).toBe('Validation failed');
    });
  });

  describe('checkFermeture', () => {
    it('should detect closure anomaly with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkFermeture('SOC1');
      
      expect(result.isValid).toBe(false);
      expect(result.hasAnomaly).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.fermetureValidation?.hasAnomaly).toBe(true);
      expect(state.fermetureValidation?.blockedReason).toBeDefined();
    });

    it('should call API and detect closure anomaly when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: MOCK_VALIDATION_F,
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkFermeture('SOC1');
      
      expect(apiClient.post).toHaveBeenCalledWith('/api/controles/integrite-dates', {
        checkType: 'F',
        societe: 'SOC1',
      });
      expect(result.isValid).toBe(false);
      expect(result.hasAnomaly).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.fermetureValidation?.hasAnomaly).toBe(true);
      expect(state.fermetureValidation?.blockedReason).toBe('Anomalie détectée: fermeture bloquée');
    });

    it('should validate successful closure when no anomaly', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: { ...MOCK_VALIDATION_F, isValid: true, hasClosureAnomaly: false, errorMessage: undefined },
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkFermeture('SOC1');
      
      expect(result.isValid).toBe(true);
      expect(result.hasAnomaly).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.fermetureValidation?.isValid).toBe(true);
      expect(state.fermetureValidation?.hasAnomaly).toBe(false);
      expect(state.fermetureValidation?.blockedReason).toBeUndefined();
    });

    it('should handle API error during fermeture check', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const error = new Error('Server error');
      vi.mocked(apiClient.post).mockRejectedValue(error);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.checkFermeture('SOC1')).rejects.toThrow('Server error');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.fermetureValidation).toBeNull();
      expect(state.error).toBe('Server error');
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      useIntegriteDatesStore.setState({
        checkType: 'F',
        societe: 'SOC2',
        isLoading: true,
        error: 'some error',
        validationResult: MOCK_VALIDATION_O,
        ouvertureValidation: { isValid: true, dateComptable: '2026-02-20', currentDate: '2026-02-21', delaiExceeded: false },
      });
      
      const store = useIntegriteDatesStore.getState();
      store.reset();
      
      const state = useIntegriteDatesStore.getState();
      expect(state.checkType).toBe('O');
      expect(state.societe).toBe('');
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.validationResult).toBeNull();
      expect(state.ouvertureValidation).toBeNull();
    });
  });
});
```