Generate Vitest unit tests for the "characterValidationStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  ValidationResult,
  ValidateCharactersRequest,
  ValidateCharactersResponse,
  CheckStringRequest,
  CheckStringResponse,
  ForbiddenCharactersResponse,
  CharacterValidationState,
} from '@/types/characterValidation';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

const MOCK_FORBIDDEN_CHARS = [
  '@', '#', '$', '%', '&', '*', '<', '>', '|', '\\', '/', '?', '"', "'",
  '\n', '\r', '\t', '\0', '\x01', '\x02', '\x03',
];

const MOCK_VALIDATION_RESULTS: Record<string, ValidationResult> = {
  'test@email.com': {
    isValid: false,
    invalidCharacters: '@',
    position: 4,
  },
  'valid-name': {
    isValid: true,
    invalidCharacters: '',
    position: null,
  },
  'special$char%here': {
    isValid: false,
    invalidCharacters: '$%',
    position: 7,
  },
};

const initialState = {
  forbiddenCharacters: [],
  lastValidationResult: null,
  isValidating: false,
  error: null,
};

export const useCharacterValidationStore = create<CharacterValidationState>()((set, get) => ({
  ...initialState,

  validateCharacters: async (input: string): Promise<ValidationResult> => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isValidating: true, error: null });

    if (!isRealApi) {
      const mockResult = MOCK_VALIDATION_RESULTS[input] || {
        isValid: true,
        invalidCharacters: '',
        position: null,
      };
      set({ lastValidationResult: mockResult, isValidating: false });
      return mockResult;
    }

    try {
      const response = await apiClient.post<ApiResponse<ValidateCharactersResponse>>(
        '/api/validation/check-string',
        { input } as ValidateCharactersRequest,
      );
      const result = response.data.data?.result || {
        isValid: true,
        invalidCharacters: '',
        position: null,
      };
      set({ lastValidationResult: result });
      return result;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation caractères';
      set({ error: message, lastValidationResult: null });
      return {
        isValid: false,
        invalidCharacters: '',
        position: null,
      };
    } finally {
      set({ isValidating: false });
    }
  },

  loadForbiddenCharacters: async (): Promise<void> => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ error: null });

    if (!isRealApi) {
      set({ forbiddenCharacters: MOCK_FORBIDDEN_CHARS });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<ForbiddenCharactersResponse>>(
        '/api/validation/forbidden-characters',
      );
      const characters = response.data.data?.characters || [];
      set({ forbiddenCharacters: characters });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement caractères interdits';
      set({ error: message, forbiddenCharacters: [] });
    }
  },

  checkString: (input: string, forbiddenChars: string[]): ValidationResult => {
    const invalidCharsFound: string[] = [];
    let firstInvalidPosition: number | null = null;

    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      if (forbiddenChars.includes(char)) {
        if (firstInvalidPosition === null) {
          firstInvalidPosition = i;
        }
        if (!invalidCharsFound.includes(char)) {
          invalidCharsFound.push(char);
        }
      }
    }

    const result: ValidationResult = {
      isValid: invalidCharsFound.length === 0,
      invalidCharacters: invalidCharsFound.join(''),
      position: firstInvalidPosition,
    };

    set({ lastValidationResult: result });
    return result;
  },

  setError: (error: string | null) => set({ error }),

  setIsValidating: (isValidating: boolean) => set({ isValidating }),

  reset: () => set({ ...initialState }),
}));

TYPES:
export interface ValidationResult {
  isValid: boolean;
  invalidCharacters: string;
  position: number | null;
}

export interface ValidateCharactersRequest {
  input: string;
}

export interface ValidateCharactersResponse {
  result: ValidationResult;
}

export interface CheckStringRequest {
  input: string;
  forbiddenChars: string[];
}

export interface CheckStringResponse {
  result: ValidationResult;
}

export interface ForbiddenCharactersResponse {
  characters: string[];
}

export interface CharacterValidationState {
  forbiddenCharacters: string[];
  lastValidationResult: ValidationResult | null;
  isValidating: boolean;
  error: string | null;
  validateCharacters: (input: string) => Promise<ValidationResult>;
  loadForbiddenCharacters: () => Promise<void>;
  checkString: (input: string, forbiddenChars: string[]) => ValidationResult;
  setError: (error: string | null) => void;
  setIsValidating: (isValidating: boolean) => void;
  reset: () => void;
}

ACTIONS TO COVER:
[
  {
    "name": "validateCharacters",
    "params": [
      "input: string"
    ],
    "businessRules": [
      "[RM-001] Vérifie qu'aucun caractère interdit n'est présent dans la chaîne",
      "Retourne la position du premier caractère invalide si trouvé",
      "Liste tous les caractères invalides détectés"
    ],
    "returns": "Promise<ValidationResult>"
  },
  {
    "name": "loadForbiddenCharacters",
    "params": [],
    "businessRules": [
      "Charge la liste des caractères interdits depuis la configuration",
      "Initialise la liste par défaut si aucune configuration n'existe"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "checkString",
    "params": [
      "input: string",
      "forbiddenChars: string[]"
    ],
    "businessRules": [
      "Parcourt la chaîne caractère par caractère",
      "Compare chaque caractère contre la liste interdite",
      "Arrête au premier caractère invalide trouvé"
    ],
    "returns": "ValidationResult"
  }
]