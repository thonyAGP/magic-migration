Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/stores/__tests__/fusionStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
useFusionStore validateFusion should set error on validation failure: AssertionError: expected true to be false // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/stores/__tests__/fusionStore.test.ts:174:30
    at processTicksAndRejections (node:internal
useFusionStore validateFusion should set isValidating during validation: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/stores/__tests__/fusionStore.test.ts:192:56
    at Timeout.checkCallback (file:///D:/Projec
useFusionStore executeFusion should set error and step to confirmation on failure: AssertionError: expected true to be false // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/stores/__tests__/fusionStore.test.ts:245:30
    at file:///D:/Projects/Lecteur_Magic/adh-we
useFusionStore pollProgress should set result when available: AssertionError: expected { success: true, …(5) } to match object { success: true, …(3) }
(2 matching properties omitted from actual)
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web
useFusionStore pollProgress should fallback to progress when result not ready: AssertionError: expected null to match object { operationId: 'op-002', …(2) }
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.pnpm/@vitest+expect@4.0.18/node_modules/

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useFusionStore } from '../fusionStore';

vi.mock('@/services/api/endpoints-lot6', () => ({
  fusionApi: {
    searchAccount: vi.fn(),
    validate: vi.fn(),
    execute: vi.fn(),
    getProgress: vi.fn(),
    getResult: vi.fn(),
  },
}));

import { fusionApi } from '@/services/api/endpoints-lot6';

const mockAccounts = [
  { codeAdherent: 1001, filiation: 0, nom: 'Dupont', prenom: 'Jean', societe: 'ADH', solde: 1250, nbTransactions: 45, nbGaranties: 2 },
  { codeAdherent: 1002, filiation: 0, nom: 'Martin', prenom: 'Marie', societe: 'ADH', solde: 890.5, nbTransactions: 23, nbGaranties: 0 },
];

const MOCK_GARANTIES_SOURCE = [
  { id: 'g-src-1', article: 'Serviette plage', description: 'Serviette plage XL', montant: 25.00, dateDepot: '2026-01-15', compteOrigine: 'source' as const },
  { id: 'g-src-2', article: 'Casier vestiaire', description: 'Casier vestiaire B12', montant: 10.00, dateDepot: '2026-01-20', compteOrigine: 'source' as const },
];

const mockPreview = {
  comptePrincipal: mockAccounts[0],
  compteSecondaire: mockAccounts[1],
  nbOperationsAFusionner: 23,
  montantTotal: 2140.5,
  garantiesATransferer: 0,
  garantiesSource: MOCK_GARANTIES_SOURCE,
  garantiesDestination: [],
  conflits: [],
  avertissements: [],
};

const mockResult = {
  success: true,
  compteFinal: { ...mockAccounts[0], solde: 2140.5, nbTransactions: 68, nbGaranties: 2 },
  nbOperationsFusionnees: 23,
  nbGarantiesTransferees: 0,
  message: 'Fusion effectuee avec succes',
  dateExecution: '2026-02-20T10:00:00.000Z',
};

const mockProgress = {
  operationId: 'op-002',
  progress: 75,
  status: 'in_progress' as const,
};

describe('useFusionStore', () => {
  beforeEach(() => {
    useFusionStore.setState({
      comptePrincipal: null,
      compteSecondaire: null,
      preview: null,
      result: null,
      progress: null,
      currentStep: 'selection_principal',
      searchResults: [],
      isSearching: false,
      isValidating: false,
      isExecuting: false,
      isLocked: false,
      error: null,
      prerequisites: null,
    });
    vi.clearAllMocks();
  });

  describe('initial state', () => {
    it('should have default values', () => {
      const state = useFusionStore.getState();
      expect(state.comptePrincipal).toBeNull();
      expect(state.compteSecondaire).toBeNull();
      expect(state.preview).toBeNull();
      expect(state.result).toBeNull();
      expect(state.progress).toBeNull();
      expect(state.currentStep).toBe('selection_principal');
      expect(state.searchResults).toEqual([]);
      expect(state.isSearching).toBe(false);
      expect(state.isValidating).toBe(false);
      expect(state.isExecuting).toBe(false);
      expect(state.error).toBeNull();
    });
  });

  describe('searchAccount', () => {
    it('should set search results on success', async () => {
      vi.mocked(fusionApi.searchAccount).mockResolvedValue({
        data: { data: [mockAccounts[0]] },
      } as never);

      await useFusionStore.getState().searchAccount('ADH', 'Dupont');

      expect(useFusionStore.getState().searchResults).toEqual([mockAccounts[0]]);
      expect(useFusionStore.getState().isSearching).toBe(false);
    });

    it('should handle API failure', async () => {
      vi.mocked(fusionApi.searchAccount).mockRejectedValue(new Error('Network error'));

      await useFusionStore.getState().searchAccount('ADH', 'test');

      expect(useFusionStore.getState().isSearching).toBe(false);
    });

    it('should handle null data', async () => {
      vi.mocked(fusionApi.searchAccount).mockResolvedValue({
        data: { data: null },
      } as never);

      await useFusionStore.getState().searchAccount('ADH', 'test');
      expect(useFusionStore.getState().searchResults).toEqual([]);
    });
  });

  describe('selectPrincipal', () => {
    it('should set principal account', () => {
      useFusionStore.getState().selectPrincipal(mockAccounts[0] as never);
      expect(useFusionStore.getState().comptePrincipal).toEqual(mockAccounts[0]);
    });
  });

  describe('selectSecondaire', () => {
    it('should set secondary account', () => {
      useFusionStore.getState().selectSecondaire(mockAccounts[1] as never);
      expect(useFusionStore.getState().compteSecondaire).toEqual(mockAccounts[1]);
    });
  });

  describe('validateFusion', () => {
    it('should return error if accounts not selected', async () => {
      const result = await useFusionStore.getState().validateFusion('ADH', 'user1');

      expect(result).toEqual({ success: false, error: 'Comptes principal et secondaire requis' });
    });

    it('should validate and set preview on success', async () => {
      useFusionStore.setState({
        comptePrincipal: mockAccounts[0] as never,
        compteSecondaire: mockAccounts[1] as never,
      });
      vi.mocked(fusionApi.validate).mockResolvedValue({
        data: { data: mockPreview },
      } as never);

      const result = await useFusionStore.getState().validateFusion('ADH', 'user1');

      expect(result).toEqual({ success: true });
      const state = useFusionStore.getState();
      expect(state.preview).toMatchObject({
        comptePrincipal: mockAccounts[0],
        compteSecondaire: mockAccounts[1],
        nbOperationsAFusionner: 23,
        montantTotal: 2140.5,
        garantiesATransferer: 0,
      });
      expect(state.currentStep).toBe('preview');
      expect(state.isValidating).toBe(false);
    });

    it('should set error on validation failure', async () => {
      useFusionStore.setState({
        comptePrincipal: mockAccounts[0] as never,
        compteSecondaire: mockAccounts[1] as never,
      });
      vi.mocked(fusionApi.validate).mockRejectedValue(new Error('Conflict detected'));

      const result = await useFusionStore.getState().validateFusion('ADH', 'user1');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Conflict detected');
      expect(useFusionStore.getState().isValidating).toBe(false);
      expect(useFusionStore.getState().error).toBe('Conflict detected');
    });

    it('should set isValidating during validation', async () => {
      useFusionStore.setState({
        comptePrincipal: mockAccounts[0] as never,
        compteSecondaire: mockAccounts[1] as never,
      });
      let resolve: (v: unknown) => void;
      const promise = new Promise((r) => { resolve = r; });
      vi.mocked(fusionApi.validate).mockReturnValue(promise as never);

      const validatePromise = useFusionStore.getState().validateFusion('ADH', 'user1');
      
      await vi.waitFor(() => {
        expect(useFusionStore.getState().isValidating).toBe(true);
      });

      resolve!({ data: { data: mockPreview } });
      await validatePromise;
      expect(useFusionStore.getState().isValidating).toBe(false);
    });
  });

  describe('executeFusion', () => {
    it('should return error if accounts not selected', async () => {
      const result = await useFusionStore.getState().executeFusion('ADH', 'user1');

      expect(result).toEqual({ success: false, error: 'Comptes principal et secondaire requis' });
    });

    it('should execute and poll progress on success', async () => {
      useFusionStore.setState({
        comptePrincipal: mockAccounts[0] as never,
        compteSecondaire: mockAccounts[1] as never,
      });
      vi.mocked(fusionApi.validate).mockResolvedValue({ data: { data: mockPreview } } as never);
      vi.mocked(fusionApi.execute).mockResolvedValue({
        data: { data: { operationId: 'op-002' } },
      } as never);
      vi.mocked(fusionApi.getResult).mockResolvedValue({
        data: { data: mockResult },
      } as never);

      const result = await useFusionStore.getState().executeFusion('ADH', 'user1');

      expect(result).toEqual({ success: true });
      const state = useFusionStore.getState();
      expect(state.result).toMatchObject({
        success: true,
        nbOperationsFusionnees: 23,
        nbGarantiesTransferees: 0,
        message: 'Fusion effectuee avec succes',
      });
      expect(state.currentStep).toBe('result');
      expect(state.isExecuting).toBe(false);
    });

    it('should set error and step to confirmation on failure', async () => {
      useFusionStore.setState({
        comptePrincipal: mockAccounts[0] as never,
        compteSecondaire: mockAccounts[1] as never,
      });
      vi.mocked(fusionApi.validate).mockResolvedValue({ data: { data: mockPreview } } as never);
      vi.mocked(fusionApi.execute).mockRejectedValue(new Error('Timeout'));

      const result = await useFusionStore.getState().executeFusion('ADH', 'user1');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Timeout');
      expect(useFusionStore.getState().currentStep).toBe('confirmation');
      expect(useFusionStore.getState().isExecuting).toBe(false);
      expect(useFusionStore.getState().error).toBe('Timeout');
    });

    it('should set step to processing during execution', async () => {
      useFusionStore.setState({
        comptePrincipal: mockAccounts[0] as never,
        compteSecondaire: mockAccounts[1] as never,
      });
      let resolve: (v: unknown) => void;
      const promise = new Promise((r) => { resolve = r; });
      vi.mocked(fusionApi.validate).mockResolvedValue({ data: { data: mockPreview } } as never);
      vi.mocked(fusionApi.execute).mockReturnValue(promise as never);

      const execPromise = useFusionStore.getState().executeFusion('ADH', 'user1');
      expect(useFusionStore.getState().currentStep).toBe('processing');
      expect(useFusionStore.getState().isExecuting).toBe(true);

      vi.mocked(fusionApi.getResult).mockResolvedValue({
        data: { data: mockResult },
      } as never);

      resolve!({ data: { data: { operationId: 'op-002' } } });
      await execPromise;
    });
  });

  describe('pollProgress', () => {
    it('should set result when available', async () => {
      vi.mocked(fusionApi.getResult).mockResolvedValue({
        data: { data: mockResult },
      } as never);

      await useFusionStore.getState().pollProgress('op-002');

      const state = useFusionStore.getState();
      expect(state.result).toMatchObject({
        success: true,
        nbOperationsFusionnees: 23,
        nbGarantiesTransferees: 0,
        message: 'Fusion effectuee avec succes',
      });
      expect(state.currentStep).toBe('result');
    });

    it('should fallback to progress when result not ready', async () => {
      vi.mocked(fusionApi.getResult).mockRejectedValue(new Error('Not ready'));
      vi.mocked(fusionApi.getProgress).mockResolvedValue({
        data: { data: mockProgress },
      } as never);

      await useFusionStore.getState().pollProgress('op-002');

      const state = useFusionStore.getState();
      expect(state.progress).toMatchObject({
        operationId: 'op-002',
        progress: 75,
        status: 'in_progress',
      });
    });

    it('should silently handle both errors', async () => {
      vi.mocked(fusionApi.getResult).mockRejectedValue(new Error('fail'));
      vi.mocked(fusionApi.getProgress).mockRejectedValue(new Error('fail'));

      await useFusionStore.getState().pollProgress('op-002');
    });
  });

  describe('setStep', () => {
    it('should change the current step', () => {
      useFusionStore.getState().setStep('confirmation');
      expect(useFusionStore.getState().currentStep).toBe('confirmation');
    });
  });

  describe('reset', () => {
    it('should reset all state', () => {
      useFusionStore.setState({
        comptePrincipal: mockAccounts[0] as never,
        compteSecondaire: mockAccounts[1] as never,
        preview: mockPreview as never,
        result: mockResult as never,
        progress: mockProgress as never,
        currentStep: 'result',
        searchResults: mockAccounts as never,
        error: 'error',
      });

      useFusionStore.getState().reset();

      const state = useFusionStore.getState();
      expect(state.comptePrincipal).toBeNull();
      expect(state.compteSecondaire).toBeNull();
      expect(state.preview).toBeNull();
      expect(state.result).toBeNull();
      expect(state.progress).toBeNull();
      expect(state.currentStep).toBe('selection_principal');
      expect(state.searchResults).toEqual([]);
      expect(state.error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  FusionAccount,
  FusionPreview,
  FusionResult,
  FusionProgress,
  FusionStep,
  FusionPrerequisites,
} from '@/types/fusion';
import { fusionApi } from '@/services/api/endpoints-lot6';
import { useDataSourceStore } from './dataSourceStore';
import { useSessionStore } from './sessionStore';

interface FusionState {
  comptePrincipal: FusionAccount | null;
  compteSecondaire: FusionAccount | null;
  preview: FusionPreview | null;
  result: FusionResult | null;
  progress: FusionProgress | null;
  currentStep: FusionStep;
  searchResults: FusionAccount[];
  isSearching: boolean;
  isValidating: boolean;
  isExecuting: boolean;
  isLocked: boolean;
  error: string | null;
  prerequisites: FusionPrerequisites | null;
}

interface FusionActions {
  checkPrerequisites: () => Promise<FusionPrerequisites>;
  searchAccount: (societe: string, query: string) => Promise<void>;
  selectPrincipal: (account: FusionAccount) => void;
  selectSecondaire: (account: FusionAccount) => void;
  validateFusion: (
    societe: string,
    operateur: string,
  ) => Promise<{ success: boolean; error?: string }>;
  executeFusion: (
    societe: string,
    operateur: string,
  ) => Promise<{ success: boolean; error?: string }>;
  lockAccounts: (sourceId: number, destId: number) => Promise<boolean>;
  unlockAccounts: () => void;
  pollProgress: (operationId: string) => Promise<void>;
  setStep: (step: FusionStep) => void;
  reset: () => void;
}

type FusionStore = FusionState & FusionActions;

const MOCK_ACCOUNTS: FusionAccount[] = [
  { codeAdherent: 1001, filiation: 0, nom: 'Dupont', prenom: 'Jean', societe: 'ADH', solde: 1250.00, nbTransactions: 45, nbGaranties: 2 },
  { codeAdherent: 1002, filiation: 0, nom: 'Martin', prenom: 'Marie', societe: 'ADH', solde: 890.50, nbTransactions: 23, nbGaranties: 0 },
  { codeAdherent: 1003, filiation: 1, nom: 'Durand', prenom: 'Pierre', societe: 'ADH', solde: 320.00, nbTransactions: 12, nbGaranties: 1 },
];

const MOCK_GARANTIES_SOURCE = [
  { id: 'g-src-1', article: 'Serviette plage', description: 'Serviette plage XL', montant: 25.00, dateDepot: '2026-01-15', compteOrigine: 'source' as const },
  { id: 'g-src-2', article: 'Casier vestiaire', description: 'Casier vestiaire B12', montant: 10.00, dateDepot: '2026-01-20', compteOrigine: 'source' as const },
];

const MOCK_GARANTIES_DESTINATION = [
  { id: 'g-dst-1', article: 'Planche surf', description: 'Planche surf 7ft', montant: 150.00, dateDepot: '2026-01-10', compteOrigine: 'destination' as const },
  { id: 'g-dst-2', article: 'Masque plongee', description: 'Masque plongee pro', montant: 35.00, dateDepot: '2026-01-12', compteOrigine: 'destination' as const },
];

const initialState: FusionState = {
  comptePrincipal: null,
  compteSecondaire: null,
  preview: null,
  result: null,
  progress: null,
  currentStep: 'selection_principal',
  searchResults: [],
  isSearching: false,
  isValidating: false,
  isExecuting: false,
  isLocked: false,
  error: null,
  prerequisites: null,
};

export const useFusionStore = create<FusionStore>()((set, get) => ({
  ...initialState,

  checkPrerequisites: async () => {
    const warnings: string[] = [];
    const { currentSession } = useSessionStore.getState();

    if (!currentSession || currentSession.status !== 'open') {
      warnings.push('Aucune session ouverte. Ouvrez une session avant de fusionner.');
    }

    const { isRealApi } = useDataSourceStore.getState();
    if (!isRealApi) {
      // Mock: simulate network closure completed
      const result: FusionPrerequisites = { canProceed: warnings.length === 0, warnings };
      set({ prerequisites: result });
      return result;
    }

    try {
      const closureResult = await useSessionStore.getState().checkNetworkClosure();
      if (closureResult.status !== 'completed') {
        warnings.push('Cloture reseau non terminee. La fusion pourrait echouer.');
      }
    } catch {
      warnings.push('Impossible de verifier la cloture reseau.');
    }

    const result: FusionPrerequisites = { canProceed: warnings.length === 0, warnings };
    set({ prerequisites: result });
    return result;
  },

  searchAccount: async (societe, query) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isSearching: true, error: null });

    if (!isRealApi) {
      const filtered = MOCK_ACCOUNTS.filter(
        (a) =>
          a.nom.toLowerCase().includes(query.toLowerCase()) ||
          a.prenom.toLowerCase().includes(query.toLowerCase()) ||
          String(a.codeAdherent).includes(query),
      );
      set({ searchResults: filtered, isSearching: false });
      return;
    }

    try {
      const response = await fusionApi.searchAccount(societe, query);
      set({ searchResults: response.data.data ?? [], isSearching: false });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur recherche compte';
      set({ searchResults: [], error: message, isSearching: false });
    }
  },

  selectPrincipal: (account) => {
    set({ comptePrincipal: account });
  },

  selectSecondaire: (account) => {
    set({ compteSecondaire: account });
  },

  validateFusion: async (societe, _operateur) => {
    const { comptePrincipal, compteSecondaire } = get();
    if (!comptePrincipal || !compteSecondaire) {
      return { success: false, error: 'Comptes principal et secondaire requis' };
    }

    const { isRealApi } = useDataSourceStore.getState();
    set({ isValidating: true, error: null });

    if (!isRealApi) {
      const mockPreview: FusionPreview = {
        comptePrincipal,
        compteSecondaire,
        nbOperationsAFusionner: compteSecondaire.nbTransactions,
        montantTotal: comptePrincipal.solde + compteSecondaire.solde,
        garantiesATransferer: compteSecondaire.nbGaranties,
        garantiesSource: comptePrincipal.nbGaranties > 0 ? MOCK_GARANTIES_SOURCE : [],
        garantiesDestination: compteSecondaire.nbGaranties > 0 ? MOCK_GARANTIES_DESTINATION : [],
        conflits: [],
        avertissements: [],
      };
      set({ preview: mockPreview, currentStep: 'preview', isValidating: false });
      return { success: true };
    }

    try {
      const response = await fusionApi.validate({
        societe,
        codeAdherentPrincipal: comptePrincipal.codeAdherent,
        filiationPrincipal: comptePrincipal.filiation,
        codeAdherentSecondaire: compteSecondaire.codeAdherent,
        filiationSecondaire: compteSecondaire.filiation,
      });
      set({ preview: response.data.data ?? null, currentStep: 'preview', isValidating: false });
      return { success: true };
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation fusion';
      set({ error: message, isValidating: false });
      return { success: false, error: message };
    }
  },

  lockAccounts: async (_sourceId: number, _destId: number) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      set({ isLocked: true });
      return true;
    }

    try {
      await fusionApi.validate({ societe: 'ADH', codeAdherentPrincipal: _sourceId, filiationPrincipal: 0, codeAdherentSecondaire: _destId, filiationSecondaire: 0 });
      set({ isLocked: true });
      return true;
    } catch {
      set({ isLocked: false });
      return false;
    }
  },

  unlockAccounts: () => {
    set({ isLocked: false });
  },

  executeFusion: async (societe, operateur) => {
    const { comptePrincipal, compteSecondaire } = get();
    if (!comptePrincipal || !compteSecondaire) {
      return { success: false, error: 'Comptes principal et secondaire requis' };
    }

    const { isRealApi } = useDataSourceStore.getState();
    set({ isExecuting: true, error: null, currentStep: 'processing' });

    // Lock accounts before execution
    const locked = await get().lockAccounts(comptePrincipal.codeAdherent, compteSecondaire.codeAdherent);
    if (!locked) {
      set({ error: 'Impossible de verrouiller les comptes', currentStep: 'confirmation', isExecuting: false });
      return { success: false, error: 'Impossible de verrouiller les comptes' };
    }

    if (!isRealApi) {
      const mockResult: FusionResult = {
        success: true,
        compteFinal: { ...comptePrincipal, solde: comptePrincipal.solde + compteSecondaire.solde, nbTransactions: comptePrincipal.nbTransactions + compteSecondaire.nbTransactions, nbGaranties: comptePrincipal.nbGaranties + compteSecondaire.nbGaranties },
        nbOperationsFusionnees: compteSecondaire.nbTransactions,
        nbGarantiesTransferees: compteSecondaire.nbGaranties,
        message: 'Fusion effectuee avec succes',
        dateExecution: new Date().toISOString(),
      };
      get().unlockAccounts();
      set({ result: mockResult, currentStep: 'result', isExecuting: false });
      return { success: true };
    }

    try {
      const response = await fusionApi.execute({
        societe,
        codeAdherentPrincipal: comptePrincipal.codeAdherent,
        filiationPrincipal: comptePrincipal.filiation,
        codeAdherentSecondaire: compteSecondaire.codeAdherent,
        filiationSecondaire: compteSecondaire.filiation,
        operateur,
      });
      const operationId = response.data.data?.operationId;
      if (operationId) {
        await get().pollProgress(operationId);
      }
      get().unlockAccounts();
      return { success: true };
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur execution fusion';
      get().unlockAccounts();
      set({ error: message, currentStep: 'confirmation', isExecuting: false });
      return { success: false, error: message };
    }
  },

  pollProgress: async (operationId) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      const { comptePrincipal, compteSecondaire } = get();
      const mockResult: FusionResult = {
        success: true,
        compteFinal: comptePrincipal!,
        nbOperationsFusionnees: compteSecondaire?.nbTransactions ?? 0,
        nbGarantiesTransferees: compteSecondaire?.nbGaranties ?? 0,
        message: 'Fusion effectuee avec succes',
        dateExecution: new Date().toISOString(),
      };
      set({ result: mockResult, currentStep: 'result' });
      return;
    }

    try {
      const resultResponse = await fusionApi.getResult(operationId);
      set({
        result: resultResponse.data.data ?? null,
        currentStep: 'result',
      });
    } catch {
      try {
        const progressResponse = await fusionApi.getProgress(operationId);
        set({ progress: progressResponse.data.data ?? null });
      } catch {
        // Silently ignore progress polling errors
      }
    }
  },

  setStep: (step) => {
    set({ currentStep: step });
  },

  reset: () => set({ ...initialState }),
}));

```

Output the COMPLETE fixed test file. Do not omit any tests.