Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
reinitAffPyrStore reinitAffectationPyr - Mock Mode should reset affectations for societe and compte: AssertionError: expected +0 to be 2 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:47:36
    at file:///D:/Projects/Lecteur_Magic/adh-web/node_m
reinitAffPyrStore reinitAffectationPyr - Mock Mode should reset affectations filtered by chambre: AssertionError: expected +0 to be 1 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:62:36
    at file:///D:/Projects/Lecteur_Magic/adh-web/node_m
reinitAffPyrStore reinitAffectationPyr - Real API Mode should call API with correct params and return count: AssertionError: expected +0 to be 2 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:121:21
    at file:///D:/Projects/Lecteur_Magic/adh-web/node_
reinitAffPyrStore reinitAffectationPyr - Real API Mode should handle API error and set error state: AssertionError: expected null to deeply equal Error: API connection failed
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:153:27
    at file:///D:/Projects/Lecteur_Ma
reinitAffPyrStore reinitAffectationPyr - Real API Mode should handle non-Error exceptions: AssertionError: expected null to be an instance of Error
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.pnpm/@vitest+expect@4.0.18/node_modules/@vitest/expect/dist/i
reinitAffPyrStore reinitAffectationPyr - Real API Mode should handle missing data in response: TypeError: Cannot read properties of undefined (reading 'data')
    at Object.reinitAffectationPyr (D:/Projects/Lecteur_Magic/adh-web/src/stores/reinitAffPyrStore.ts:75:43)
    at D:/Projects/Lecteur_
reinitAffPyrStore resetAllAffectations - Mock Mode should reset all affectations and return total count: AssertionError: expected +0 to be 10 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:196:36
    at file:///D:/Projects/Lecteur_Magic/adh-web/node
reinitAffPyrStore resetAllAffectations - Real API Mode should call API and return count: AssertionError: expected +0 to be 150 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:230:21
    at file:///D:/Projects/Lecteur_Magic/adh-web/nod
reinitAffPyrStore resetAllAffectations - Real API Mode should handle API error and set error state: AssertionError: expected null to deeply equal Error: Server error
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:243:27
    at file:///D:/Projects/Lecteur_Magic/adh-w
reinitAffPyrStore resetAllAffectations - Real API Mode should handle non-Error exceptions: AssertionError: expected null to be an instance of Error
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.pnpm/@vitest+expect@4.0.18/node_modules/@vitest/expect/dist/i
reinitAffPyrStore resetAllAffectations - Real API Mode should handle missing data in response: TypeError: Cannot read properties of undefined (reading 'data')
    at Object.resetAllAffectations (D:/Projects/Lecteur_Magic/adh-web/src/stores/reinitAffPyrStore.ts:111:43)
    at D:/Projects/Lecteur
reinitAffPyrStore getAffectationStatus - Real API Mode should call API with correct params and return status: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:322:44
    at file:///D:/Projects/Lecteur_Magic/adh-web
reinitAffPyrStore getAffectationStatus - Real API Mode should handle API error and set error state: AssertionError: expected null to deeply equal Error: Connection timeout
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:345:27
    at file:///D:/Projects/Lecteur_Magic
reinitAffPyrStore getAffectationStatus - Real API Mode should handle non-Error exceptions: AssertionError: expected null to be an instance of Error
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.pnpm/@vitest+expect@4.0.18/node_modules/@vitest/expect/dist/i
reinitAffPyrStore getAffectationStatus - Real API Mode should handle missing data in response: TypeError: Cannot read properties of undefined (reading 'data')
    at Object.getAffectationStatus (D:/Projects/Lecteur_Magic/adh-web/src/stores/reinitAffPyrStore.ts:154:28)
    at D:/Projects/Lecteur
reinitAffPyrStore clearError should clear error state: AssertionError: expected null not to be null // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:384:31
    at file:///D:/Projects/Lecteur_Magic/adh-
reinitAffPyrStore reset should reset store to initial state: AssertionError: expected +0 to be 2 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:401:36
    at file:///D:/Projects/Lecteur_Magic/adh-web/node_
reinitAffPyrStore Business Rules should process masse update without complex validation: AssertionError: expected +0 to be 50 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:455:21
    at file:///D:/Projects/Lecteur_Magic/adh-web/node
reinitAffPyrStore Business Rules should support global reset for caisse closure scenario: AssertionError: expected +0 to be 200 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/reinitAffPyrStore.test.ts:468:21
    at file:///D:/Projects/Lecteur_Magic/adh-web/nod

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useReinitAffPyrStore } from '@/stores/reinitAffPyrStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import type { ReinitAffectationResponse, AffectationStatusResponse } from '@/types/reinitAffPyr';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    post: vi.fn(),
    get: vi.fn(),
  },
}));

const MOCK_RESET_RESPONSE: ApiResponse<ReinitAffectationResponse> = {
  success: true,
  data: { affectedCount: 2 },
};

const MOCK_STATUS_RESPONSE: ApiResponse<AffectationStatusResponse> = {
  success: true,
  data: { hasActiveAffectations: true, count: 3 },
};

const MOCK_STATUS_EMPTY_RESPONSE: ApiResponse<AffectationStatusResponse> = {
  success: true,
  data: { hasActiveAffectations: false, count: 0 },
};

describe('reinitAffPyrStore', () => {
  beforeEach(() => {
    useReinitAffPyrStore.getState().reset();
    useDataSourceStore.setState({ isRealApi: false });
    vi.clearAllMocks();
  });

  describe('reinitAffectationPyr - Mock Mode', () => {
    it('should reset affectations for societe and compte', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const count = await store.reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1001,
      });

      expect(count).toBe(2);
      expect(store.lastResetCount).toBe(2);
      expect(store.isProcessing).toBe(false);
      expect(store.error).toBe(null);
    });

    it('should reset affectations filtered by chambre', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const count = await store.reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1001,
        chambre: '101',
      });

      expect(count).toBe(1);
      expect(store.lastResetCount).toBe(1);
    });

    it('should return 0 when no records match filters', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const count = await store.reinitAffectationPyr({
        societe: 'SOC999',
        compte: 9999,
      });

      expect(count).toBe(0);
      expect(store.lastResetCount).toBe(0);
    });

    it('should include empty chambre records', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const count = await store.reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1002,
      });

      expect(count).toBe(2);
    });

    it('should set isProcessing to true during operation', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const promise = store.reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1001,
      });

      expect(useReinitAffPyrStore.getState().isProcessing).toBe(true);
      
      await promise;
      
      expect(useReinitAffPyrStore.getState().isProcessing).toBe(false);
    });
  });

  describe('reinitAffectationPyr - Real API Mode', () => {
    beforeEach(() => {
      useDataSourceStore.setState({ isRealApi: true });
    });

    it('should call API with correct params and return count', async () => {
      vi.mocked(apiClient.post).mockResolvedValue(MOCK_RESET_RESPONSE);
      
      const store = useReinitAffPyrStore.getState();
      const count = await store.reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1001,
      });

      expect(apiClient.post).toHaveBeenCalledWith(
        '/api/reinitAffPyr/reset?societe=SOC1&compte=1001',
      );
      expect(count).toBe(2);
      expect(store.lastResetCount).toBe(2);
      expect(store.isProcessing).toBe(false);
    });

    it('should include chambre in query params when provided', async () => {
      vi.mocked(apiClient.post).mockResolvedValue(MOCK_RESET_RESPONSE);
      
      await useReinitAffPyrStore.getState().reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1001,
        chambre: '101',
      });

      expect(apiClient.post).toHaveBeenCalledWith(
        '/api/reinitAffPyr/reset?societe=SOC1&compte=1001&chambre=101',
      );
    });

    it('should handle API error and set error state', async () => {
      const apiError = new Error('API connection failed');
      vi.mocked(apiClient.post).mockRejectedValue(apiError);
      
      const store = useReinitAffPyrStore.getState();
      
      await expect(
        store.reinitAffectationPyr({
          societe: 'SOC1',
          compte: 1001,
        }),
      ).rejects.toThrow('API connection failed');

      expect(store.error).toEqual(apiError);
      expect(store.isProcessing).toBe(false);
    });

    it('should handle non-Error exceptions', async () => {
      vi.mocked(apiClient.post).mockRejectedValue('String error');
      
      const store = useReinitAffPyrStore.getState();
      
      await expect(
        store.reinitAffectationPyr({
          societe: 'SOC1',
          compte: 1001,
        }),
      ).rejects.toThrow('Erreur réinitialisation affectation PYR');

      expect(store.error).toBeInstanceOf(Error);
      expect(store.isProcessing).toBe(false);
    });

    it('should handle missing data in response', async () => {
      vi.mocked(apiClient.post).mockResolvedValue({
        success: true,
        data: undefined,
      });
      
      const count = await useReinitAffPyrStore.getState().reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1001,
      });

      expect(count).toBe(0);
      expect(useReinitAffPyrStore.getState().lastResetCount).toBe(0);
    });
  });

  describe('resetAllAffectations - Mock Mode', () => {
    it('should reset all affectations and return total count', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const count = await store.resetAllAffectations();

      expect(count).toBe(10);
      expect(store.lastResetCount).toBe(10);
      expect(store.isProcessing).toBe(false);
      expect(store.error).toBe(null);
    });

    it('should set isProcessing during operation', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const promise = store.resetAllAffectations();

      expect(useReinitAffPyrStore.getState().isProcessing).toBe(true);
      
      await promise;
      
      expect(useReinitAffPyrStore.getState().isProcessing).toBe(false);
    });
  });

  describe('resetAllAffectations - Real API Mode', () => {
    beforeEach(() => {
      useDataSourceStore.setState({ isRealApi: true });
    });

    it('should call API and return count', async () => {
      const mockResponse: ApiResponse<ReinitAffectationResponse> = {
        success: true,
        data: { affectedCount: 150 },
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockResponse);
      
      const store = useReinitAffPyrStore.getState();
      const count = await store.resetAllAffectations();

      expect(apiClient.post).toHaveBeenCalledWith('/api/reinitAffPyr/reset-all');
      expect(count).toBe(150);
      expect(store.lastResetCount).toBe(150);
      expect(store.isProcessing).toBe(false);
    });

    it('should handle API error and set error state', async () => {
      const apiError = new Error('Server error');
      vi.mocked(apiClient.post).mockRejectedValue(apiError);
      
      const store = useReinitAffPyrStore.getState();
      
      await expect(store.resetAllAffectations()).rejects.toThrow('Server error');

      expect(store.error).toEqual(apiError);
      expect(store.isProcessing).toBe(false);
    });

    it('should handle non-Error exceptions', async () => {
      vi.mocked(apiClient.post).mockRejectedValue({ message: 'Object error' });
      
      const store = useReinitAffPyrStore.getState();
      
      await expect(store.resetAllAffectations()).rejects.toThrow('Erreur réinitialisation globale');

      expect(store.error).toBeInstanceOf(Error);
    });

    it('should handle missing data in response', async () => {
      vi.mocked(apiClient.post).mockResolvedValue({
        success: true,
        data: undefined,
      });
      
      const count = await useReinitAffPyrStore.getState().resetAllAffectations();

      expect(count).toBe(0);
      expect(useReinitAffPyrStore.getState().lastResetCount).toBe(0);
    });
  });

  describe('getAffectationStatus - Mock Mode', () => {
    it('should return status with active affectations', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const status = await store.getAffectationStatus('SOC1', 1001);

      expect(status.hasActiveAffectations).toBe(true);
      expect(status.count).toBe(2);
    });

    it('should exclude null and empty affectations', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const status = await store.getAffectationStatus('SOC1', 1003);

      expect(status.hasActiveAffectations).toBe(false);
      expect(status.count).toBe(0);
    });

    it('should return false when no records match', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const status = await store.getAffectationStatus('SOC999', 9999);

      expect(status.hasActiveAffectations).toBe(false);
      expect(status.count).toBe(0);
    });

    it('should count records with non-empty affectationPyr', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const status = await store.getAffectationStatus('SOC1', 1004);

      expect(status.hasActiveAffectations).toBe(true);
      expect(status.count).toBe(2);
    });
  });

  describe('getAffectationStatus - Real API Mode', () => {
    beforeEach(() => {
      useDataSourceStore.setState({ isRealApi: true });
    });

    it('should call API with correct params and return status', async () => {
      vi.mocked(apiClient.get).mockResolvedValue(MOCK_STATUS_RESPONSE);
      
      const store = useReinitAffPyrStore.getState();
      const status = await store.getAffectationStatus('SOC1', 1001);

      expect(apiClient.get).toHaveBeenCalledWith(
        '/api/reinitAffPyr/status?societe=SOC1&compte=1001',
      );
      expect(status.hasActiveAffectations).toBe(true);
      expect(status.count).toBe(3);
    });

    it('should handle empty status response', async () => {
      vi.mocked(apiClient.get).mockResolvedValue(MOCK_STATUS_EMPTY_RESPONSE);
      
      const status = await useReinitAffPyrStore.getState().getAffectationStatus('SOC1', 1001);

      expect(status.hasActiveAffectations).toBe(false);
      expect(status.count).toBe(0);
    });

    it('should handle API error and set error state', async () => {
      const apiError = new Error('Connection timeout');
      vi.mocked(apiClient.get).mockRejectedValue(apiError);
      
      const store = useReinitAffPyrStore.getState();
      
      await expect(
        store.getAffectationStatus('SOC1', 1001),
      ).rejects.toThrow('Connection timeout');

      expect(store.error).toEqual(apiError);
    });

    it('should handle non-Error exceptions', async () => {
      vi.mocked(apiClient.get).mockRejectedValue(null);
      
      const store = useReinitAffPyrStore.getState();
      
      await expect(
        store.getAffectationStatus('SOC1', 1001),
      ).rejects.toThrow('Erreur vérification statut');

      expect(store.error).toBeInstanceOf(Error);
    });

    it('should handle missing data in response', async () => {
      vi.mocked(apiClient.get).mockResolvedValue({
        success: true,
        data: undefined,
      });
      
      const status = await useReinitAffPyrStore.getState().getAffectationStatus('SOC1', 1001);

      expect(status.hasActiveAffectations).toBe(false);
      expect(status.count).toBe(0);
    });
  });

  describe('clearError', () => {
    it('should clear error state', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValue(new Error('Test error'));
      
      const store = useReinitAffPyrStore.getState();
      
      await expect(
        store.reinitAffectationPyr({ societe: 'SOC1', compte: 1001 }),
      ).rejects.toThrow();
      
      expect(store.error).not.toBe(null);
      
      store.clearError();
      
      expect(useReinitAffPyrStore.getState().error).toBe(null);
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValue(MOCK_RESET_RESPONSE);
      
      const store = useReinitAffPyrStore.getState();
      
      await store.reinitAffectationPyr({ societe: 'SOC1', compte: 1001 });
      
      expect(store.lastResetCount).toBe(2);
      
      store.reset();
      
      const resetStore = useReinitAffPyrStore.getState();
      expect(resetStore.isProcessing).toBe(false);
      expect(resetStore.error).toBe(null);
      expect(resetStore.lastResetCount).toBe(0);
    });
  });

  describe('Business Rules', () => {
    it('should handle RM-001: empty chambre vs non-empty chambre logic', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const countWithEmptyChambre = await store.reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1002,
        chambre: '',
      });

      const countWithChambre = await store.reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1002,
        chambre: '201',
      });

      expect(countWithEmptyChambre).toBe(1);
      expect(countWithChambre).toBe(1);
    });

    it('should reset all PYR markers for compte indépendamment des chambres', async () => {
      const store = useReinitAffPyrStore.getState();
      
      const count = await store.reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1004,
      });

      expect(count).toBe(2);
    });

    it('should process masse update without complex validation', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValue({
        success: true,
        data: { affectedCount: 50 },
      });
      
      const count = await useReinitAffPyrStore.getState().reinitAffectationPyr({
        societe: 'SOC1',
        compte: 1001,
      });

      expect(count).toBe(50);
      expect(apiClient.post).toHaveBeenCalledTimes(1);
    });

    it('should support global reset for caisse closure scenario', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValue({
        success: true,
        data: { affectedCount: 200 },
      });
      
      const count = await useReinitAffPyrStore.getState().resetAllAffectations();

      expect(count).toBe(200);
      expect(apiClient.post).toHaveBeenCalledWith('/api/reinitAffPyr/reset-all');
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  ReinitAffectationParams,
  ReinitAffectationResponse,
  AffectationStatusResponse,
  ReinitAffPyrState,
} from '@/types/reinitAffPyr';
import { useDataSourceStore } from './dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

interface ReinitAffPyrStore extends ReinitAffPyrState {
  reset: () => void;
}

const initialState: Omit<ReinitAffPyrState, 'reinitAffectationPyr' | 'resetAllAffectations' | 'getAffectationStatus' | 'clearError'> = {
  isProcessing: false,
  error: null,
  lastResetCount: 0,
};

const MOCK_HEBERGEMENT_RECORDS = [
  { societe: 'SOC1', compte: 1001, chambre: '101', affectationPyr: 'P' },
  { societe: 'SOC1', compte: 1001, chambre: '102', affectationPyr: 'H' },
  { societe: 'SOC1', compte: 1002, chambre: '201', affectationPyr: 'P' },
  { societe: 'SOC1', compte: 1002, chambre: '', affectationPyr: 'P' },
  { societe: 'SOC1', compte: 1003, chambre: '301', affectationPyr: null },
  { societe: 'SOC1', compte: 1004, chambre: '401', affectationPyr: 'P' },
  { societe: 'SOC1', compte: 1004, chambre: '', affectationPyr: 'H' },
  { societe: 'SOC2', compte: 2001, chambre: '501', affectationPyr: 'P' },
  { societe: 'SOC2', compte: 2001, chambre: '502', affectationPyr: '' },
  { societe: 'SOC2', compte: 2002, chambre: '', affectationPyr: null },
];

export const useReinitAffPyrStore = create<ReinitAffPyrStore>()((set) => ({
  ...initialState,

  reinitAffectationPyr: async (params: ReinitAffectationParams) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isProcessing: true, error: null });

    if (!isRealApi) {
      await new Promise((resolve) => setTimeout(resolve, 800));
      
      const filtered = MOCK_HEBERGEMENT_RECORDS.filter(
        (r) =>
          r.societe === params.societe &&
          r.compte === params.compte &&
          (params.chambre === undefined || r.chambre === params.chambre),
      );

      const affectedCount = filtered.length;
      
      set({ 
        isProcessing: false, 
        lastResetCount: affectedCount 
      });
      return affectedCount;
    }

    try {
      const queryParams = new URLSearchParams({
        societe: params.societe,
        compte: String(params.compte),
      });
      
      if (params.chambre !== undefined) {
        queryParams.append('chambre', params.chambre);
      }

      const response = await apiClient.post<ApiResponse<ReinitAffectationResponse>>(
        `/api/reinitAffPyr/reset?${queryParams.toString()}`,
      );

      const affectedCount = response.data.data?.affectedCount ?? 0;
      
      set({ 
        lastResetCount: affectedCount,
        isProcessing: false 
      });
      
      return affectedCount;
    } catch (e: unknown) {
      const error = e instanceof Error ? e : new Error('Erreur réinitialisation affectation PYR');
      set({ error, isProcessing: false });
      throw error;
    }
  },

  resetAllAffectations: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isProcessing: true, error: null });

    if (!isRealApi) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      
      const totalCount = MOCK_HEBERGEMENT_RECORDS.length;
      
      set({ 
        isProcessing: false, 
        lastResetCount: totalCount 
      });
      return totalCount;
    }

    try {
      const response = await apiClient.post<ApiResponse<ReinitAffectationResponse>>(
        '/api/reinitAffPyr/reset-all',
      );

      const affectedCount = response.data.data?.affectedCount ?? 0;
      
      set({ 
        lastResetCount: affectedCount,
        isProcessing: false 
      });
      
      return affectedCount;
    } catch (e: unknown) {
      const error = e instanceof Error ? e : new Error('Erreur réinitialisation globale');
      set({ error, isProcessing: false });
      throw error;
    }
  },

  getAffectationStatus: async (societe: string, compte: number) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      const filtered = MOCK_HEBERGEMENT_RECORDS.filter(
        (r) =>
          r.societe === societe &&
          r.compte === compte &&
          r.affectationPyr !== null &&
          r.affectationPyr !== '',
      );

      return {
        hasActiveAffectations: filtered.length > 0,
        count: filtered.length,
      };
    }

    try {
      const queryParams = new URLSearchParams({
        societe,
        compte: String(compte),
      });

      const response = await apiClient.get<ApiResponse<AffectationStatusResponse>>(
        `/api/reinitAffPyr/status?${queryParams.toString()}`,
      );

      return response.data.data ?? { hasActiveAffectations: false, count: 0 };
    } catch (e: unknown) {
      const error = e instanceof Error ? e : new Error('Erreur vérification statut');
      set({ error });
      throw error;
    }
  },

  clearError: () => set({ error: null }),

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.