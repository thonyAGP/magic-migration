Generate Vitest unit tests for the "printConfigurationStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type { PrintConfig } from '@/types/printConfiguration';
import { useDataSourceStore } from './dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

interface PrintConfigState {
  currentConfig: PrintConfig | null;
  isInitializing: boolean;
  error: string | null;
}

interface PrintConfigActions {
  setListingNumber: (listingNumber: number) => Promise<void>;
  resetPrintParameters: () => Promise<void>;
  getPrintConfig: () => Promise<PrintConfig>;
  setError: (error: string | null) => void;
  reset: () => void;
}

type PrintConfigStore = PrintConfigState & PrintConfigActions;

const DEFAULT_CONFIG: PrintConfig = {
  currentListingNum: 0,
  currentPrinterName: 'VOID',
  currentPrinterNum: 0,
  numberCopies: 0,
  specificPrint: 'VOID',
};

const initialState: PrintConfigState = {
  currentConfig: null,
  isInitializing: false,
  error: null,
};

export const usePrintConfigStore = create<PrintConfigStore>()((set, get) => ({
  ...initialState,

  setListingNumber: async (listingNumber) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isInitializing: true, error: null });

    if (!isRealApi) {
      const config: PrintConfig = {
        currentListingNum: listingNumber,
        currentPrinterName: 'VOID',
        currentPrinterNum: 0,
        numberCopies: 0,
        specificPrint: 'VOID',
      };
      set({ currentConfig: config, isInitializing: false });
      return;
    }

    try {
      await apiClient.post<ApiResponse<void>>('/api/print-config/set-listing', {
        listingNumber,
      });
      const updatedConfig = await get().getPrintConfig();
      set({ currentConfig: updatedConfig });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur configuration listing';
      set({ error: message });
      throw e;
    } finally {
      set({ isInitializing: false });
    }
  },

  resetPrintParameters: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isInitializing: true, error: null });

    if (!isRealApi) {
      const current = get().currentConfig ?? DEFAULT_CONFIG;
      const config: PrintConfig = {
        ...current,
        currentPrinterName: 'VOID',
        currentPrinterNum: 0,
        numberCopies: 0,
      };
      set({ currentConfig: config, isInitializing: false });
      return;
    }

    try {
      await apiClient.post<ApiResponse<void>>('/api/print-config/reset', {});
      const updatedConfig = await get().getPrintConfig();
      set({ currentConfig: updatedConfig });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur réinitialisation';
      set({ error: message });
      throw e;
    } finally {
      set({ isInitializing: false });
    }
  },

  getPrintConfig: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isInitializing: true, error: null });

    if (!isRealApi) {
      const config = get().currentConfig ?? DEFAULT_CONFIG;
      set({ isInitializing: false });
      return config;
    }

    try {
      const response = await apiClient.get<ApiResponse<PrintConfig>>('/api/print-config');
      const config = response.data.data ?? DEFAULT_CONFIG;
      set({ currentConfig: config });
      return config;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur lecture config';
      set({ error: message });
      throw e;
    } finally {
      set({ isInitializing: false });
    }
  },

  setError: (error) => {
    set({ error });
  },

  reset: () => set({ ...initialState }),
}));

TYPES:
export interface PrintConfig {
  currentListingNum: number;
  currentPrinterName: string;
  currentPrinterNum: number;
  numberCopies: number;
  specificPrint: string;
}

export interface SetListingRequest {
  listingNumber: number;
}

export interface ResetPrintParametersRequest {}

export interface GetPrintConfigRequest {}

export type PrintConfigAction = 
  | { type: 'SET_CONFIG'; payload: PrintConfig }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'RESET' };

export interface PrintConfigState {
  currentConfig: PrintConfig | null;
  isInitializing: boolean;
  error: string | null;
  setListingNumber: (listingNumber: number) => Promise<void>;
  resetPrintParameters: () => Promise<void>;
  getPrintConfig: () => Promise<PrintConfig>;
  setError: (error: string | null) => void;
  reset: () => void;
}

export const DEFAULT_PRINT_CONFIG: PrintConfig = {
  currentListingNum: 0,
  currentPrinterName: 'VOID',
  currentPrinterNum: 0,
  numberCopies: 0,
  specificPrint: 'VOID',
};

ACTIONS TO COVER:
[
  {
    "name": "setListingNumber",
    "params": [
      "listingNumber: number"
    ],
    "businessRules": [
      "[RM-001] Si SPECIFICPRINT = 'VOID', initialiser les paramètres d'impression par défaut",
      "SetParam CURRENTLISTINGNUM avec le numéro de listing fourni",
      "SetParam CURRENTPRINTERNAME à 'VOID'",
      "SetParam CURRENTPRINTERNUM à 0",
      "SetParam NUMBERCOPIES à 0"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "resetPrintParameters",
    "params": [],
    "businessRules": [
      "Réinitialiser CURRENTPRINTERNAME à 'VOID'",
      "Réinitialiser CURRENTPRINTERNUM à 0",
      "Réinitialiser NUMBERCOPIES à 0"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "getPrintConfig",
    "params": [],
    "businessRules": [
      "Récupérer la configuration d'impression courante"
    ],
    "returns": "Promise<PrintConfig>"
  }
]