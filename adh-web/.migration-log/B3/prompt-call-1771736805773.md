Generate Vitest unit tests for the "choixPyrStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  Hebergement,
  ClientGm,
  ChoixPyrState,
  FetchHebergementsResponse,
  SelectChambreResponse,
} from '@/types/choixPyr';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface ChoixPyrActions {
  fetchHebergements: (
    societe: number,
    compte: number,
    filiation: number
  ) => Promise<void>;
  selectChambre: (hebergement: Hebergement) => Promise<void>;
  cancelSelection: () => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

type ChoixPyrStore = ChoixPyrState & ChoixPyrActions;

const MOCK_CLIENT: ClientGm = {
  societe: 1,
  compte: 1001,
  filiation: 0,
  nom: 'DUBOIS',
  prenom: 'Marc',
};

const MOCK_HEBERGEMENTS: Hebergement[] = [
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '101',
    dateDebut: new Date('2026-02-15'),
    dateFin: new Date('2026-02-28'),
    statut: 'ACTIF',
  },
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '203',
    dateDebut: new Date('2026-02-18'),
    dateFin: null,
    statut: 'ACTIF',
  },
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '305',
    dateDebut: new Date('2026-02-10'),
    dateFin: new Date('2026-03-05'),
    statut: 'ACTIF',
  },
];

const initialState: ChoixPyrState = {
  hebergements: [],
  selectedHebergement: null,
  clientInfo: null,
  isLoading: false,
  error: null,
};

export const useChoixPyrStore = create<ChoixPyrStore>()((set, get) => ({
  ...initialState,

  fetchHebergements: async (societe, compte, filiation) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const today = new Date();
      const validHebergements = MOCK_HEBERGEMENTS.filter(
        (h) => h.dateDebut <= today && (h.dateFin === null || h.dateFin >= today)
      );
      set({
        hebergements: validHebergements,
        clientInfo: MOCK_CLIENT,
        isLoading: false,
      });
      return;
    }

    try {
      const response = await apiClient.get<FetchHebergementsResponse>(
        `/api/choixPyr/hebergements?societe=${societe}&compte=${compte}&filiation=${filiation}`
      );
      const data = response.data.data;
      set({
        hebergements: data?.hebergements ?? [],
        clientInfo: data?.clientInfo ?? null,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement hebergements';
      set({ hebergements: [], clientInfo: null, error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  selectChambre: async (hebergement) => {
    const { isRealApi } = useDataSourceStore.getState();
    const { clientInfo } = get();

    if (!clientInfo) {
      set({ error: 'Aucune information client disponible' });
      return;
    }

    if (
      hebergement.societe !== clientInfo.societe ||
      hebergement.compte !== clientInfo.compte ||
      hebergement.filiation !== clientInfo.filiation
    ) {
      set({ error: 'Hebergement non valide pour ce client' });
      return;
    }

    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({
        selectedHebergement: hebergement,
        isLoading: false,
      });
      return;
    }

    try {
      const response = await apiClient.post<SelectChambreResponse>(
        '/api/choixPyr/select',
        {
          societe: hebergement.societe,
          compte: hebergement.compte,
          filiation: hebergement.filiation,
          chambre: hebergement.chambre,
        }
      );
      if (response.data.data?.success) {
        set({ selectedHebergement: hebergement });
      } else {
        set({ error: 'Echec selection chambre' });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur selection chambre';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  cancelSelection: () => {
    set({ selectedHebergement: null, error: null });
  },

  setError: (error) => {
    set({ error });
  },

  reset: () => set({ ...initialState }),
}));

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export interface Hebergement {
  societe: number;
  compte: number;
  filiation: number;
  chambre: string;
  dateDebut: Date;
  dateFin: Date | null;
  statut: string;
}

export interface ClientGm {
  societe: number;
  compte: number;
  filiation: number;
  nom: string;
  prenom: string | null;
}

export interface ChoixPyrState {
  hebergements: Hebergement[];
  selectedHebergement: Hebergement | null;
  clientInfo: ClientGm | null;
  isLoading: boolean;
  error: string | null;
  fetchHebergements: (
    societe: number,
    compte: number,
    filiation: number
  ) => Promise<void>;
  selectChambre: (hebergement: Hebergement) => Promise<void>;
  cancelSelection: () => Promise<void>;
  setError: (error: string | null) => void;
  reset: () => void;
}

export interface FetchHebergementsRequest {
  societe: number;
  compte: number;
  filiation: number;
}

export interface FetchHebergementsResponse extends ApiResponse {
  data: {
    hebergements: Hebergement[];
    clientInfo: ClientGm;
  };
}

export interface SelectChambreRequest {
  societe: number;
  compte: number;
  filiation: number;
  chambre: string;
}

export interface SelectChambreResponse extends ApiResponse {
  data: {
    success: boolean;
    selectedChambre: string;
  };
}

export type ChoixPyrActionType =
  | "FETCH_HEBERGEMENTS_START"
  | "FETCH_HEBERGEMENTS_SUCCESS"
  | "FETCH_HEBERGEMENTS_ERROR"
  | "SELECT_CHAMBRE"
  | "CANCEL_SELECTION"
  | "SET_ERROR"
  | "RESET";

ACTIONS TO COVER:
[
  {
    "name": "fetchHebergements",
    "params": [
      "societe: number",
      "compte: number",
      "filiation: number"
    ],
    "businessRules": [
      "RM-001: Charger tous les hebergements actifs pour le client GM specifie",
      "RM-002: Filtrer les chambres valides (date debut <= aujourd'hui, date fin >= aujourd'hui ou null)",
      "Joindre avec client_gm pour recuperer les informations du client"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "selectChambre",
    "params": [
      "hebergement: Hebergement"
    ],
    "businessRules": [
      "RM-001: Valider que l'hebergement selectionne appartient au client",
      "RM-002: Mettre a jour la table hebergement pour marquer la chambre selectionnee",
      "Retourner la chambre selectionnee au programme appelant"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "cancelSelection",
    "params": [],
    "businessRules": [
      "RM-004: Annuler la selection et retourner sans mise a jour",
      "Fermer le dialogue de selection"
    ],
    "returns": "Promise<void>"
  }
]