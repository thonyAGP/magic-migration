Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/programDispatchStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
programDispatchStore getLastClickedControl should return null when no control clicked in mock mode: AssertionError: expected 'BTN_TELEPHONE' to be null
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/programDispatchStore.test.ts:181:27
    at processTicksAndRejections (node:internal/process/t

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useProgramDispatchStore } from '@/stores/programDispatchStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import type { ProgramDispatchRoute, LastClickedResponse } from '@/types/programDispatch';
import { useDataSourceStore } from '@/stores/dataSourceStore';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    post: vi.fn(),
    get: vi.fn(),
  },
}));

const MOCK_SUCCESS_ROUTE: ApiResponse<ProgramDispatchRoute> = {
  success: true,
  data: {
    controlId: 'BTN_CHANGE',
    success: true,
    targetProgram: 'ADH-25',
  },
};

const MOCK_FAILED_ROUTE: ApiResponse<ProgramDispatchRoute> = {
  success: true,
  data: {
    controlId: 'BTN_INVALID',
    success: false,
    error: 'Programme cible non trouvé',
  },
};

const MOCK_LAST_CLICKED: ApiResponse<LastClickedResponse> = {
  success: true,
  data: {
    controlId: 'BTN_TELEPHONE',
  },
};

describe('programDispatchStore', () => {
  beforeEach(() => {
    useProgramDispatchStore.getState().reset();
    useProgramDispatchStore.getState().clearDispatch();
    useDataSourceStore.setState({ isRealApi: false });
    vi.clearAllMocks();
  });

  describe('dispatchToProgram', () => {
    it('should dispatch to valid program in mock mode', async () => {
      const { dispatchToProgram } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_CHANGE');

      const state = useProgramDispatchStore.getState();
      expect(state.lastClickedControl).toBe('BTN_CHANGE');
      expect(state.isDispatching).toBe(false);
      expect(state.error).toBeNull();
      expect(apiClient.post).not.toHaveBeenCalled();
    });

    it('should set error for invalid control in mock mode', async () => {
      const { dispatchToProgram } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_INVALID');

      const state = useProgramDispatchStore.getState();
      expect(state.lastClickedControl).toBe('BTN_INVALID');
      expect(state.isDispatching).toBe(false);
      expect(state.error).toContain('Programme cible non trouvé');
    });

    it('should dispatch to valid program in real API mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: MOCK_SUCCESS_ROUTE });

      const { dispatchToProgram } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_CHANGE');

      expect(apiClient.post).toHaveBeenCalledWith(
        '/api/programDispatch/route',
        null,
        { params: { controlId: 'BTN_CHANGE' } }
      );

      const state = useProgramDispatchStore.getState();
      expect(state.lastClickedControl).toBe('BTN_CHANGE');
      expect(state.isDispatching).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should set error when API returns failure in real API mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: MOCK_FAILED_ROUTE });

      const { dispatchToProgram } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_INVALID');

      const state = useProgramDispatchStore.getState();
      expect(state.isDispatching).toBe(false);
      expect(state.error).toBe('Programme cible non trouvé');
    });

    it('should handle API error in real API mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Network error'));

      const { dispatchToProgram } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_CHANGE');

      const state = useProgramDispatchStore.getState();
      expect(state.isDispatching).toBe(false);
      expect(state.error).toBe('Network error');
    });

    it('should handle unknown error type in real API mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce('string error');

      const { dispatchToProgram } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_CHANGE');

      const state = useProgramDispatchStore.getState();
      expect(state.isDispatching).toBe(false);
      expect(state.error).toBe('Erreur dispatch programme');
    });

    it('should set isDispatching to true during dispatch', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      let resolvePromise: ((value: unknown) => void) | undefined;
      const promise = new Promise((resolve) => { resolvePromise = resolve; });
      vi.mocked(apiClient.post).mockReturnValueOnce(promise);

      const { dispatchToProgram } = useProgramDispatchStore.getState();
      const dispatchPromise = dispatchToProgram('BTN_CHANGE');

      expect(useProgramDispatchStore.getState().isDispatching).toBe(true);

      resolvePromise?.({ data: MOCK_SUCCESS_ROUTE });
      await dispatchPromise;

      expect(useProgramDispatchStore.getState().isDispatching).toBe(false);
    });

    it('should route to all 15 valid controls in mock mode', async () => {
      const validControls = [
        'BTN_CHANGE', 'BTN_DEPOT', 'BTN_GARANTIE', 'BTN_GRATUITES',
        'BTN_VERSEMENT', 'BTN_TELEPHONE', 'BTN_MENU_COMPTE', 'BTN_EXTRAIT',
        'BTN_CMP', 'BTN_BAR_LIMIT', 'BTN_GM_MENU', 'BTN_CAISSE_GM',
        'BTN_FORFAIT_TAI', 'BTN_SOLDE', 'BTN_IMPRESSION', 'BTN_VENTE',
      ];

      const { dispatchToProgram } = useProgramDispatchStore.getState();

      for (const controlId of validControls) {
        await dispatchToProgram(controlId);
        const state = useProgramDispatchStore.getState();
        expect(state.error).toBeNull();
      }
    });
  });

  describe('getLastClickedControl', () => {
    it('should return last clicked control in mock mode', async () => {
      const { dispatchToProgram, getLastClickedControl } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_TELEPHONE');
      const lastClicked = await getLastClickedControl();

      expect(lastClicked).toBe('BTN_TELEPHONE');
    });

    it('should return null when no control clicked in mock mode', async () => {
      const { getLastClickedControl } = useProgramDispatchStore.getState();

      const lastClicked = await getLastClickedControl();

      expect(lastClicked).toBeNull();
    });

    it('should retrieve last clicked control from API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValueOnce({ data: MOCK_LAST_CLICKED });

      const { getLastClickedControl } = useProgramDispatchStore.getState();
      const lastClicked = await getLastClickedControl();

      expect(apiClient.get).toHaveBeenCalledWith('/api/programDispatch/lastClicked');
      expect(lastClicked).toBe('BTN_TELEPHONE');
    });

    it('should return null when API returns null control', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { success: true, data: { controlId: null } },
      });

      const { getLastClickedControl } = useProgramDispatchStore.getState();
      const lastClicked = await getLastClickedControl();

      expect(lastClicked).toBeNull();
    });

    it('should handle API error when retrieving last clicked', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('API error'));

      const { getLastClickedControl } = useProgramDispatchStore.getState();
      const lastClicked = await getLastClickedControl();

      expect(lastClicked).toBeNull();
      expect(useProgramDispatchStore.getState().error).toBe('API error');
    });

    it('should handle unknown error type when retrieving last clicked', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce('string error');

      const { getLastClickedControl } = useProgramDispatchStore.getState();
      const lastClicked = await getLastClickedControl();

      expect(lastClicked).toBeNull();
      expect(useProgramDispatchStore.getState().error).toBe('Erreur récupération dernier contrôle');
    });
  });

  describe('clearDispatch', () => {
    it('should clear last clicked control and error', async () => {
      const { dispatchToProgram, clearDispatch } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_INVALID');
      expect(useProgramDispatchStore.getState().lastClickedControl).toBe('BTN_INVALID');
      expect(useProgramDispatchStore.getState().error).not.toBeNull();

      clearDispatch();

      const state = useProgramDispatchStore.getState();
      expect(state.lastClickedControl).toBeNull();
      expect(state.error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', async () => {
      const { dispatchToProgram, reset } = useProgramDispatchStore.getState();

      await dispatchToProgram('BTN_CHANGE');

      reset();

      const state = useProgramDispatchStore.getState();
      expect(state.lastClickedControl).toBeNull();
      expect(state.isDispatching).toBe(false);
      expect(state.error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  ProgramDispatchRoute,
  LastClickedResponse,
} from '@/types/programDispatch';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface ProgramDispatchState {
  lastClickedControl: string | null;
  isDispatching: boolean;
  error: string | null;
}

interface ProgramDispatchActions {
  dispatchToProgram: (controlId: string) => Promise<void>;
  getLastClickedControl: () => Promise<string | null>;
  clearDispatch: () => void;
  reset: () => void;
}

type ProgramDispatchStore = ProgramDispatchState & ProgramDispatchActions;

const MOCK_ROUTES: Record<string, string> = {
  BTN_CHANGE: 'ADH-25',
  BTN_DEPOT: 'ADH-40',
  BTN_GARANTIE: 'ADH-111',
  BTN_GRATUITES: 'ADH-168',
  BTN_VERSEMENT: 'ADH-174',
  BTN_TELEPHONE: 'ADH-217',
  BTN_MENU_COMPTE: 'ADH-37',
  BTN_EXTRAIT: 'ADH-69',
  BTN_CMP: 'ADH-77',
  BTN_BAR_LIMIT: 'ADH-86',
  BTN_GM_MENU: 'ADH-158',
  BTN_CAISSE_GM: 'ADH-163',
  BTN_FORFAIT_TAI: 'ADH-173',
  BTN_SOLDE: 'ADH-190',
  BTN_IMPRESSION: 'ADH-214',
  BTN_VENTE: 'ADH-242',
};

let MOCK_LAST_CLICKED: string | null = null;

const initialState: ProgramDispatchState = {
  lastClickedControl: null,
  isDispatching: false,
  error: null,
};

export const useProgramDispatchStore = create<ProgramDispatchStore>()((set) => ({
  ...initialState,

  dispatchToProgram: async (controlId) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isDispatching: true, error: null, lastClickedControl: controlId });

    if (!isRealApi) {
      MOCK_LAST_CLICKED = controlId;
      const targetProgram = MOCK_ROUTES[controlId];
      if (targetProgram) {
        set({ isDispatching: false });
      } else {
        set({
          error: `Programme cible non trouvé pour le contrôle ${controlId}`,
          isDispatching: false,
        });
      }
      return;
    }

    try {
      const response = await apiClient.post<ApiResponse<ProgramDispatchRoute>>(
        '/api/programDispatch/route',
        null,
        { params: { controlId } },
      );

      if (!response.data.success || !response.data.data?.success) {
        throw new Error(
          response.data.data?.error ?? 'Erreur lors du routage',
        );
      }

      set({ isDispatching: false });
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur dispatch programme';
      set({ error: message, isDispatching: false });
    }
  },

  getLastClickedControl: async () => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      return MOCK_LAST_CLICKED;
    }

    try {
      const response = await apiClient.get<ApiResponse<LastClickedResponse>>(
        '/api/programDispatch/lastClicked',
      );

      if (!response.data.success) {
        throw new Error('Impossible de récupérer le dernier contrôle cliqué');
      }

      return response.data.data?.controlId ?? null;
    } catch (e: unknown) {
      const message =
        e instanceof Error
          ? e.message
          : 'Erreur récupération dernier contrôle';
      set({ error: message });
      return null;
    }
  },

  clearDispatch: () => {
    set({ lastClickedControl: null, error: null });
  },

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.