```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useFidelisationRemiseStore } from '@/stores/fidelisationRemiseStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { FidelisationRemise } from '@/types/fidelisationRemise';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

const MOCK_GOLD_REMISE: FidelisationRemise = {
  societe: 'SOC1',
  compte: 1001,
  filiation: 0,
  service: 'RST',
  imputation: 101,
  fidelisation: 'GOLD',
  remise: 15,
};

const MOCK_EXPIRED_REMISE: FidelisationRemise = {
  societe: 'SOC1',
  compte: 1004,
  filiation: 0,
  service: 'BAR',
  imputation: 104,
  fidelisation: 'EXPIRED',
  remise: null,
};

const MOCK_NO_FIDELISATION: FidelisationRemise = {
  societe: 'SOC1',
  compte: 1005,
  filiation: 0,
  service: 'RST',
  imputation: 105,
  fidelisation: null,
  remise: null,
};

describe('fidelisationRemiseStore', () => {
  beforeEach(() => {
    useFidelisationRemiseStore.getState().reset();
    vi.clearAllMocks();
    useDataSourceStore.setState({ isRealApi: false });
  });

  describe('getFidelisationRemise', () => {
    it('should fetch and calculate remise for valid GOLD fidelisation (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      await store.getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);

      const state = useFidelisationRemiseStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.remiseData).toEqual(MOCK_GOLD_REMISE);
      expect(state.remiseResult).toEqual({
        fidelisationId: 'GOLD',
        montantRemise: 15,
        isValide: true,
        message: null,
      });
    });

    it('should handle EXPIRED fidelisation as invalid (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      await store.getFidelisationRemise('SOC1', 1004, 0, 'BAR', 104);

      const state = useFidelisationRemiseStore.getState();
      expect(state.remiseData).toEqual(MOCK_EXPIRED_REMISE);
      expect(state.remiseResult).toEqual({
        fidelisationId: 'EXPIRED',
        montantRemise: 0,
        isValide: false,
        message: 'Programme de fidelisation expire',
      });
    });

    it('should handle no fidelisation program (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      await store.getFidelisationRemise('SOC1', 1005, 0, 'RST', 105);

      const state = useFidelisationRemiseStore.getState();
      expect(state.remiseData).toEqual(MOCK_NO_FIDELISATION);
      expect(state.remiseResult).toEqual({
        fidelisationId: null,
        montantRemise: 0,
        isValide: false,
        message: 'Aucun programme de fidelisation actif',
      });
    });

    it('should handle non-existent compte (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      await store.getFidelisationRemise('SOC1', 9999, 0, 'RST', 999);

      const state = useFidelisationRemiseStore.getState();
      expect(state.remiseData).toBeNull();
      expect(state.remiseResult).toBeNull();
    });

    it('should fetch from API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      const mockApiResponse = {
        data: {
          data: {
            fidelisationId: 'PLATINUM',
            montantRemise: 20,
            isValide: true,
            message: null,
          },
          success: true,
        },
      };

      vi.mocked(apiClient.get).mockResolvedValueOnce(mockApiResponse);

      const store = useFidelisationRemiseStore.getState();
      await store.getFidelisationRemise('SOC2', 2001, 0, 'SPA', 201);

      const state = useFidelisationRemiseStore.getState();
      expect(apiClient.get).toHaveBeenCalledWith('/api/fidelisation-remise/get', {
        params: {
          societe: 'SOC2',
          compte: 2001,
          filiation: 0,
          service: 'SPA',
          imputation: 201,
        },
      });
      expect(state.remiseResult).toEqual({
        fidelisationId: 'PLATINUM',
        montantRemise: 20,
        isValide: true,
        message: null,
      });
    });

    it('should handle API error', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Network error'));

      const store = useFidelisationRemiseStore.getState();
      await store.getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);

      const state = useFidelisationRemiseStore.getState();
      expect(state.error).toBe('Network error');
      expect(state.remiseData).toBeNull();
      expect(state.remiseResult).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should set loading state during fetch', async () => {
      const store = useFidelisationRemiseStore.getState();

      const promise = store.getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);
      expect(useFidelisationRemiseStore.getState().isLoading).toBe(true);

      await promise;
      expect(useFidelisationRemiseStore.getState().isLoading).toBe(false);
    });
  });

  describe('validateRemiseEligibility', () => {
    it('should validate eligible remise (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      const isValid = await store.validateRemiseEligibility(MOCK_GOLD_REMISE);

      expect(isValid).toBe(true);
      expect(useFidelisationRemiseStore.getState().isLoading).toBe(false);
      expect(useFidelisationRemiseStore.getState().error).toBeNull();
    });

    it('should reject expired fidelisation (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      const isValid = await store.validateRemiseEligibility(MOCK_EXPIRED_REMISE);

      expect(isValid).toBe(false);
    });

    it('should reject remise with no fidelisation (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      const isValid = await store.validateRemiseEligibility(MOCK_NO_FIDELISATION);

      expect(isValid).toBe(false);
    });

    it('should reject remise with zero amount (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      const zeroRemise: FidelisationRemise = {
        ...MOCK_GOLD_REMISE,
        remise: 0,
      };

      const isValid = await store.validateRemiseEligibility(zeroRemise);

      expect(isValid).toBe(false);
    });

    it('should call API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: {
          data: { isValide: true },
          success: true,
        },
      });

      const store = useFidelisationRemiseStore.getState();
      const isValid = await store.validateRemiseEligibility(MOCK_GOLD_REMISE);

      expect(apiClient.post).toHaveBeenCalledWith('/api/fidelisation-remise/validate', {
        remiseData: MOCK_GOLD_REMISE,
      });
      expect(isValid).toBe(true);
    });

    it('should handle API error during validation', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Validation failed'));

      const store = useFidelisationRemiseStore.getState();
      const isValid = await store.validateRemiseEligibility(MOCK_GOLD_REMISE);

      expect(isValid).toBe(false);
      expect(useFidelisationRemiseStore.getState().error).toBe('Validation failed');
    });
  });

  describe('calculateMontantRemise', () => {
    it('should calculate remise amount for valid data (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      const montant = await store.calculateMontantRemise(MOCK_GOLD_REMISE);

      expect(montant).toBe(15);
      expect(useFidelisationRemiseStore.getState().isLoading).toBe(false);
      expect(useFidelisationRemiseStore.getState().error).toBeNull();
    });

    it('should return 0 for expired fidelisation (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      const montant = await store.calculateMontantRemise(MOCK_EXPIRED_REMISE);

      expect(montant).toBe(0);
    });

    it('should return 0 for no fidelisation (mock)', async () => {
      const store = useFidelisationRemiseStore.getState();

      const montant = await store.calculateMontantRemise(MOCK_NO_FIDELISATION);

      expect(montant).toBe(0);
    });

    it('should call API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: {
          data: { montantRemise: 25 },
          success: true,
        },
      });

      const store = useFidelisationRemiseStore.getState();
      const montant = await store.calculateMontantRemise(MOCK_GOLD_REMISE);

      expect(apiClient.post).toHaveBeenCalledWith('/api/fidelisation-remise/calculate', {
        remiseData: MOCK_GOLD_REMISE,
      });
      expect(montant).toBe(25);
    });

    it('should handle API error during calculation', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Calculation failed'));

      const store = useFidelisationRemiseStore.getState();
      const montant = await store.calculateMontantRemise(MOCK_GOLD_REMISE);

      expect(montant).toBe(0);
      expect(useFidelisationRemiseStore.getState().error).toBe('Calculation failed');
    });

    it('should return 0 when API returns no data', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: {
          data: undefined,
          success: true,
        },
      });

      const store = useFidelisationRemiseStore.getState();
      const montant = await store.calculateMontantRemise(MOCK_GOLD_REMISE);

      expect(montant).toBe(0);
    });
  });

  describe('setError', () => {
    it('should set error message', () => {
      const store = useFidelisationRemiseStore.getState();

      store.setError('Custom error');

      expect(useFidelisationRemiseStore.getState().error).toBe('Custom error');
    });

    it('should clear error when null', () => {
      useFidelisationRemiseStore.setState({ error: 'Existing error' });

      const store = useFidelisationRemiseStore.getState();
      store.setError(null);

      expect(useFidelisationRemiseStore.getState().error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', () => {
      useFidelisationRemiseStore.setState({
        isLoading: true,
        error: 'Some error',
        remiseData: MOCK_GOLD_REMISE,
        remiseResult: {
          fidelisationId: 'GOLD',
          montantRemise: 15,
          isValide: true,
          message: null,
        },
      });

      const store = useFidelisationRemiseStore.getState();
      store.reset();

      const state = useFidelisationRemiseStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.remiseData).toBeNull();
      expect(state.remiseResult).toBeNull();
    });
  });

  describe('business rules', () => {
    it('should validate remise is not used twice in same period', async () => {
      const store = useFidelisationRemiseStore.getState();

      await store.getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);
      const firstResult = useFidelisationRemiseStore.getState().remiseResult;

      await store.getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);
      const secondResult = useFidelisationRemiseStore.getState().remiseResult;

      expect(firstResult).toEqual(secondResult);
    });

    it('should verify remise conforms to client profile', async () => {
      const store = useFidelisationRemiseStore.getState();

      await store.getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);
      const goldRemise = useFidelisationRemiseStore.getState().remiseData;

      expect(goldRemise?.fidelisation).toBe('GOLD');
      expect(goldRemise?.remise).toBe(15);
    });

    it('should apply configured remise rules and thresholds', async () => {
      const store = useFidelisationRemiseStore.getState();

      await store.getFidelisationRemise('SOC1', 1002, 0, 'BTQ', 102);
      const silverRemise = useFidelisationRemiseStore.getState().remiseData;

      expect(silverRemise?.fidelisation).toBe('SILVER');
      expect(silverRemise?.remise).toBe(10);
      expect((silverRemise?.remise ?? 0) < 15).toBe(true);
    });
  });
});
```