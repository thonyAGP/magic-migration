Generate Vitest unit tests for the "soldeOuvertureStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  SoldeOuverture,
  MoyenReglement,
  GestionDeviseSession,
  SoldeCalculationResult,
  CoherenceValidationResult,
  CalculerSoldeOuvertureRequest,
  GetSoldeOuvertureRequest,
  ValiderCoherenceSoldeRequest,
  UpdateDeviseSessionRequest,
} from '@/types/soldeOuverture';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface SoldeOuvertureState {
  soldeOuverture: SoldeOuverture | null;
  moyensReglement: MoyenReglement[];
  devisesSessions: GestionDeviseSession[];
  isLoading: boolean;
  error: string | null;
  isCalculating: boolean;
  calculationResult: SoldeCalculationResult | null;
}

interface SoldeOuvertureActions {
  loadSoldeOuverture: (societe: string, sessionId: number) => Promise<void>;
  calculerSoldeOuverture: (
    societe: string,
    sessionId: number,
  ) => Promise<SoldeCalculationResult>;
  updateDeviseSession: (sessionId: number) => Promise<void>;
  validerCoherenceSolde: (
    soldeEnregistre: number,
    soldeCalcule: number,
  ) => Promise<CoherenceValidationResult>;
  setSoldeOuverture: (solde: SoldeOuverture | null) => void;
  setMoyensReglement: (moyens: MoyenReglement[]) => void;
  setDevisesSessions: (devises: GestionDeviseSession[]) => void;
  setCalculationResult: (result: SoldeCalculationResult | null) => void;
  clearError: () => void;
  reset: () => void;
}

type SoldeOuvertureStore = SoldeOuvertureState & SoldeOuvertureActions;

const MOCK_MOYENS_REGLEMENT: MoyenReglement[] = [
  { id: 1, code: 'ESP', libelle: 'Espèces' },
  { id: 2, code: 'CB', libelle: 'Carte bancaire' },
  { id: 3, code: 'CHQ', libelle: 'Chèque' },
  { id: 4, code: 'GP', libelle: 'Gift Pass' },
  { id: 5, code: 'OD', libelle: 'Ordre de dépôt' },
];

const MOCK_DEVISES_SESSIONS: GestionDeviseSession[] = [
  { id: 1, sessionId: 1001, deviseCode: 'EUR', tauxChange: 1.0, montant: 500.0 },
  { id: 2, sessionId: 1001, deviseCode: 'USD', tauxChange: 1.08, montant: 324.0 },
  { id: 3, sessionId: 1001, deviseCode: 'GBP', tauxChange: 0.85, montant: 170.0 },
  { id: 4, sessionId: 1001, deviseCode: 'CHF', tauxChange: 0.95, montant: 95.0 },
  { id: 5, sessionId: 1001, deviseCode: 'JPY', tauxChange: 157.0, montant: 15700.0 },
];

const MOCK_SOLDE_OUVERTURE: SoldeOuverture = {
  societe: 'SOC1',
  deviseLocale: 'EUR',
  soldeOuverture: 1200.0,
  soldeOuvertureMonnaie: 500.0,
  soldeOuvertureProduits: 350.0,
  soldeOuvertureCartes: 200.0,
  soldeOuvertureCheques: 100.0,
  soldeOuvertureOd: 50.0,
  nbreDevise: 5,
  uniBi: 'BI',
};

const MOCK_CALCULATION_RESULT: SoldeCalculationResult = {
  totalEur: 1200.0,
  details: [
    { devise: 'EUR', montant: 500.0, tauxChange: 1.0, montantEur: 500.0 },
    { devise: 'USD', montant: 324.0, tauxChange: 1.08, montantEur: 300.0 },
    { devise: 'GBP', montant: 170.0, tauxChange: 0.85, montantEur: 200.0 },
    { devise: 'CHF', montant: 95.0, tauxChange: 0.95, montantEur: 100.0 },
    { devise: 'JPY', montant: 15700.0, tauxChange: 157.0, montantEur: 100.0 },
  ],
};

const initialState: SoldeOuvertureState = {
  soldeOuverture: null,
  moyensReglement: [],
  devisesSessions: [],
  isLoading: false,
  error: null,
  isCalculating: false,
  calculationResult: null,
};

export const useSoldeOuvertureStore = create<SoldeOuvertureStore>()((set) => ({
  ...initialState,

  loadSoldeOuverture: async (societe, sessionId) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({
        soldeOuverture: MOCK_SOLDE_OUVERTURE,
        moyensReglement: MOCK_MOYENS_REGLEMENT,
        devisesSessions: MOCK_DEVISES_SESSIONS,
        isLoading: false,
      });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<SoldeOuverture>>(
        `/api/solde-ouverture/${societe}/${sessionId}`,
      );
      const data = response.data.data;
      set({
        soldeOuverture: data ?? null,
        moyensReglement: MOCK_MOYENS_REGLEMENT,
        devisesSessions: MOCK_DEVISES_SESSIONS,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement solde ouverture';
      set({ soldeOuverture: null, error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  calculerSoldeOuverture: async (societe, sessionId) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isCalculating: true, error: null });

    if (!isRealApi) {
      set({
        calculationResult: MOCK_CALCULATION_RESULT,
        isCalculating: false,
      });
      return MOCK_CALCULATION_RESULT;
    }

    try {
      const request: CalculerSoldeOuvertureRequest = { societe, sessionId };
      const response = await apiClient.post<ApiResponse<SoldeCalculationResult>>(
        '/api/solde-ouverture/calculer',
        request,
      );
      const data = response.data.data;
      if (!data) {
        throw new Error('Aucune donnée retournée');
      }
      set({ calculationResult: data });
      return data;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur calcul solde ouverture';
      set({ calculationResult: null, error: message });
      throw e;
    } finally {
      set({ isCalculating: false });
    }
  },

  updateDeviseSession: async (sessionId) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({ isLoading: false });
      return;
    }

    try {
      const request: UpdateDeviseSessionRequest = { sessionId };
      await apiClient.post<ApiResponse<void>>(
        '/api/solde-ouverture/update-devise-session',
        request,
      );
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur mise à jour devises session';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  validerCoherenceSolde: async (soldeEnregistre, soldeCalcule) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const ecart = Math.abs(soldeEnregistre - soldeCalcule);
      const mockResult: CoherenceValidationResult = {
        coherent: ecart < 0.01,
        ecart: ecart > 0 ? ecart : null,
      };
      set({ isLoading: false });
      return mockResult;
    }

    try {
      const request: ValiderCoherenceSoldeRequest = { soldeEnregistre, soldeCalcule };
      const response = await apiClient.post<ApiResponse<CoherenceValidationResult>>(
        '/api/solde-ouverture/valider-coherence',
        request,
      );
      const data = response.data.data;
      if (!data) {
        throw new Error('Aucune donnée retournée');
      }
      return data;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation cohérence';
      set({ error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  setSoldeOuverture: (solde) => set({ soldeOuverture: solde }),
  setMoyensReglement: (moyens) => set({ moyensReglement: moyens }),
  setDevisesSessions: (devises) => set({ devisesSessions: devises }),
  setCalculationResult: (result) => set({ calculationResult: result }),
  clearError: () => set({ error: null }),
  reset: () => set({ ...initialState }),
}));

TYPES:
import type { ApiResponse } from '@/services/api/apiClient';

// ============================================================================
// ENTITIES
// ============================================================================

export interface SoldeOuverture {
  societe: string;
  deviseLocale: string;
  soldeOuverture: number;
  soldeOuvertureMonnaie: number;
  soldeOuvertureProduits: number;
  soldeOuvertureCartes: number;
  soldeOuvertureCheques: number;
  soldeOuvertureOd: number;
  nbreDevise: number;
  uniBi: string;
}

export interface MoyenReglement {
  id: number;
  code: string;
  libelle: string;
}

export interface GestionDeviseSession {
  id: number;
  sessionId: number;
  deviseCode: string;
  tauxChange: number;
  montant: number;
}

// ============================================================================
// CALCULATION TYPES
// ============================================================================

export interface DeviseConversion {
  devise: string;
  montant: number;
  tauxChange: number;
  montantEur: number;
}

export interface SoldeCalculationResult {
  totalEur: number;
  details: DeviseConversion[];
}

export interface CoherenceValidationResult {
  coherent: boolean;
  ecart: number | null;
}

// ============================================================================
// REQUEST/RESPONSE TYPES
// ============================================================================

export interface CalculerSoldeOuvertureRequest {
  societe: string;
  sessionId: number;
}

export interface GetSoldeOuvertureRequest {
  societe: string;
  sessionId: number;
}

export interface ValiderCoherenceSoldeRequest {
  soldeEnregistre: number;
  soldeCalcule: number;
}

export interface UpdateDeviseSessionRequest {
  sessionId: number;
}

// ============================================================================
// API RESPONSE TYPES
// ============================================================================

export type CalculerSoldeOuvertureResponse = ApiResponse<SoldeCalculationResult>;
export type GetSoldeOuvertureResponse = ApiResponse<SoldeOuverture>;
export type ValiderCoherenceSoldeResponse = ApiResponse<CoherenceValidationResult>;
export type UpdateDeviseSessionResponse = ApiResponse<void>;

// ============================================================================
// STORE STATE
// ============================================================================

export interface SoldeOuvertureState {
  soldeOuverture: SoldeOuverture | null;
  moyensReglement: MoyenReglement[];
  devisesSessions: GestionDeviseSession[];
  isLoading: boolean;
  error: string | null;
  isCalculating: boolean;
  calculationResult: SoldeCalculationResult | null;
}

// ============================================================================
// STORE ACTIONS
// ============================================================================

export interface SoldeOuvertureActions {
  loadSoldeOuverture: (societe: string, sessionId: number) => Promise<void>;
  calculerSoldeOuverture: (
    societe: string,
    sessionId: number,
  ) => Promise<SoldeCalculationResult>;
  updateDeviseSession: (sessionId: number) => Promise<void>;
  validerCoherenceSolde: (
    soldeEnregistre: number,
    soldeCalcule: number,
  ) => Promise<CoherenceValidationResult>;
  setSoldeOuverture: (solde: SoldeOuverture | null) => void;
  setMoyensReglement: (moyens: MoyenReglement[]) => void;
  setDevisesSessions: (devises: GestionDeviseSession[]) => void;
  setCalculationResult: (result: SoldeCalculationResult | null) => void;
  clearError: () => void;
  reset: () => void;
}

export type SoldeOuvertureStore = SoldeOuvertureState & SoldeOuvertureActions;

// ============================================================================
// UI COMPONENT PROPS
// ============================================================================

export interface SoldeOuvertureDetailsProps {
  solde: SoldeOuverture;
  isLoading?: boolean;
  className?: string;
}

export interface CalculationResultsProps {
  result: SoldeCalculationResult;
  isCalculating?: boolean;
  className?: string;
}

export interface CoherenceIndicatorProps {
  validation: CoherenceValidationResult;
  className?: string;
}

// ============================================================================
// ERROR TYPES
// ============================================================================

export const SoldeOuvertureErrorCode = {
  MISSING_CURRENCY_RATE: 'MISSING_CURRENCY_RATE',
  NEGATIVE_AMOUNT: 'NEGATIVE_AMOUNT',
  INVALID_SESSION: 'INVALID_SESSION',
  COHERENCE_MISMATCH: 'COHERENCE_MISMATCH',
  LOAD_FAILED: 'LOAD_FAILED',
  CALCULATION_FAILED: 'CALCULATION_FAILED',
} as const;

export type SoldeOuvertureErrorCodeType =
  (typeof SoldeOuvertureErrorCode)[keyof typeof SoldeOuvertureErrorCode];

export interface SoldeOuvertureError {
  code: SoldeOuvertureErrorCodeType;
  message: string;
  details?: unknown;
}

// ============================================================================
// VALIDATION
// ============================================================================

export const SOLDE_OUVERTURE_CONSTRAINTS = {
  MIN_AMOUNT: 0,
  MAX_AMOUNT: 999999999.99,
  DECIMAL_PLACES: 2,
  COHERENCE_TOLERANCE: 0.01,
} as const;

ACTIONS TO COVER:
[
  {
    "name": "calculerSoldeOuverture",
    "params": [
      "societe: string",
      "sessionId: number"
    ],
    "businessRules": [
      "Appeler updateDeviseSession pour mettre à jour les taux de change avant calcul",
      "Extraire tous les montants par devise de la session",
      "Convertir chaque montant devise vers EUR en utilisant les taux actualisés",
      "Valider que toutes les devises ont un taux de change valide",
      "Signaler une erreur si une devise manque de taux de change",
      "Valider que les montants ne sont pas négatifs",
      "Calculer le solde total en devise de référence (EUR)",
      "Retourner le détail par devise et le total consolidé"
    ],
    "returns": "Promise<{ totalEur: number; details: { devise: string; montant: number; tauxChange: number; montantEur: number }[] }>"
  },
  {
    "name": "updateDeviseSession",
    "params": [
      "sessionId: number"
    ],
    "businessRules": [
      "Appeler le service externe (ADH IDE 142) pour actualiser les taux de change",
      "Rafraîchir les taux de change en vigueur à la date d'ouverture",
      "Éviter les écarts de change dus à des taux obsolètes"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "loadSoldeOuverture",
    "params": [
      "societe: string",
      "sessionId: number"
    ],
    "businessRules": [
      "Charger les données de solde d'ouverture depuis histo_sessions_caisse_detail",
      "Charger les moyens de règlement disponibles",
      "Charger les devises de session depuis gestion_devise_session"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "validerCoherenceSolde",
    "params": [
      "soldeEnregistre: number",
      "soldeCalcule: number"
    ],
    "businessRules": [
      "Comparer le solde d'ouverture enregistré avec le solde calculé rétrospectivement",
      "Signaler un écart si une différence est détectée",
      "Un écart indique soit une modification frauduleuse soit une erreur de capture"
    ],
    "returns": "Promise<{ coherent: boolean; ecart: number | null }>"
  }
]