Generate Vitest unit tests for the "programDispatchStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  ProgramDispatchRoute,
  LastClickedResponse,
} from '@/types/programDispatch';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface ProgramDispatchState {
  lastClickedControl: string | null;
  isDispatching: boolean;
  error: string | null;
}

interface ProgramDispatchActions {
  dispatchToProgram: (controlId: string) => Promise<void>;
  getLastClickedControl: () => Promise<string | null>;
  clearDispatch: () => void;
  reset: () => void;
}

type ProgramDispatchStore = ProgramDispatchState & ProgramDispatchActions;

const MOCK_ROUTES: Record<string, string> = {
  BTN_CHANGE: 'ADH-25',
  BTN_DEPOT: 'ADH-40',
  BTN_GARANTIE: 'ADH-111',
  BTN_GRATUITES: 'ADH-168',
  BTN_VERSEMENT: 'ADH-174',
  BTN_TELEPHONE: 'ADH-217',
  BTN_MENU_COMPTE: 'ADH-37',
  BTN_EXTRAIT: 'ADH-69',
  BTN_CMP: 'ADH-77',
  BTN_BAR_LIMIT: 'ADH-86',
  BTN_GM_MENU: 'ADH-158',
  BTN_CAISSE_GM: 'ADH-163',
  BTN_FORFAIT_TAI: 'ADH-173',
  BTN_SOLDE: 'ADH-190',
  BTN_IMPRESSION: 'ADH-214',
  BTN_VENTE: 'ADH-242',
};

let MOCK_LAST_CLICKED: string | null = null;

const initialState: ProgramDispatchState = {
  lastClickedControl: null,
  isDispatching: false,
  error: null,
};

export const useProgramDispatchStore = create<ProgramDispatchStore>()((set) => ({
  ...initialState,

  dispatchToProgram: async (controlId) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isDispatching: true, error: null, lastClickedControl: controlId });

    if (!isRealApi) {
      MOCK_LAST_CLICKED = controlId;
      const targetProgram = MOCK_ROUTES[controlId];
      if (targetProgram) {
        set({ isDispatching: false });
      } else {
        set({
          error: `Programme cible non trouvé pour le contrôle ${controlId}`,
          isDispatching: false,
        });
      }
      return;
    }

    try {
      const response = await apiClient.post<ApiResponse<ProgramDispatchRoute>>(
        '/api/programDispatch/route',
        null,
        { params: { controlId } },
      );

      if (!response.data.success || !response.data.data?.success) {
        throw new Error(
          response.data.data?.error ?? 'Erreur lors du routage',
        );
      }

      set({ isDispatching: false });
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur dispatch programme';
      set({ error: message, isDispatching: false });
    }
  },

  getLastClickedControl: async () => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      return MOCK_LAST_CLICKED;
    }

    try {
      const response = await apiClient.get<ApiResponse<LastClickedResponse>>(
        '/api/programDispatch/lastClicked',
      );

      if (!response.data.success) {
        throw new Error('Impossible de récupérer le dernier contrôle cliqué');
      }

      return response.data.data?.controlId ?? null;
    } catch (e: unknown) {
      const message =
        e instanceof Error
          ? e.message
          : 'Erreur récupération dernier contrôle';
      set({ error: message });
      return null;
    }
  },

  clearDispatch: () => {
    set({ lastClickedControl: null, error: null });
  },

  reset: () => set({ ...initialState }),
}));

TYPES:
export interface ProgramDispatchControl {
  controlId: string;
  targetProgram: string;
  programName: string;
}

export interface ProgramDispatchRoute {
  controlId: string;
  success: boolean;
  targetProgram?: string;
  error?: string;
}

export interface LastClickedResponse {
  controlId: string | null;
}

export interface ProgramDispatchState {
  lastClickedControl: string | null;
  isDispatching: boolean;
  error: string | null;
  dispatchToProgram: (controlId: string) => Promise<void>;
  getLastClickedControl: () => Promise<string | null>;
  clearDispatch: () => void;
}

export type ProgramDispatchAction =
  | { type: 'SET_LAST_CLICKED'; payload: string }
  | { type: 'SET_DISPATCHING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'CLEAR_DISPATCH' };

ACTIONS TO COVER:
[
  {
    "name": "dispatchToProgram",
    "params": [
      "controlId: string"
    ],
    "businessRules": [
      "Capture the last clicked control ID via LastClicked()",
      "Route to target program based on control key mapping",
      "Terminal program - no further downstream calls",
      "Single centralized dispatch logic for 21 callers"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "getLastClickedControl",
    "params": [],
    "businessRules": [
      "Retrieve the last clicked control identifier from UI context"
    ],
    "returns": "Promise<string | null>"
  },
  {
    "name": "clearDispatch",
    "params": [],
    "businessRules": [
      "Reset dispatch state after routing completes"
    ],
    "returns": "void"
  }
]