```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';

const mockNavigate = vi.fn();
const mockGetMatricule = vi.fn();
const mockSetMatricule = vi.fn();
const mockSetError = vi.fn();
const mockReset = vi.fn();

vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom');
  return {
    ...actual,
    useNavigate: () => mockNavigate,
  };
});

vi.mock('@/stores/authenticationStore', () => ({
  useAuthenticationStore: (selector: (state: unknown) => unknown) => {
    const state = {
      matricule: null,
      isLoading: false,
      error: null,
      getMatricule: mockGetMatricule,
      setMatricule: mockSetMatricule,
      setError: mockSetError,
      reset: mockReset,
    };
    return selector(state);
  },
}));

import { AuthenticationPage } from '@/pages/AuthenticationPage';

const renderWithRouter = (component: React.ReactElement) => {
  return render(<BrowserRouter>{component}</BrowserRouter>);
};

describe('AuthenticationPage', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders without crashing', () => {
    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByText('Authentification')).toBeInTheDocument();
    expect(screen.getByPlaceholderText('Saisir le login')).toBeInTheDocument();
  });

  it('displays form elements correctly', () => {
    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByLabelText('Login')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Retour' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Récupérer matricule' })).toBeInTheDocument();
  });

  it('handles login input change', () => {
    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login') as HTMLInputElement;
    
    fireEvent.change(input, { target: { value: 'test.user' } });
    expect(input.value).toBe('test.user');
  });

  it('disables submit button when login is empty', () => {
    renderWithRouter(<AuthenticationPage />);
    const submitButton = screen.getByRole('button', { name: 'Récupérer matricule' });
    expect(submitButton).toBeDisabled();
  });

  it('enables submit button when login is filled', () => {
    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login');
    const submitButton = screen.getByRole('button', { name: 'Récupérer matricule' });

    fireEvent.change(input, { target: { value: 'test.user' } });
    expect(submitButton).not.toBeDisabled();
  });

  it('calls getMatricule on form submit with valid login', async () => {
    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login');
    const submitButton = screen.getByRole('button', { name: 'Récupérer matricule' });

    fireEvent.change(input, { target: { value: 'test.user' } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(mockGetMatricule).toHaveBeenCalledWith('test.user');
    });
  });

  it('shows error when submitting empty login', async () => {
    renderWithRouter(<AuthenticationPage />);
    const form = screen.getByRole('button', { name: 'Récupérer matricule' }).closest('form');

    fireEvent.submit(form!);

    await waitFor(() => {
      expect(mockSetError).toHaveBeenCalledWith('Le login est requis');
    });
  });

  it('trims whitespace from login before submission', async () => {
    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login');
    const submitButton = screen.getByRole('button', { name: 'Récupérer matricule' });

    fireEvent.change(input, { target: { value: '  test.user  ' } });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(mockGetMatricule).toHaveBeenCalledWith('test.user');
    });
  });

  it('navigates back when Retour button is clicked', () => {
    renderWithRouter(<AuthenticationPage />);
    const backButton = screen.getByRole('button', { name: 'Retour' });

    fireEvent.click(backButton);
    expect(mockNavigate).toHaveBeenCalledWith('/caisse/menu');
  });

  it('calls reset on unmount', () => {
    const { unmount } = renderWithRouter(<AuthenticationPage />);
    unmount();
    expect(mockReset).toHaveBeenCalled();
  });
});

describe('AuthenticationPage - Loading State', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('displays loading state when isLoading is true', () => {
    vi.mocked(vi.importActual('@/stores/authenticationStore')).then((mod) => {
      vi.spyOn(mod as { useAuthenticationStore: (selector: (state: unknown) => unknown) => unknown }, 'useAuthenticationStore').mockImplementation((selector) => {
        const state = {
          matricule: null,
          isLoading: true,
          error: null,
          getMatricule: mockGetMatricule,
          setMatricule: mockSetMatricule,
          setError: mockSetError,
          reset: mockReset,
        };
        return selector(state);
      });
    });

    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByText('Récupération en cours...')).toBeInTheDocument();
  });

  it('disables inputs when loading', () => {
    vi.mocked(vi.importActual('@/stores/authenticationStore')).then((mod) => {
      vi.spyOn(mod as { useAuthenticationStore: (selector: (state: unknown) => unknown) => unknown }, 'useAuthenticationStore').mockImplementation((selector) => {
        const state = {
          matricule: null,
          isLoading: true,
          error: null,
          getMatricule: mockGetMatricule,
          setMatricule: mockSetMatricule,
          setError: mockSetError,
          reset: mockReset,
        };
        return selector(state);
      });
    });

    renderWithRouter(<AuthenticationPage />);
    const input = screen.getByPlaceholderText('Saisir le login');
    expect(input).toBeDisabled();
  });
});

describe('AuthenticationPage - Error State', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('displays error message when error exists', () => {
    vi.mocked(vi.importActual('@/stores/authenticationStore')).then((mod) => {
      vi.spyOn(mod as { useAuthenticationStore: (selector: (state: unknown) => unknown) => unknown }, 'useAuthenticationStore').mockImplementation((selector) => {
        const state = {
          matricule: null,
          isLoading: false,
          error: 'Utilisateur introuvable',
          getMatricule: mockGetMatricule,
          setMatricule: mockSetMatricule,
          setError: mockSetError,
          reset: mockReset,
        };
        return selector(state);
      });
    });

    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByText('Utilisateur introuvable')).toBeInTheDocument();
  });
});

describe('AuthenticationPage - Success State', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('displays matricule when retrieved successfully', () => {
    vi.mocked(vi.importActual('@/stores/authenticationStore')).then((mod) => {
      vi.spyOn(mod as { useAuthenticationStore: (selector: (state: unknown) => unknown) => unknown }, 'useAuthenticationStore').mockImplementation((selector) => {
        const state = {
          matricule: 'MAT12345',
          isLoading: false,
          error: null,
          getMatricule: mockGetMatricule,
          setMatricule: mockSetMatricule,
          setError: mockSetError,
          reset: mockReset,
        };
        return selector(state);
      });
    });

    renderWithRouter(<AuthenticationPage />);
    expect(screen.getByText('Matricule:')).toBeInTheDocument();
    expect(screen.getByText('MAT12345')).toBeInTheDocument();
  });
});
```