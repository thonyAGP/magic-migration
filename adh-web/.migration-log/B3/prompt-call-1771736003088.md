Generate Vitest unit tests for the "emailSearchStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  EmailAddress,
  SearchFilters,
  CreateEmailDto,
  UpdateEmailDto,
  GetEmailsResponse,
  CreateEmailResponse,
  UpdateEmailResponse,
  DeleteEmailResponse,
  SetPrincipalResponse,
} from '@/types/emailSearch';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface EmailSearchState {
  emails: EmailAddress[];
  selectedEmail: EmailAddress | null;
  isLoading: boolean;
  error: string | null;
  filters: SearchFilters;
}

interface EmailSearchActions {
  searchEmails: (filters: SearchFilters) => Promise<void>;
  createEmail: (data: CreateEmailDto) => Promise<void>;
  updateEmail: (id: number, data: UpdateEmailDto) => Promise<void>;
  deleteEmail: (id: number) => Promise<void>;
  setAsPrincipal: (id: number) => Promise<void>;
  selectEmail: (email: EmailAddress | null) => void;
  setFilters: (filters: SearchFilters) => void;
  clearFilters: () => void;
  resetState: () => void;
}

type EmailSearchStore = EmailSearchState & EmailSearchActions;

const MOCK_EMAILS: EmailAddress[] = [
  {
    id: 1,
    societe: 'SKI',
    compte: '100001',
    filiation: 0,
    email: 'jean.dupont@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-15T10:30:00'),
    updatedAt: new Date('2026-02-10T14:20:00'),
  },
  {
    id: 2,
    societe: 'SKI',
    compte: '100001',
    filiation: 0,
    email: 'contact@dupont-family.fr',
    isPrincipal: false,
    createdAt: new Date('2026-01-20T09:15:00'),
    updatedAt: null,
  },
  {
    id: 3,
    societe: 'SKI',
    compte: '100001',
    filiation: 0,
    email: 'j.dupont@work.com',
    isPrincipal: false,
    createdAt: new Date('2026-02-01T16:45:00'),
    updatedAt: null,
  },
  {
    id: 4,
    societe: 'SKI',
    compte: '100002',
    filiation: 0,
    email: 'sophie.martin@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-10T11:00:00'),
    updatedAt: new Date('2026-02-15T08:30:00'),
  },
  {
    id: 5,
    societe: 'SKI',
    compte: '100002',
    filiation: 0,
    email: 's.martin@company.fr',
    isPrincipal: false,
    createdAt: new Date('2026-01-18T14:20:00'),
    updatedAt: null,
  },
  {
    id: 6,
    societe: 'SKI',
    compte: '100002',
    filiation: 0,
    email: 'contact@martin-group.com',
    isPrincipal: false,
    createdAt: new Date('2026-02-05T10:10:00'),
    updatedAt: null,
  },
  {
    id: 7,
    societe: 'EXCHANGE',
    compte: '100003',
    filiation: 1,
    email: 'pierre.durand@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-12T09:45:00'),
    updatedAt: new Date('2026-02-12T15:00:00'),
  },
  {
    id: 8,
    societe: 'EXCHANGE',
    compte: '100003',
    filiation: 1,
    email: 'p.durand@perso.fr',
    isPrincipal: false,
    createdAt: new Date('2026-01-25T13:30:00'),
    updatedAt: null,
  },
  {
    id: 9,
    societe: 'EXCHANGE',
    compte: '100003',
    filiation: 1,
    email: 'contact@durand.net',
    isPrincipal: false,
    createdAt: new Date('2026-02-08T11:20:00'),
    updatedAt: null,
  },
  {
    id: 10,
    societe: 'EXCHANGE',
    compte: '100004',
    filiation: 0,
    email: 'marie.bernard@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-08T10:00:00'),
    updatedAt: null,
  },
  {
    id: 11,
    societe: 'EXCHANGE',
    compte: '100004',
    filiation: 0,
    email: 'm.bernard@work.com',
    isPrincipal: false,
    createdAt: new Date('2026-01-22T15:45:00'),
    updatedAt: null,
  },
  {
    id: 12,
    societe: 'EXCHANGE',
    compte: '100004',
    filiation: 0,
    email: 'contact@bernard-services.fr',
    isPrincipal: false,
    createdAt: new Date('2026-02-03T09:30:00'),
    updatedAt: null,
  },
  {
    id: 13,
    societe: 'SKI',
    compte: '100005',
    filiation: 0,
    email: 'luc.petit@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-05T14:15:00'),
    updatedAt: new Date('2026-02-18T10:45:00'),
  },
  {
    id: 14,
    societe: 'SKI',
    compte: '100005',
    filiation: 0,
    email: 'l.petit@company.fr',
    isPrincipal: false,
    createdAt: new Date('2026-01-28T11:30:00'),
    updatedAt: null,
  },
  {
    id: 15,
    societe: 'SKI',
    compte: '100005',
    filiation: 0,
    email: 'contact@petit-consulting.com',
    isPrincipal: false,
    createdAt: new Date('2026-02-11T16:00:00'),
    updatedAt: null,
  },
];

const initialState: EmailSearchState = {
  emails: [],
  selectedEmail: null,
  isLoading: false,
  error: null,
  filters: {
    societe: '',
    compte: '',
    filiation: null,
    email: '',
  },
};

export const useEmailSearchStore = create<EmailSearchStore>()((set, get) => ({
  ...initialState,

  searchEmails: async (filters: SearchFilters) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const filtered = MOCK_EMAILS.filter((email) => {
        if (filters.societe && email.societe !== filters.societe) return false;
        if (filters.compte && email.compte !== filters.compte) return false;
        if (filters.filiation !== null && email.filiation !== filters.filiation) return false;
        if (filters.email && !email.email.toLowerCase().includes(filters.email.toLowerCase())) return false;
        return true;
      });
      set({ emails: filtered, isLoading: false });
      return;
    }

    try {
      const params: Record<string, string> = {};
      if (filters.societe) params.societe = filters.societe;
      if (filters.compte) params.compte = filters.compte;
      if (filters.filiation !== null) params.filiation = String(filters.filiation);
      if (filters.email) params.email = filters.email;

      const response = await apiClient.get<ApiResponse<GetEmailsResponse>>('/api/email-search/emails', { params });
      set({ emails: response.data.data?.data ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur recherche emails';
      set({ emails: [], error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  createEmail: async (data: CreateEmailDto) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const newEmail: EmailAddress = {
        id: Math.max(...MOCK_EMAILS.map((e) => e.id), 0) + 1,
        societe: data.societe,
        compte: data.compte,
        filiation: data.filiation,
        email: data.email,
        isPrincipal: data.isPrincipal ?? false,
        createdAt: new Date(),
        updatedAt: null,
      };

      if (data.isPrincipal) {
        MOCK_EMAILS.forEach((email) => {
          if (
            email.societe === data.societe &&
            email.compte === data.compte &&
            email.filiation === data.filiation
          ) {
            email.isPrincipal = false;
          }
        });
      }

      MOCK_EMAILS.push(newEmail);
      const { filters } = get();
      await get().searchEmails(filters);
      set({ isLoading: false });
      return;
    }

    try {
      const response = await apiClient.post<ApiResponse<CreateEmailResponse>>('/api/email-search/emails', data);
      const created = response.data.data?.data;
      if (created) {
        const currentEmails = get().emails;
        set({ emails: [...currentEmails, created] });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur création email';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  updateEmail: async (id: number, data: UpdateEmailDto) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const emailIndex = MOCK_EMAILS.findIndex((e) => e.id === id);
      if (emailIndex === -1) {
        set({ error: 'Email introuvable', isLoading: false });
        return;
      }

      const email = MOCK_EMAILS[emailIndex];
      if (data.email !== undefined) email.email = data.email;
      if (data.isPrincipal !== undefined && data.isPrincipal) {
        MOCK_EMAILS.forEach((e) => {
          if (
            e.societe === email.societe &&
            e.compte === email.compte &&
            e.filiation === email.filiation &&
            e.id !== id
          ) {
            e.isPrincipal = false;
          }
        });
        email.isPrincipal = true;
      }
      email.updatedAt = new Date();

      const { filters } = get();
      await get().searchEmails(filters);
      set({ isLoading: false });
      return;
    }

    try {
      const response = await apiClient.put<ApiResponse<UpdateEmailResponse>>(`/api/email-search/emails/${id}`, data);
      const updated = response.data.data?.data;
      if (updated) {
        const currentEmails = get().emails;
        set({ emails: currentEmails.map((e) => (e.id === id ? updated : e)) });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur modification email';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  deleteEmail: async (id: number) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const index = MOCK_EMAILS.findIndex((e) => e.id === id);
      if (index === -1) {
        set({ error: 'Email introuvable', isLoading: false });
        return;
      }
      MOCK_EMAILS.splice(index, 1);
      const { filters } = get();
      await get().searchEmails(filters);
      set({ isLoading: false });
      return;
    }

    try {
      await apiClient.delete<ApiResponse<DeleteEmailResponse>>(`/api/email-search/emails/${id}`);
      const currentEmails = get().emails;
      set({ emails: currentEmails.filter((e) => e.id !== id) });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur suppression email';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  setAsPrincipal: async (id: number) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const email = MOCK_EMAILS.find((e) => e.id === id);
      if (!email) {
        set({ error: 'Email introuvable', isLoading: false });
        return;
      }

      MOCK_EMAILS.forEach((e) => {
        if (
          e.societe === email.societe &&
          e.compte === email.compte &&
          e.filiation === email.filiation
        ) {
          e.isPrincipal = e.id === id;
        }
      });

      const { filters } = get();
      await get().searchEmails(filters);
      set({ isLoading: false });
      return;
    }

    try {
      await apiClient.post<ApiResponse<SetPrincipalResponse>>(`/api/email-search/emails/${id}/set-principal`);
      const currentEmails = get().emails;
      const email = currentEmails.find((e) => e.id === id);
      if (email) {
        set({
          emails: currentEmails.map((e) =>
            e.societe === email.societe &&
            e.compte === email.compte &&
            e.filiation === email.filiation
              ? { ...e, isPrincipal: e.id === id }
              : e,
          ),
        });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur définition email principal';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  selectEmail: (email: EmailAddress | null) => {
    set({ selectedEmail: email });
  },

  setFilters: (filters: SearchFilters) => {
    set({ filters });
  },

  clearFilters: () => {
    set({
      filters: {
        societe: '',
        compte: '',
        filiation: null,
        email: '',
      },
    });
  },

  resetState: () => set({ ...initialState }),
}));

TYPES:
import type { GmIdentifier } from "@/types";

export interface EmailAddress {
  id: number;
  societe: string;
  compte: string;
  filiation: number;
  email: string;
  isPrincipal: boolean;
  createdAt: Date | null;
  updatedAt: Date | null;
}

export interface GmRecord {
  societe: string;
  compte: string;
  filiation: number;
  nom: string | null;
  prenom: string | null;
}

export interface SearchFilters {
  societe: string;
  compte: string;
  filiation: number | null;
  email: string;
}

export interface CreateEmailDto {
  societe: string;
  compte: string;
  filiation: number;
  email: string;
  isPrincipal?: boolean;
}

export interface UpdateEmailDto {
  email?: string;
  isPrincipal?: boolean;
}

export interface EmailSearchState {
  emails: EmailAddress[];
  selectedEmail: EmailAddress | null;
  isLoading: boolean;
  error: string | null;
  filters: SearchFilters;
  searchEmails: (filters: SearchFilters) => Promise<void>;
  createEmail: (data: CreateEmailDto) => Promise<void>;
  updateEmail: (id: number, data: UpdateEmailDto) => Promise<void>;
  deleteEmail: (id: number) => Promise<void>;
  setAsPrincipal: (id: number) => Promise<void>;
  selectEmail: (email: EmailAddress | null) => void;
  setFilters: (filters: SearchFilters) => void;
  clearFilters: () => void;
  resetState: () => void;
}

export interface GetEmailsRequest {
  societe?: string;
  compte?: string;
  filiation?: number;
  email?: string;
}

export interface GetEmailsResponse {
  data: EmailAddress[];
  count: number;
}

export interface CreateEmailRequest {
  societe: string;
  compte: string;
  filiation: number;
  email: string;
  isPrincipal?: boolean;
}

export interface CreateEmailResponse {
  data: EmailAddress;
}

export interface UpdateEmailRequest {
  email?: string;
  isPrincipal?: boolean;
}

export interface UpdateEmailResponse {
  data: EmailAddress;
}

export interface DeleteEmailResponse {
  success: boolean;
}

export interface SetPrincipalResponse {
  success: boolean;
}

export const EMPTY_SEARCH_FILTERS = {
  societe: '',
  compte: '',
  filiation: null,
  email: '',
} as const;

export const EMAIL_VALIDATION_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

export const ACTION_TYPES = {
  SEARCH_EMAILS: 'emailSearch/searchEmails',
  CREATE_EMAIL: 'emailSearch/createEmail',
  UPDATE_EMAIL: 'emailSearch/updateEmail',
  DELETE_EMAIL: 'emailSearch/deleteEmail',
  SET_PRINCIPAL: 'emailSearch/setAsPrincipal',
  SELECT_EMAIL: 'emailSearch/selectEmail',
  SET_FILTERS: 'emailSearch/setFilters',
  CLEAR_FILTERS: 'emailSearch/clearFilters',
  RESET_STATE: 'emailSearch/resetState',
} as const;

ACTIONS TO COVER:
[
  {
    "name": "searchEmails",
    "params": [
      "filters: SearchFilters"
    ],
    "businessRules": [
      "RM-001: Execute search with validated entry conditions",
      "RM-002: Access email table in READ mode with optional LINK to gm-recherche and fichier_langue",
      "Multi-criteria search: societe, compte, filiation, email pattern"
    ],
    "returns": "Promise<EmailAddress[]>"
  },
  {
    "name": "createEmail",
    "params": [
      "data: CreateEmailDto"
    ],
    "businessRules": [
      "RM-002: Access email table in WRITE mode",
      "RM-002: Write to gm-recherche table (cafil008_dat)",
      "Validate email format before creation",
      "Set createdAt timestamp to current date/time"
    ],
    "returns": "Promise<EmailAddress>"
  },
  {
    "name": "updateEmail",
    "params": [
      "id: number",
      "data: UpdateEmailDto"
    ],
    "businessRules": [
      "RM-002: Access email table in WRITE mode",
      "Validate email exists before update",
      "Update updatedAt timestamp",
      "Validate email format if email field is being updated"
    ],
    "returns": "Promise<EmailAddress>"
  },
  {
    "name": "deleteEmail",
    "params": [
      "id: number"
    ],
    "businessRules": [
      "RM-002: Access email table in WRITE mode",
      "RM-004: Handle error propagation if deletion fails",
      "Validate email exists before deletion"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "setAsPrincipal",
    "params": [
      "id: number"
    ],
    "businessRules": [
      "RM-002: Write to email table",
      "Only one email can be principal per GM (societe+compte+filiation)",
      "Unset previous principal email if exists"
    ],
    "returns": "Promise<void>"
  }
]