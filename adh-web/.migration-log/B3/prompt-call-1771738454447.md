Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/moyenPaiementStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
moyenPaiementStore getMOPInfo should handle API error when getting MOP info: AssertionError: expected null to be 'Erreur récupération info MOP' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/moyenPaiementStore.test.ts:128:27
    at processTicksAnd
moyenPaiementStore getMOPInfo should handle network error when getting MOP info: AssertionError: expected null to be 'Network error' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/moyenPaiementStore.test.ts:143:27
    at processTicksAndRejections (nod
moyenPaiementStore getMOPInfo should set loading state during API call: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/moyenPaiementStore.test.ts:165:31
    at file:///D:/Projects/Lecteur_Magic/adh-we
moyenPaiementStore checkMOPExists should handle API error when checking MOP exists: AssertionError: expected null to be 'Erreur vérification existence MOP' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/moyenPaiementStore.test.ts:221:27
    at processTic
moyenPaiementStore checkMOPExists should handle network error when checking MOP exists: AssertionError: expected null to be 'Connection failed' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/moyenPaiementStore.test.ts:236:27
    at processTicksAndRejections 
moyenPaiementStore getMOPByCode should handle API error when getting MOP by code: AssertionError: expected null to be 'Erreur récupération MOP' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/moyenPaiementStore.test.ts:288:27
    at processTicksAndRejec
moyenPaiementStore getMOPByCode should handle network error when getting MOP by code: AssertionError: expected null to be 'Timeout' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/moyenPaiementStore.test.ts:301:27
    at processTicksAndRejections (node:inte

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useMoyenPaiementStore } from '@/stores/moyenPaiementStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type { MoyenPaiement, MOPInfo } from '@/types/moyenPaiement';

const MOCK_MOP_CB: MoyenPaiement = {
  code: 'CB',
  libelle: 'Carte Bancaire',
  classe: 'UNI',
  typeDevise: 'UNI',
};

const MOCK_MOP_CHG: MoyenPaiement = {
  code: 'CHG',
  libelle: 'Change',
  classe: 'BI',
  typeDevise: 'BI',
};

const MOCK_MOP_INFO_CB: MOPInfo = {
  classe: 'UNI',
  libelle: 'Carte Bancaire',
  existe: true,
};

const MOCK_MOP_INFO_NOT_FOUND: MOPInfo = {
  classe: 'UNI',
  libelle: '',
  existe: false,
};

global.fetch = vi.fn();

describe('moyenPaiementStore', () => {
  beforeEach(() => {
    useMoyenPaiementStore.getState().reset();
    vi.clearAllMocks();
    useDataSourceStore.setState({ isRealApi: false });
  });

  describe('getMOPInfo', () => {
    it('should get MOP info for UNI typeDevise in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPInfo('CB', 'UNI');

      expect(result).toEqual({
        classe: 'UNI',
        libelle: 'Carte Bancaire',
        existe: true,
      });
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should get MOP info for BI typeDevise in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPInfo('CHG', 'BI');

      expect(result).toEqual({
        classe: 'BI',
        libelle: 'Change',
        existe: true,
      });
      expect(store.isLoading).toBe(false);
    });

    it('should return non-existent MOP info in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPInfo('XXX', 'UNI');

      expect(result).toEqual({
        classe: 'UNI',
        libelle: '',
        existe: false,
      });
      expect(store.isLoading).toBe(false);
    });

    it('should get MOP info from API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: MOCK_MOP_INFO_CB }),
      });

      const result = await store.getMOPInfo('CB', 'UNI');

      expect(result).toEqual(MOCK_MOP_INFO_CB);
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/moyenpaiement/info?code=CB&typeDevise=UNI',
      );
      expect(store.isLoading).toBe(false);
    });

    it('should get MOP info without typeDevise in API mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: MOCK_MOP_INFO_CB }),
      });

      await store.getMOPInfo('CB', 'UNI');

      expect(global.fetch).toHaveBeenCalledWith(
        '/api/moyenpaiement/info?code=CB&typeDevise=UNI',
      );
    });

    it('should handle API error when getting MOP info', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: false,
      });

      await expect(store.getMOPInfo('CB', 'UNI')).rejects.toThrow(
        'Erreur récupération info MOP',
      );
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe('Erreur récupération info MOP');
    });

    it('should handle network error when getting MOP info', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
        new Error('Network error'),
      );

      await expect(store.getMOPInfo('CB', 'UNI')).rejects.toThrow(
        'Network error',
      );
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe('Network error');
    });

    it('should set loading state during API call', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockImplementationOnce(
        () =>
          new Promise((resolve) =>
            setTimeout(
              () =>
                resolve({
                  ok: true,
                  json: async () => ({ data: MOCK_MOP_INFO_CB }),
                }),
              10,
            ),
          ),
      );

      const promise = store.getMOPInfo('CB', 'UNI');
      expect(store.isLoading).toBe(true);
      await promise;
      expect(store.isLoading).toBe(false);
    });
  });

  describe('checkMOPExists', () => {
    it('should check MOP exists in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.checkMOPExists('CB', 'PHU');

      expect(result).toBe(true);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should return false for non-existent MOP in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.checkMOPExists('XXX', 'PHU');

      expect(result).toBe(false);
      expect(store.isLoading).toBe(false);
    });

    it('should check MOP exists from API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: { existe: true } }),
      });

      const result = await store.checkMOPExists('CB', 'PHU');

      expect(result).toBe(true);
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/moyenpaiement/exists?code=CB&societe=PHU',
      );
      expect(store.isLoading).toBe(false);
    });

    it('should handle API error when checking MOP exists', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: false,
      });

      await expect(store.checkMOPExists('CB', 'PHU')).rejects.toThrow(
        'Erreur vérification existence MOP',
      );
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe('Erreur vérification existence MOP');
    });

    it('should handle network error when checking MOP exists', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
        new Error('Connection failed'),
      );

      await expect(store.checkMOPExists('CB', 'PHU')).rejects.toThrow(
        'Connection failed',
      );
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe('Connection failed');
    });
  });

  describe('getMOPByCode', () => {
    it('should get MOP by code in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPByCode('CB');

      expect(result).toEqual(MOCK_MOP_CB);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should return null for non-existent MOP in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPByCode('XXX');

      expect(result).toBeNull();
      expect(store.isLoading).toBe(false);
    });

    it('should get MOP by code from API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: MOCK_MOP_CB }),
      });

      const result = await store.getMOPByCode('CB');

      expect(result).toEqual(MOCK_MOP_CB);
      expect(global.fetch).toHaveBeenCalledWith('/api/moyenpaiement/CB');
      expect(store.isLoading).toBe(false);
    });

    it('should handle API error when getting MOP by code', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: false,
      });

      await expect(store.getMOPByCode('CB')).rejects.toThrow(
        'Erreur récupération MOP',
      );
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe('Erreur récupération MOP');
    });

    it('should handle network error when getting MOP by code', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
        new Error('Timeout'),
      );

      await expect(store.getMOPByCode('CB')).rejects.toThrow('Timeout');
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe('Timeout');
    });
  });

  describe('setMoyensPaiement', () => {
    it('should set moyens paiement', () => {
      const store = useMoyenPaiementStore.getState();
      const moyens: MoyenPaiement[] = [MOCK_MOP_CB, MOCK_MOP_CHG];

      store.setMoyensPaiement(moyens);

      expect(useMoyenPaiementStore.getState().moyensPaiement).toEqual(moyens);
    });
  });

  describe('setSelectedMOP', () => {
    it('should set selected MOP', () => {
      const store = useMoyenPaiementStore.getState();

      store.setSelectedMOP(MOCK_MOP_CB);

      expect(useMoyenPaiementStore.getState().selectedMOP).toEqual(
        MOCK_MOP_CB,
      );
    });

    it('should clear selected MOP', () => {
      const store = useMoyenPaiementStore.getState();
      store.setSelectedMOP(MOCK_MOP_CB);

      store.setSelectedMOP(null);

      expect(useMoyenPaiementStore.getState().selectedMOP).toBeNull();
    });
  });

  describe('setIsLoading', () => {
    it('should set loading state', () => {
      const store = useMoyenPaiementStore.getState();

      store.setIsLoading(true);
      expect(useMoyenPaiementStore.getState().isLoading).toBe(true);

      store.setIsLoading(false);
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
    });
  });

  describe('setError', () => {
    it('should set error', () => {
      const store = useMoyenPaiementStore.getState();

      store.setError('Test error');
      expect(useMoyenPaiementStore.getState().error).toBe('Test error');

      store.setError(null);
      expect(useMoyenPaiementStore.getState().error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', () => {
      const store = useMoyenPaiementStore.getState();
      store.setMoyensPaiement([MOCK_MOP_CB]);
      store.setSelectedMOP(MOCK_MOP_CB);
      store.setIsLoading(true);
      store.setError('Test error');

      store.reset();

      const state = useMoyenPaiementStore.getState();
      expect(state.moyensPaiement).toEqual([]);
      expect(state.selectedMOP).toBeNull();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  MoyenPaiement,
  MOPInfo,
  TypeDevise,
  ClasseMOP,
} from '@/types/moyenPaiement';
import { useDataSourceStore } from './dataSourceStore';

interface MoyenPaiementState {
  moyensPaiement: MoyenPaiement[];
  selectedMOP: MoyenPaiement | null;
  isLoading: boolean;
  error: string | null;
}

interface MoyenPaiementActions {
  getMOPInfo: (
    codeMOP: string,
    typeDevise: TypeDevise,
  ) => Promise<{ classe: ClasseMOP; libelle: string; existe: boolean }>;
  checkMOPExists: (codeMOP: string, societe: string) => Promise<boolean>;
  getMOPByCode: (codeMOP: string) => Promise<MoyenPaiement | null>;
  setMoyensPaiement: (moyens: MoyenPaiement[]) => void;
  setSelectedMOP: (mop: MoyenPaiement | null) => void;
  setIsLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

type MoyenPaiementStore = MoyenPaiementState & MoyenPaiementActions;

const MOCK_MOYENS_PAIEMENT: MoyenPaiement[] = [
  {
    code: 'CB',
    libelle: 'Carte Bancaire',
    classe: 'UNI',
    typeDevise: 'UNI',
  },
  {
    code: 'ESP',
    libelle: 'Espèces',
    classe: 'UNI',
    typeDevise: 'UNI',
  },
  {
    code: 'CHQ',
    libelle: 'Chèque',
    classe: 'CHQ',
    typeDevise: 'UNI',
  },
  {
    code: 'VIR',
    libelle: 'Virement',
    classe: 'TRANSF',
    typeDevise: 'UNI',
  },
  {
    code: 'CHG',
    libelle: 'Change',
    classe: 'BI',
    typeDevise: 'BI',
  },
  {
    code: 'CBE',
    libelle: 'CB Étranger',
    classe: 'BI',
    typeDevise: 'BI',
  },
  {
    code: 'TRV',
    libelle: 'Chèques Voyage',
    classe: 'BI',
    typeDevise: 'BI',
  },
  {
    code: 'VAC',
    libelle: 'Chèques Vacances',
    classe: 'UNI',
    typeDevise: 'UNI',
  },
  {
    code: 'PRE',
    libelle: 'Prélèvement',
    classe: 'TRANSF',
    typeDevise: 'UNI',
  },
  {
    code: 'AVO',
    libelle: 'Avoir',
    classe: 'UNI',
    typeDevise: 'UNI',
  },
];

const initialState: MoyenPaiementState = {
  moyensPaiement: [],
  selectedMOP: null,
  isLoading: false,
  error: null,
};

export const useMoyenPaiementStore = create<MoyenPaiementStore>()((set) => ({
  ...initialState,

  getMOPInfo: async (codeMOP, typeDevise) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const mop = MOCK_MOYENS_PAIEMENT.find((m) => m.code === codeMOP);
      const result: MOPInfo = mop
        ? {
            classe: mop.classe,
            libelle: mop.libelle,
            existe: true,
          }
        : {
            classe: 'UNI',
            libelle: '',
            existe: false,
          };
      set({ isLoading: false });
      return result;
    }

    try {
      const params = new URLSearchParams({ code: codeMOP });
      if (typeDevise) {
        params.append('typeDevise', typeDevise);
      }

      const response = await fetch(
        `/api/moyenpaiement/info?${params.toString()}`,
      );
      if (!response.ok) {
        throw new Error('Erreur récupération info MOP');
      }

      const data = (await response.json()) as {
        data: MOPInfo;
      };
      set({ isLoading: false });
      return data.data;
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur récupération info MOP';
      set({ isLoading: false, error: message });
      throw new Error(message);
    }
  },

  checkMOPExists: async (codeMOP, societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const exists = MOCK_MOYENS_PAIEMENT.some((m) => m.code === codeMOP);
      set({ isLoading: false });
      return exists;
    }

    try {
      const params = new URLSearchParams({ code: codeMOP, societe });
      const response = await fetch(
        `/api/moyenpaiement/exists?${params.toString()}`,
      );
      if (!response.ok) {
        throw new Error('Erreur vérification existence MOP');
      }

      const data = (await response.json()) as {
        data: { existe: boolean };
      };
      set({ isLoading: false });
      return data.data.existe;
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur vérification existence MOP';
      set({ isLoading: false, error: message });
      throw new Error(message);
    }
  },

  getMOPByCode: async (codeMOP) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const mop = MOCK_MOYENS_PAIEMENT.find((m) => m.code === codeMOP) ?? null;
      set({ isLoading: false });
      return mop;
    }

    try {
      const response = await fetch(`/api/moyenpaiement/${codeMOP}`);
      if (!response.ok) {
        throw new Error('Erreur récupération MOP');
      }

      const data = (await response.json()) as {
        data: MoyenPaiement | null;
      };
      set({ isLoading: false });
      return data.data;
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur récupération MOP';
      set({ isLoading: false, error: message });
      throw new Error(message);
    }
  },

  setMoyensPaiement: (moyens) => set({ moyensPaiement: moyens }),
  setSelectedMOP: (mop) => set({ selectedMOP: mop }),
  setIsLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error }),
  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.