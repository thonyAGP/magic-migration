Generate Vitest unit tests for the "raisonsUtilisationStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  RaisonUtilisation,
  RaisonsUtilisationState,
  GetRaisonsUtilisationResponse,
  ValiderSelectionResponse,
} from '@/types/raisonsUtilisation';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { RAISON_UTILISATION_MOCK } from '@/types/raisonsUtilisation';

type RaisonsUtilisationStore = RaisonsUtilisationState;

const initialState: Omit<
  RaisonsUtilisationState,
  | 'loadRaisonsUtilisation'
  | 'selectRaisonPrimaire'
  | 'selectRaisonSecondaire'
  | 'validerSelection'
  | 'abandonner'
  | 'updateCommentaire'
  | 'reset'
> = {
  raisons: [],
  selectedRaisonPrimaire: null,
  selectedRaisonSecondaire: null,
  commentaireSaisi: '',
  confirmation: false,
  retourRaison: false,
  isLoading: false,
  error: null,
};

export const useRaisonsUtilisationStore = create<RaisonsUtilisationStore>()(
  (set, get) => ({
    ...initialState,

    loadRaisonsUtilisation: async (serviceCode) => {
      const { isRealApi } = useDataSourceStore.getState();
      set({ isLoading: true, error: null });

      if (!isRealApi) {
        let filtered = [...RAISON_UTILISATION_MOCK];
        if (serviceCode !== undefined) {
          filtered = filtered.filter((r) => r.idPrimaire === serviceCode);
        }
        const sorted = filtered.sort((a, b) => a.idPrimaire - b.idPrimaire);
        set({ raisons: sorted, isLoading: false });
        return;
      }

      try {
        const params = serviceCode !== undefined ? { serviceCode } : undefined;
        const response = await apiClient.get<GetRaisonsUtilisationResponse>(
          '/api/raisons-utilisation',
          { params },
        );
        const raisons = response.data.data ?? [];
        const sorted = raisons.sort((a, b) => a.idPrimaire - b.idPrimaire);
        set({ raisons: sorted });
      } catch (e: unknown) {
        const message =
          e instanceof Error
            ? e.message
            : 'Erreur chargement raisons utilisation';
        set({ raisons: [], error: message });
      } finally {
        set({ isLoading: false });
      }
    },

    selectRaisonPrimaire: async (idPrimaire) => {
      const { raisons } = get();
      const raison = raisons.find((r) => r.idPrimaire === idPrimaire);

      if (!raison) {
        set({ error: 'Raison primaire introuvable' });
        return;
      }

      const hasSecondary = raison.existeRaisonSecondaire;

      set({
        selectedRaisonPrimaire: idPrimaire,
        selectedRaisonSecondaire: hasSecondary ? null : raison.idSecondaire,
        error: null,
      });
    },

    selectRaisonSecondaire: async (idSecondaire) => {
      const { raisons, selectedRaisonPrimaire } = get();

      if (selectedRaisonPrimaire === null) {
        set({ error: 'Aucune raison primaire sélectionnée' });
        return;
      }

      const primaryRaison = raisons.find(
        (r) => r.idPrimaire === selectedRaisonPrimaire,
      );

      if (!primaryRaison || !primaryRaison.existeRaisonSecondaire) {
        set({ error: 'Cette raison primaire ne possède pas de raisons secondaires' });
        return;
      }

      set({ selectedRaisonSecondaire: idSecondaire, error: null });
    },

    validerSelection: async () => {
      const {
        commentaireSaisi,
        selectedRaisonPrimaire,
        selectedRaisonSecondaire,
        confirmation,
      } = get();

      const trimmedComment = commentaireSaisi.trim();

      if (trimmedComment === '' || !confirmation) {
        set({
          error:
            'Commentaire requis et confirmation nécessaire avant validation',
        });
        return;
      }

      if (selectedRaisonPrimaire === null || selectedRaisonPrimaire === 0) {
        set({ error: 'Aucune raison primaire sélectionnée' });
        return;
      }

      const { isRealApi } = useDataSourceStore.getState();

      if (!isRealApi) {
        set({
          confirmation: true,
          retourRaison: true,
          error: null,
        });
        return;
      }

      try {
        const response = await apiClient.post<ValiderSelectionResponse>(
          '/api/raisons-utilisation/valider',
          {
            commentaire: trimmedComment,
            selectedRaisonPrimaire,
            selectedRaisonSecondaire,
          },
        );

        if (response.data.success) {
          set({ confirmation: true, retourRaison: true, error: null });
        } else {
          set({ error: response.data.message ?? 'Erreur validation' });
        }
      } catch (e: unknown) {
        const message =
          e instanceof Error ? e.message : 'Erreur validation sélection';
        set({ error: message });
      }
    },

    abandonner: async () => {
      set({
        confirmation: false,
        retourRaison: false,
        selectedRaisonPrimaire: null,
        selectedRaisonSecondaire: null,
        commentaireSaisi: '',
        error: null,
      });
    },

    updateCommentaire: (commentaire) => {
      set({ commentaireSaisi: commentaire.trim(), error: null });
    },

    reset: () => set({ ...initialState }),
  }),
);

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export interface RaisonUtilisation {
  idPrimaire: number;
  idSecondaire: number | null;
  commentaire: string;
  existeRaisonSecondaire: boolean;
}

export interface RaisonsUtilisationState {
  raisons: RaisonUtilisation[];
  selectedRaisonPrimaire: number | null;
  selectedRaisonSecondaire: number | null;
  commentaireSaisi: string;
  confirmation: boolean;
  retourRaison: boolean;
  isLoading: boolean;
  error: string | null;

  loadRaisonsUtilisation: (serviceCode?: number) => Promise<void>;
  selectRaisonPrimaire: (idPrimaire: number) => Promise<void>;
  selectRaisonSecondaire: (idSecondaire: number) => Promise<void>;
  validerSelection: () => Promise<void>;
  abandonner: () => Promise<void>;
  updateCommentaire: (commentaire: string) => void;
  reset: () => void;
}

export interface GetRaisonsUtilisationRequest {
  serviceCode?: number;
}

export interface GetRaisonsUtilisationResponse extends ApiResponse {
  data: RaisonUtilisation[];
}

export interface SelectRaisonPrimaireRequest {
  idPrimaire: number;
}

export interface SelectRaisonSecondaireRequest {
  idSecondaire: number;
}

export interface ValiderSelectionRequest {
  commentaire: string;
  selectedRaisonPrimaire: number;
  selectedRaisonSecondaire: number | null;
}

export interface ValiderSelectionResponse extends ApiResponse {
  data: {
    idPrimaire: number;
    idSecondaire: number | null;
    commentaire: string;
  };
}

export const RAISON_UTILISATION_MOCK = [
  {
    idPrimaire: 1,
    idSecondaire: null,
    commentaire: "Paiement service bar",
    existeRaisonSecondaire: false,
  },
  {
    idPrimaire: 2,
    idSecondaire: null,
    commentaire: "Paiement restaurant",
    existeRaisonSecondaire: false,
  },
  {
    idPrimaire: 3,
    idSecondaire: null,
    commentaire: "Paiement boutique",
    existeRaisonSecondaire: false,
  },
  {
    idPrimaire: 4,
    idSecondaire: null,
    commentaire: "Caution",
    existeRaisonSecondaire: false,
  },
  {
    idPrimaire: 5,
    idSecondaire: null,
    commentaire: "Dépôt espèces",
    existeRaisonSecondaire: false,
  },
  {
    idPrimaire: 6,
    idSecondaire: 61,
    commentaire: "Retrait espèces",
    existeRaisonSecondaire: true,
  },
  {
    idPrimaire: 7,
    idSecondaire: null,
    commentaire: "Frais divers",
    existeRaisonSecondaire: false,
  },
  {
    idPrimaire: 8,
    idSecondaire: null,
    commentaire: "Remboursement",
    existeRaisonSecondaire: false,
  },
  {
    idPrimaire: 9,
    idSecondaire: null,
    commentaire: "Ajustement compte",
    existeRaisonSecondaire: false,
  },
  {
    idPrimaire: 10,
    idSecondaire: null,
    commentaire: "Autre motif",
    existeRaisonSecondaire: false,
  },
] as const satisfies readonly RaisonUtilisation[];

ACTIONS TO COVER:
[
  {
    "name": "loadRaisonsUtilisation",
    "params": [
      "serviceCode?: number"
    ],
    "businessRules": [
      "RM-001: Apply conditional logic for raison selection based on context",
      "Fetch raisons from cafil069_dat table",
      "Sort by idPrimaire ascending",
      "Filter by service if serviceCode provided"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "selectRaisonPrimaire",
    "params": [
      "idPrimaire: number"
    ],
    "businessRules": [
      "RM-003: Check if idPrimaire equals 6 for special handling",
      "Set selectedRaisonPrimaire state",
      "Reset selectedRaisonSecondaire if no secondary raisons exist",
      "Update existeRaisonSecondaire flag"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "selectRaisonSecondaire",
    "params": [
      "idSecondaire: number"
    ],
    "businessRules": [
      "Set selectedRaisonSecondaire state",
      "Validate that idSecondaire belongs to current primary raison"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "validerSelection",
    "params": [],
    "businessRules": [
      "RM-002: Validate commentaireSaisi is not empty AND confirmation AND last action is not 'Bt.Abandonner'",
      "RM-004: Check that confirmation AND selectedRaisonPrimaire is not 0",
      "Set confirmation to true",
      "Set retourRaison to true if validation passes",
      "Return selected raison data to caller (Easy Check-Out)"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "abandonner",
    "params": [],
    "businessRules": [
      "Set confirmation to false",
      "Set retourRaison to false",
      "Clear all selections",
      "Close dialog/modal"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "updateCommentaire",
    "params": [
      "commentaire: string"
    ],
    "businessRules": [
      "Update commentaireSaisi state",
      "Trim whitespace from input"
    ],
    "returns": "void"
  }
]