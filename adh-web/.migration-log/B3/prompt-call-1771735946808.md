Generate Vitest component tests for "CalculEquivalentPage".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { render, screen, fireEvent, waitFor } from "@testing-library/react"
- Mock the store with vi.mock()
- CRITICAL: import the page component using @/ alias: import { CalculEquivalentPage } from "@/pages/CalculEquivalentPage"
- Place vi.mock() calls BEFORE the page import (vitest hoisting)
- Test: renders without crashing
- Test: displays loading state
- Test: displays data when loaded
- Test: handles user interactions (clicks, form submits)
- Test: displays error state

PAGE COMPONENT:
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Button, Input } from '@/components/ui';
import { useCalculEquivalentStore } from '@/stores/calculEquivalentStore';
import { useAuthStore } from '@/stores';
import type { ConversionParams, OperationType } from '@/types/calculEquivalent';

const DEVISES = [
  { code: 'EUR', label: 'Euro (EUR)' },
  { code: 'USD', label: 'Dollar US (USD)' },
  { code: 'GBP', label: 'Livre Sterling (GBP)' },
  { code: 'JPY', label: 'Yen Japonais (JPY)' },
] as const;

const MOYENS_PAIEMENT = [
  { code: 'ESP', label: 'Espèces' },
  { code: 'CB', label: 'Carte Bancaire' },
  { code: 'CHQ', label: 'Chèque' },
  { code: 'VIR', label: 'Virement' },
] as const;

export function CalculEquivalentPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);

  const isCalculating = useCalculEquivalentStore((s) => s.isCalculating);
  const error = useCalculEquivalentStore((s) => s.error);
  const validationErrors = useCalculEquivalentStore((s) => s.validationErrors);
  const lastConversion = useCalculEquivalentStore((s) => s.lastConversion);
  const calculerEquivalent = useCalculEquivalentStore((s) => s.calculerEquivalent);
  const clearError = useCalculEquivalentStore((s) => s.clearError);
  const resetState = useCalculEquivalentStore((s) => s.resetState);

  const [quantite, setQuantite] = useState<string>('');
  const [devise, setDevise] = useState<string>('USD');
  const [typeOperation, setTypeOperation] = useState<OperationType>('A');
  const [modePaiement, setModePaiement] = useState<string>('ESP');

  useEffect(() => {
    return () => resetState();
  }, [resetState]);

  const handleCalculer = useCallback(async () => {
    clearError();

    const quantiteNum = parseFloat(quantite);
    if (isNaN(quantiteNum) || quantiteNum <= 0) {
      return;
    }

    const params: ConversionParams = {
      societe: '1',
      uniBi: 'U',
      deviseLocale: 'EUR',
      nombreDecimal: 2,
      devise,
      modePaiement,
      quantite: quantiteNum,
      typeOperation,
      typeDevise: devise === 'EUR' ? 0 : devise === 'JPY' ? 2 : 1,
    };

    await calculerEquivalent(params);
  }, [quantite, devise, typeOperation, modePaiement, calculerEquivalent, clearError]);

  const handleBack = () => {
    navigate('/caisse/menu');
  };

  const getFieldError = (field: string) => {
    return validationErrors.find((e) => e.field === field)?.message;
  };

  return (
    <ScreenLayout>
      <div className="space-y-6 max-w-2xl mx-auto">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold">Calcul d'équivalent</h2>
            <p className="text-on-surface-muted text-sm mt-1">
              Conversion de devises
            </p>
          </div>
          {user && (
            <span className="text-xs text-on-surface-muted">
              {user.prenom} {user.nom}
            </span>
          )}
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md text-sm">
            {error}
          </div>
        )}

        <div className="bg-surface border border-border rounded-lg p-6 space-y-6">
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-on-surface mb-2">
                Montant
              </label>
              <Input
                type="number"
                value={quantite}
                onChange={(e) => setQuantite(e.target.value)}
                placeholder="Montant à convertir"
                min="0.01"
                step="0.01"
                disabled={isCalculating}
              />
              {getFieldError('quantite') && (
                <p className="text-red-600 text-xs mt-1">{getFieldError('quantite')}</p>
              )}
            </div>

            <div>
              <label className="block text-sm font-medium text-on-surface mb-2">
                Devise
              </label>
              <select
                value={devise}
                onChange={(e) => setDevise(e.target.value)}
                disabled={isCalculating}
                className="w-full px-3 py-2 border border-border rounded-md bg-white text-on-surface focus:outline-none focus:ring-2 focus:ring-primary"
              >
                {DEVISES.map((d) => (
                  <option key={d.code} value={d.code}>
                    {d.label}
                  </option>
                ))}
              </select>
              {getFieldError('devise') && (
                <p className="text-red-600 text-xs mt-1">{getFieldError('devise')}</p>
              )}
            </div>

            <div>
              <label className="block text-sm font-medium text-on-surface mb-2">
                Type d'opération
              </label>
              <div className="flex gap-4">
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="radio"
                    value="A"
                    checked={typeOperation === 'A'}
                    onChange={(e) => setTypeOperation(e.target.value as OperationType)}
                    disabled={isCalculating}
                    className="w-4 h-4 text-primary focus:ring-primary"
                  />
                  <span className="text-sm text-on-surface">Achat</span>
                </label>
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="radio"
                    value="V"
                    checked={typeOperation === 'V'}
                    onChange={(e) => setTypeOperation(e.target.value as OperationType)}
                    disabled={isCalculating}
                    className="w-4 h-4 text-primary focus:ring-primary"
                  />
                  <span className="text-sm text-on-surface">Vente</span>
                </label>
              </div>
              {getFieldError('typeOperation') && (
                <p className="text-red-600 text-xs mt-1">{getFieldError('typeOperation')}</p>
              )}
            </div>

            <div>
              <label className="block text-sm font-medium text-on-surface mb-2">
                Mode de paiement
              </label>
              <select
                value={modePaiement}
                onChange={(e) => setModePaiement(e.target.value)}
                disabled={isCalculating}
                className="w-full px-3 py-2 border border-border rounded-md bg-white text-on-surface focus:outline-none focus:ring-2 focus:ring-primary"
              >
                {MOYENS_PAIEMENT.map((m) => (
                  <option key={m.code} value={m.code}>
                    {m.label}
                  </option>
                ))}
              </select>
              {getFieldError('modePaiement') && (
                <p className="text-red-600 text-xs mt-1">{getFieldError('modePaiement')}</p>
              )}
            </div>
          </div>

          <div className="pt-4 border-t border-border">
            <Button
              onClick={handleCalculer}
              disabled={isCalculating || !quantite || parseFloat(quantite) <= 0}
              className="w-full"
            >
              {isCalculating ? 'Calcul en cours...' : 'Calculer'}
            </Button>
          </div>

          {lastConversion && (
            <div className="mt-6 p-4 bg-green-50 border border-green-200 rounded-md">
              <div className="flex items-center justify-between">
                <span className="text-sm font-medium text-green-900">Équivalent:</span>
                <span className="text-2xl font-bold text-green-700">
                  {lastConversion.equivalent.toFixed(2)} EUR
                </span>
              </div>
              {lastConversion.taux && (
                <p className="text-xs text-green-700 mt-2">
                  Taux appliqué: {lastConversion.taux.toFixed(4)}
                </p>
              )}
            </div>
          )}
        </div>

        <div className="flex justify-start">
          <Button onClick={handleBack} variant="secondary">
            Retour au menu
          </Button>
        </div>
      </div>
    </ScreenLayout>
  );
}

TYPES:
import type { ApiResponse } from '@/services/api/apiClient';

// ============================================================================
// DOMAIN TYPES - calculEquivalent (Change Devises - ADH IDE 25)
// ============================================================================

export type OperationType = 'A' | 'V';
export type DirectionalType = 'U' | 'B';

export interface TauxChange {
  societe: string;
  devise: string;
  tauxAchat: number;
  tauxVente: number;
  typeDevise: number;
  dateValidite: string;
  nbDecimales: number;
}

export interface MoyenReglement {
  code: string;
  libelle: string;
  cdrtDeviseIn: boolean;
  ordreAffichage: number;
}

// ============================================================================
// CONVERSION REQUEST/RESPONSE
// ============================================================================

export interface ConversionParams {
  societe: string;
  uniBi: DirectionalType;
  deviseLocale: string;
  nombreDecimal: number;
  devise: string;
  modePaiement: string;
  quantite: number;
  typeOperation: OperationType;
  typeDevise: number;
}

export interface ConversionResult {
  equivalent: number;
  cdrtDeviseIn: boolean;
  taux?: number;
  quantiteOriginale?: number;
  deviseOriginale?: string;
  deviseLocale?: string;
}

export interface ConversionError {
  field: keyof ConversionParams;
  message: string;
}

// ============================================================================
// API REQUEST/RESPONSE TYPES
// ============================================================================

export interface CalculerEquivalentRequest {
  params: ConversionParams;
}

export interface CalculerEquivalentResponse extends ApiResponse<ConversionResult> {}

export interface GetTauxChangeRequest {
  societe: string;
  devise: string;
  typeOperation: OperationType;
  uniBi: DirectionalType;
}

export interface GetTauxChangeResponse extends ApiResponse<TauxChange> {}

// ============================================================================
// VALIDATION TYPES
// ============================================================================

export interface ValidationResult {
  isValid: boolean;
  errors: ConversionError[];
}

// ============================================================================
// STORE STATE
// ============================================================================

export interface CalculEquivalentState {
  isCalculating: boolean;
  isValidating: boolean;
  error: string | null;
  validationErrors: ConversionError[];
  lastConversion: ConversionResult | null;
  conversionHistory: ConversionResult[];
  maxHistorySize: number;

  // Actions
  calculerEquivalent: (params: ConversionParams) => Promise<ConversionResult>;
  validateConversionParams: (params: ConversionParams) => Promise<ValidationResult>;
  getTauxChange: (request: GetTauxChangeRequest) => Promise<TauxChange>;
  clearError: () => void;
  clearHistory: () => void;
  resetState: () => void;
}

// ============================================================================
// UI COMPONENT PROPS
// ============================================================================

export interface ConversionFormProps {
  onSuccess?: (result: ConversionResult) => void;
  onError?: (error: string) => void;
  initialParams?: Partial<ConversionParams>;
  readonly?: boolean;
  className?: string;
}

export interface ConversionResultDisplayProps {
  result: ConversionResult | null;
  isLoading?: boolean;
  error?: string | null;
  className?: string;
}

export interface ConversionHistoryProps {
  items: ConversionResult[];
  onSelectItem?: (item: ConversionResult) => void;
  maxItems?: number;
  className?: string;
}

// ============================================================================
// BUSINESS RULES CONSTANTS
// ============================================================================

export const CONVERSION_RULES = {
  RM001: '[RM-001] Si typeOperation=A ET uniBi<>B: Appliquer taux achat unidirectionnel',
  RM002: '[RM-002] Si typeOperation=A ET uniBi=B: Appliquer taux achat bilateral (inverse du taux vente)',
  RM003: '[RM-003] Si uniBi<>B: Utiliser calcul unidirectionnel standard',
  RM004: '[RM-004] Si uniBi=B: Utiliser calcul bilateral (division par taux vente)',
  RM005: '[RM-005] Si typeOperation<>A: Appliquer logique vente (division par taux)',
} as const;

export const OPERATION_TYPES = {
  ACHAT: 'A' as const,
  VENTE: 'V' as const,
} as const;

export const DIRECTIONAL_TYPES = {
  UNIDIRECTIONNEL: 'U' as const,
  BILATERAL: 'B' as const,
} as const;

// ============================================================================
// MOCK DATA
// ============================================================================

export const MOCK_CONVERSION_SCENARIOS = [
  {
    name: 'Achat USD unidirectionnel',
    params: {
      societe: '1',
      uniBi: 'U',
      deviseLocale: 'EUR',
      nombreDecimal: 2,
      devise: 'USD',
      modePaiement: 'ESP',
      quantite: 100,
      typeOperation: 'A',
      typeDevise: 1,
    },
    expectedEquivalent: 92.5,
  },
  {
    name: 'Achat EUR bilateral',
    params: {
      societe: '1',
      uniBi: 'B',
      deviseLocale: 'EUR',
      nombreDecimal: 2,
      devise: 'EUR',
      modePaiement: 'CB',
      quantite: 100,
      typeOperation: 'A',
      typeDevise: 0,
    },
    expectedEquivalent: 100,
  },
  {
    name: 'Vente GBP unidirectionnel',
    params: {
      societe: '1',
      uniBi: 'U',
      deviseLocale: 'EUR',
      nombreDecimal: 2,
      devise: 'GBP',
      modePaiement: 'ESP',
      quantite: 50,
      typeOperation: 'V',
      typeDevise: 1,
    },
    expectedEquivalent: 58.75,
  },
  {
    name: 'Vente JPY bilateral',
    params: {
      societe: '1',
      uniBi: 'B',
      deviseLocale: 'EUR',
      nombreDecimal: 0,
      devise: 'JPY',
      modePaiement: 'CB',
      quantite: 10000,
      typeOperation: 'V',
      typeDevise: 2,
    },
    expectedEquivalent: 68.6,
  },
  {
    name: 'Espèces vs CB - USD',
    params: {
      societe: '1',
      uniBi: 'U',
      deviseLocale: 'EUR',
      nombreDecimal: 2,
      devise: 'USD',
      modePaiement: 'ESP',
      quantite: 200,
      typeOperation: 'A',
      typeDevise: 1,
    },
    expectedEquivalent: 185,
  },
] as const;

export const MOCK_TAUX_CHANGES: TauxChange[] = [
  {
    societe: '1',
    devise: 'USD',
    tauxAchat: 0.925,
    tauxVente: 1.08,
    typeDevise: 1,
    dateValidite: '2026-02-22',
    nbDecimales: 2,
  },
  {
    societe: '1',
    devise: 'EUR',
    tauxAchat: 1,
    tauxVente: 1,
    typeDevise: 0,
    dateValidite: '2026-02-22',
    nbDecimales: 2,
  },
  {
    societe: '1',
    devise: 'GBP',
    tauxAchat: 1.175,
    tauxVente: 1.29,
    typeDevise: 1,
    dateValidite: '2026-02-22',
    nbDecimales: 2,
  },
  {
    societe: '1',
    devise: 'JPY',
    tauxAchat: 145.2,
    tauxVente: 145.8,
    typeDevise: 2,
    dateValidite: '2026-02-22',
    nbDecimales: 0,
  },
] as const;

export const MOCK_MOYENS_REGLEMENT: MoyenReglement[] = [
  {
    code: 'ESP',
    libelle: 'Espèces',
    cdrtDeviseIn: true,
    ordreAffichage: 1,
  },
  {
    code: 'CB',
    libelle: 'Carte Bancaire',
    cdrtDeviseIn: false,
    ordreAffichage: 2,
  },
  {
    code: 'CHQ',
    libelle: 'Chèque',
    cdrtDeviseIn: false,
    ordreAffichage: 3,
  },
  {
    code: 'VIR',
    libelle: 'Virement',
    cdrtDeviseIn: false,
    ordreAffichage: 4,
  },
] as const;

UI SECTIONS:
[
  {
    "name": "ConversionUtility",
    "controls": [
      "Input: quantite (number)",
      "Input: devise (select)",
      "Input: typeOperation (radio: Achat/Vente)",
      "Input: modePaiement (select)",
      "Button: Calculer",
      "Output: equivalent (readonly, formatted)"
    ]
  }
]