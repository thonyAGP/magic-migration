Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/gestionChequeStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
gestionChequeStore listerChequesCompte should call API with correct query params when isRealApi is true: AssertionError: expected "vi.fn()" to be called with arguments: [ Array(1) ][90m

Received: 

[1m  1st vi.fn() call:

[22m[2m  [[22m
[32m-   "/api/gestion-cheque/liste/SOC1/C001/F1?dateDebut=202

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useGestionChequeStore } from '@/stores/gestionChequeStore';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type { Cheque } from '@/types/gestionCheque';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(),
  },
}));

const MOCK_CHEQUE: Cheque = {
  numeroCheque: 'CHQ-123456',
  montant: 500.0,
  dateEmission: new Date('2026-02-15'),
  banque: 'BNP Paribas',
  titulaire: 'DUPONT Jean',
  estPostdate: false,
};

const MOCK_CHEQUE_POSTDATE: Cheque = {
  numeroCheque: 'CHQ-789012',
  montant: 1200.0,
  dateEmission: new Date('2026-03-01'),
  banque: 'Soci√©t√© G√©n√©rale',
  titulaire: 'MARTIN Sophie',
  estPostdate: true,
};

const MOCK_CHEQUES: Cheque[] = [
  {
    numeroCheque: 'CHQ-111111',
    montant: 750.0,
    dateEmission: new Date('2026-01-10'),
    banque: 'Cr√©dit Agricole',
    titulaire: 'BERNARD Pierre',
    estPostdate: false,
  },
  {
    numeroCheque: 'CHQ-222222',
    montant: 2500.0,
    dateEmission: new Date('2026-02-05'),
    banque: 'BNP Paribas',
    titulaire: 'DUBOIS Marie',
    estPostdate: true,
  },
];

describe('gestionChequeStore', () => {
  beforeEach(() => {
    useGestionChequeStore.getState().reset();
    vi.clearAllMocks();
  });

  describe('enregistrerDepot', () => {
    it('should enregistrer depot with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();

      await store.enregistrerDepot(MOCK_CHEQUE, 'SOC1', 'C001', 'F1');

      const state = useGestionChequeStore.getState();
      expect(state.cheques).toHaveLength(1);
      expect(state.cheques[0]).toEqual(MOCK_CHEQUE);
      expect(state.totalDepots).toBe(500.0);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should enregistrer depot via API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      vi.mocked(apiClient.post).mockResolvedValue({
        data: {
          success: true,
          data: { success: true, message: 'D√©p√¥t enregistr√©' },
        },
      });

      const store = useGestionChequeStore.getState();

      await store.enregistrerDepot(MOCK_CHEQUE, 'SOC1', 'C001', 'F1');

      expect(apiClient.post).toHaveBeenCalledWith('/api/gestion-cheque/depot', {
        numeroCheque: MOCK_CHEQUE.numeroCheque,
        montant: MOCK_CHEQUE.montant,
        dateEmission: MOCK_CHEQUE.dateEmission,
        banque: MOCK_CHEQUE.banque,
        titulaire: MOCK_CHEQUE.titulaire,
        societe: 'SOC1',
        compte: 'C001',
        filiation: 'F1',
      });

      const state = useGestionChequeStore.getState();
      expect(state.cheques).toHaveLength(1);
      expect(state.totalDepots).toBe(500.0);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should set error when API call fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      const errorMessage = 'Network error';
      vi.mocked(apiClient.post).mockRejectedValue(new Error(errorMessage));

      const store = useGestionChequeStore.getState();

      await store.enregistrerDepot(MOCK_CHEQUE, 'SOC1', 'C001', 'F1');

      const state = useGestionChequeStore.getState();
      expect(state.error).toBe(errorMessage);
      expect(state.isLoading).toBe(false);
      expect(state.cheques).toHaveLength(0);
    });

    it('should accumulate multiple depots', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();

      await store.enregistrerDepot(MOCK_CHEQUE, 'SOC1', 'C001', 'F1');
      await store.enregistrerDepot(MOCK_CHEQUE_POSTDATE, 'SOC1', 'C001', 'F1');

      const state = useGestionChequeStore.getState();
      expect(state.cheques).toHaveLength(2);
      expect(state.totalDepots).toBe(1700.0);
    });
  });

  describe('enregistrerRetrait', () => {
    it('should enregistrer retrait with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();

      await store.enregistrerRetrait(MOCK_CHEQUE, 'SOC1', 'C001', 'F1');

      const state = useGestionChequeStore.getState();
      expect(state.cheques).toHaveLength(1);
      expect(state.cheques[0]).toEqual(MOCK_CHEQUE);
      expect(state.totalRetraits).toBe(500.0);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should enregistrer retrait via API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      vi.mocked(apiClient.post).mockResolvedValue({
        data: {
          success: true,
          data: { success: true, message: 'Retrait enregistr√©' },
        },
      });

      const store = useGestionChequeStore.getState();

      await store.enregistrerRetrait(MOCK_CHEQUE, 'SOC1', 'C001', 'F1');

      expect(apiClient.post).toHaveBeenCalledWith('/api/gestion-cheque/retrait', {
        numeroCheque: MOCK_CHEQUE.numeroCheque,
        montant: MOCK_CHEQUE.montant,
        dateEmission: MOCK_CHEQUE.dateEmission,
        banque: MOCK_CHEQUE.banque,
        titulaire: MOCK_CHEQUE.titulaire,
        societe: 'SOC1',
        compte: 'C001',
        filiation: 'F1',
      });

      const state = useGestionChequeStore.getState();
      expect(state.cheques).toHaveLength(1);
      expect(state.totalRetraits).toBe(500.0);
      expect(state.isLoading).toBe(false);
    });

    it('should set error when API call fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      const errorMessage = 'Insufficient funds';
      vi.mocked(apiClient.post).mockRejectedValue(new Error(errorMessage));

      const store = useGestionChequeStore.getState();

      await store.enregistrerRetrait(MOCK_CHEQUE, 'SOC1', 'C001', 'F1');

      const state = useGestionChequeStore.getState();
      expect(state.error).toBe(errorMessage);
      expect(state.isLoading).toBe(false);
    });
  });

  describe('validerCheque', () => {
    it('should return valide=false when numero already exists in mock data', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();

      const result = await store.validerCheque('CHQ-245781', new Date('2026-02-20'));

      expect(result.valide).toBe(false);
      expect(result.erreur).toBe('Num√©ro de ch√®que d√©j√† utilis√©');
    });

    it('should return valide=true and estPostdate=false when date is not future', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();
      const pastDate = new Date('2025-12-01');

      const result = await store.validerCheque('CHQ-NOUVEAU', pastDate);

      expect(result.valide).toBe(true);
      expect(result.estPostdate).toBe(false);
    });

    it('should return valide=true and estPostdate=true when date is future', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();
      const futureDate = new Date('2027-01-01');

      const result = await store.validerCheque('CHQ-NOUVEAU', futureDate);

      expect(result.valide).toBe(true);
      expect(result.estPostdate).toBe(true);
    });

    it('should validate via API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      vi.mocked(apiClient.post).mockResolvedValue({
        data: {
          success: true,
          data: { valide: true, estPostdate: false },
        },
      });

      const store = useGestionChequeStore.getState();

      const result = await store.validerCheque('CHQ-123456', new Date('2026-02-15'));

      expect(apiClient.post).toHaveBeenCalledWith('/api/gestion-cheque/valider', {
        numeroCheque: 'CHQ-123456',
        dateEmission: new Date('2026-02-15'),
      });

      expect(result.valide).toBe(true);
      expect(result.estPostdate).toBe(false);
    });

    it('should return error when API call fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      const errorMessage = 'Validation failed';
      vi.mocked(apiClient.post).mockRejectedValue(new Error(errorMessage));

      const store = useGestionChequeStore.getState();

      const result = await store.validerCheque('CHQ-123456', new Date('2026-02-15'));

      expect(result.valide).toBe(false);
      expect(result.erreur).toBe(errorMessage);
    });
  });

  describe('listerChequesCompte', () => {
    it('should return filtered cheques with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();

      const result = await store.listerChequesCompte('SOC1', 'C001', 'F1');

      expect(result.length).toBeGreaterThan(0);
      expect(useGestionChequeStore.getState().cheques).toEqual(result);
      expect(useGestionChequeStore.getState().isLoading).toBe(false);
    });

    it('should filter by dateDebut when provided', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();
      const dateDebut = new Date('2026-02-01');

      const result = await store.listerChequesCompte('SOC1', 'C001', 'F1', { dateDebut });

      result.forEach((cheque) => {
        expect(cheque.dateEmission.getTime()).toBeGreaterThanOrEqual(dateDebut.getTime());
      });
    });

    it('should filter by dateFin when provided', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();
      const dateFin = new Date('2026-02-01');

      const result = await store.listerChequesCompte('SOC1', 'C001', 'F1', { dateFin });

      result.forEach((cheque) => {
        expect(cheque.dateEmission.getTime()).toBeLessThanOrEqual(dateFin.getTime());
      });
    });

    it('should filter by estPostdate when provided', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();

      const result = await store.listerChequesCompte('SOC1', 'C001', 'F1', { estPostdate: true });

      result.forEach((cheque) => {
        expect(cheque.estPostdate).toBe(true);
      });
    });

    it('should call API with correct query params when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      vi.mocked(apiClient.get).mockResolvedValue({
        data: {
          success: true,
          data: MOCK_CHEQUES,
        },
      });

      const store = useGestionChequeStore.getState();
      const dateDebut = new Date('2026-01-01');
      const dateFin = new Date('2026-02-28');

      await store.listerChequesCompte('SOC1', 'C001', 'F1', { dateDebut, dateFin, estPostdate: true });

      const expectedUrl = `/api/gestion-cheque/liste/SOC1/C001/F1?dateDebut=${dateDebut.toISOString()}&dateFin=${dateFin.toISOString()}&estPostdate=true`;
      expect(apiClient.get).toHaveBeenCalledWith(expectedUrl);
    });

    it('should set error when API call fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      const errorMessage = 'Network error';
      vi.mocked(apiClient.get).mockRejectedValue(new Error(errorMessage));

      const store = useGestionChequeStore.getState();

      const result = await store.listerChequesCompte('SOC1', 'C001', 'F1');

      const state = useGestionChequeStore.getState();
      expect(state.error).toBe(errorMessage);
      expect(result).toEqual([]);
      expect(state.cheques).toEqual([]);
    });
  });

  describe('calculerTotaux', () => {
    it('should return mock totals when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: false,
        setIsRealApi: vi.fn(),
      });

      const store = useGestionChequeStore.getState();

      const result = await store.calculerTotaux('SOC1', 'C001', 'F1');

      expect(result.totalDepots).toBe(12075.5);
      expect(result.totalRetraits).toBe(4850.0);
      expect(useGestionChequeStore.getState().totalDepots).toBe(12075.5);
      expect(useGestionChequeStore.getState().totalRetraits).toBe(4850.0);
      expect(useGestionChequeStore.getState().isLoading).toBe(false);
    });

    it('should call API and return totals when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      const apiTotals = { totalDepots: 15000.0, totalRetraits: 5000.0 };

      vi.mocked(apiClient.get).mockResolvedValue({
        data: {
          success: true,
          data: apiTotals,
        },
      });

      const store = useGestionChequeStore.getState();

      const result = await store.calculerTotaux('SOC1', 'C001', 'F1');

      expect(apiClient.get).toHaveBeenCalledWith('/api/gestion-cheque/totaux/SOC1/C001/F1');
      expect(result.totalDepots).toBe(15000.0);
      expect(result.totalRetraits).toBe(5000.0);
      expect(useGestionChequeStore.getState().totalDepots).toBe(15000.0);
      expect(useGestionChequeStore.getState().totalRetraits).toBe(5000.0);
    });

    it('should set error and return zeros when API call fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setIsRealApi: vi.fn(),
      });

      const errorMessage = 'Calculation error';
      vi.mocked(apiClient.get).mockRejectedValue(new Error(errorMessage));

      const store = useGestionChequeStore.getState();

      const result = await store.calculerTotaux('SOC1', 'C001', 'F1');

      const state = useGestionChequeStore.getState();
      expect(state.error).toBe(errorMessage);
      expect(result.totalDepots).toBe(0);
      expect(result.totalRetraits).toBe(0);
      expect(state.totalDepots).toBe(0);
      expect(state.totalRetraits).toBe(0);
    });
  });

  describe('setters', () => {
    it('should set cheques', () => {
      const store = useGestionChequeStore.getState();

      store.setCheques(MOCK_CHEQUES);

      expect(useGestionChequeStore.getState().cheques).toEqual(MOCK_CHEQUES);
    });

    it('should set selectedCheque', () => {
      const store = useGestionChequeStore.getState();

      store.setSelectedCheque(MOCK_CHEQUE);

      expect(useGestionChequeStore.getState().selectedCheque).toEqual(MOCK_CHEQUE);
    });

    it('should set isLoading', () => {
      const store = useGestionChequeStore.getState();

      store.setIsLoading(true);

      expect(useGestionChequeStore.getState().isLoading).toBe(true);
    });

    it('should set error', () => {
      const store = useGestionChequeStore.getState();

      store.setError('Test error');

      expect(useGestionChequeStore.getState().error).toBe('Test error');
    });

    it('should set filters', () => {
      const store = useGestionChequeStore.getState();
      const filters = { dateDebut: new Date('2026-01-01'), estPostdate: true };

      store.setFilters(filters);

      expect(useGestionChequeStore.getState().filters).toEqual(filters);
    });

    it('should set totalDepots', () => {
      const store = useGestionChequeStore.getState();

      store.setTotalDepots(5000.0);

      expect(useGestionChequeStore.getState().totalDepots).toBe(5000.0);
    });

    it('should set totalRetraits', () => {
      const store = useGestionChequeStore.getState();

      store.setTotalRetraits(2000.0);

      expect(useGestionChequeStore.getState().totalRetraits).toBe(2000.0);
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', () => {
      const store = useGestionChequeStore.getState();

      store.setCheques(MOCK_CHEQUES);
      store.setSelectedCheque(MOCK_CHEQUE);
      store.setIsLoading(true);
      store.setError('Error');
      store.setTotalDepots(1000.0);
      store.setTotalRetraits(500.0);

      store.reset();

      const state = useGestionChequeStore.getState();
      expect(state.cheques).toEqual([]);
      expect(state.selectedCheque).toBeNull();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.totalDepots).toBe(0);
      expect(state.totalRetraits).toBe(0);
      expect(state.filters).toEqual({});
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  GestionChequeState,
  Cheque,
  ChequeFilters,
  EnregistrerDepotRequest,
  EnregistrerRetraitRequest,
  ListerChequesRequest,
  ValiderChequeRequest,
  CalculerTotauxRequest,
} from '@/types/gestionCheque';
import type { ApiResponse } from '@/services/api/apiClient';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

const MOCK_CHEQUES: Cheque[] = [
  {
    numeroCheque: 'CHQ-245781',
    montant: 1250.0,
    dateEmission: new Date('2025-12-15'),
    banque: 'BNP Paribas',
    titulaire: 'DUPONT Jean',
    estPostdate: false,
  },
  {
    numeroCheque: 'CHQ-389042',
    montant: 3500.0,
    dateEmission: new Date('2026-01-22'),
    banque: 'Soci√©t√© G√©n√©rale',
    titulaire: 'MARTIN Sophie',
    estPostdate: false,
  },
  {
    numeroCheque: 'CHQ-567123',
    montant: 850.5,
    dateEmission: new Date('2026-02-01'),
    banque: 'Cr√©dit Agricole',
    titulaire: 'BERNARD Pierre',
    estPostdate: false,
  },
  {
    numeroCheque: 'CHQ-892456',
    montant: 2100.0,
    dateEmission: new Date('2026-02-28'),
    banque: 'BNP Paribas',
    titulaire: 'DUBOIS Marie',
    estPostdate: true,
  },
  {
    numeroCheque: 'CHQ-134567',
    montant: 450.0,
    dateEmission: new Date('2026-01-18'),
    banque: 'Cr√©dit Mutuel',
    titulaire: 'PETIT Luc',
    estPostdate: false,
  },
  {
    numeroCheque: 'CHQ-678901',
    montant: 5000.0,
    dateEmission: new Date('2026-02-10'),
    banque: 'Soci√©t√© G√©n√©rale',
    titulaire: 'ROUX Claire',
    estPostdate: false,
  },
  {
    numeroCheque: 'CHQ-445566',
    montant: 175.0,
    dateEmission: new Date('2026-01-28'),
    banque: 'Cr√©dit Agricole',
    titulaire: 'LEROY Paul',
    estPostdate: false,
  },
  {
    numeroCheque: 'CHQ-998877',
    montant: 3200.0,
    dateEmission: new Date('2026-03-05'),
    banque: 'BNP Paribas',
    titulaire: 'MOREAU Anne',
    estPostdate: true,
  },
  {
    numeroCheque: 'CHQ-223344',
    montant: 950.0,
    dateEmission: new Date('2026-02-05'),
    banque: 'Cr√©dit Mutuel',
    titulaire: 'SIMON Marc',
    estPostdate: false,
  },
  {
    numeroCheque: 'CHQ-556677',
    montant: 1800.0,
    dateEmission: new Date('2026-02-25'),
    banque: 'Soci√©t√© G√©n√©rale',
    titulaire: 'LAURENT Julie',
    estPostdate: true,
  },
];

const initialState: Omit<
  GestionChequeState,
  | 'setCheques'
  | 'setSelectedCheque'
  | 'setIsLoading'
  | 'setError'
  | 'setFilters'
  | 'setTotalDepots'
  | 'setTotalRetraits'
  | 'enregistrerDepot'
  | 'enregistrerRetrait'
  | 'validerCheque'
  | 'listerChequesCompte'
  | 'calculerTotaux'
  | 'reset'
> = {
  cheques: [],
  selectedCheque: null,
  isLoading: false,
  error: null,
  filters: {},
  totalDepots: 0,
  totalRetraits: 0,
};

export const useGestionChequeStore = create<GestionChequeState>()((set) => ({
  ...initialState,

  setCheques: (cheques) => set({ cheques }),
  setSelectedCheque: (cheque) => set({ selectedCheque: cheque }),
  setIsLoading: (loading) => set({ isLoading: loading }),
  setError: (error) => set({ error }),
  setFilters: (filters) => set({ filters }),
  setTotalDepots: (total) => set({ totalDepots: total }),
  setTotalRetraits: (total) => set({ totalRetraits: total }),

  enregistrerDepot: async (cheque, societe, compte, filiation) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set((state) => ({
        cheques: [...state.cheques, cheque],
        totalDepots: state.totalDepots + cheque.montant,
        isLoading: false,
      }));
      return;
    }

    try {
      const request: EnregistrerDepotRequest = {
        numeroCheque: cheque.numeroCheque,
        montant: cheque.montant,
        dateEmission: cheque.dateEmission,
        banque: cheque.banque,
        titulaire: cheque.titulaire,
        societe,
        compte,
        filiation,
      };

      const response = await apiClient.post<ApiResponse<{ success: boolean; message?: string }>>(
        '/api/gestion-cheque/depot',
        request,
      );

      if (response.data.success && response.data.data?.success) {
        set((state) => ({
          cheques: [...state.cheques, cheque],
          totalDepots: state.totalDepots + cheque.montant,
        }));
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur lors de l\'enregistrement du d√©p√¥t';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  enregistrerRetrait: async (cheque, societe, compte, filiation) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set((state) => ({
        cheques: [...state.cheques, cheque],
        totalRetraits: state.totalRetraits + cheque.montant,
        isLoading: false,
      }));
      return;
    }

    try {
      const request: EnregistrerRetraitRequest = {
        numeroCheque: cheque.numeroCheque,
        montant: cheque.montant,
        dateEmission: cheque.dateEmission,
        banque: cheque.banque,
        titulaire: cheque.titulaire,
        societe,
        compte,
        filiation,
      };

      const response = await apiClient.post<ApiResponse<{ success: boolean; message?: string }>>(
        '/api/gestion-cheque/retrait',
        request,
      );

      if (response.data.success && response.data.data?.success) {
        set((state) => ({
          cheques: [...state.cheques, cheque],
          totalRetraits: state.totalRetraits + cheque.montant,
        }));
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur lors de l\'enregistrement du retrait';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  validerCheque: async (numeroCheque, dateEmission) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      const existant = MOCK_CHEQUES.find((c) => c.numeroCheque === numeroCheque);
      if (existant) {
        return {
          valide: false,
          estPostdate: false,
          erreur: 'Num√©ro de ch√®que d√©j√† utilis√©',
        };
      }

      const today = new Date();
      const estPostdate = dateEmission > today;

      return {
        valide: true,
        estPostdate,
      };
    }

    try {
      const request: ValiderChequeRequest = {
        numeroCheque,
        dateEmission,
      };

      const response = await apiClient.post<
        ApiResponse<{ valide: boolean; estPostdate: boolean; erreur?: string }>
      >('/api/gestion-cheque/valider', request);

      return (
        response.data.data ?? {
          valide: false,
          estPostdate: false,
          erreur: 'Erreur de validation',
        }
      );
    } catch (e: unknown) {
      return {
        valide: false,
        estPostdate: false,
        erreur: e instanceof Error ? e.message : 'Erreur lors de la validation du ch√®que',
      };
    }
  },

  listerChequesCompte: async (societe, compte, filiation, filters) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      let filtered = [...MOCK_CHEQUES];

      if (filters?.dateDebut) {
        filtered = filtered.filter((c) => c.dateEmission >= filters.dateDebut!);
      }

      if (filters?.dateFin) {
        filtered = filtered.filter((c) => c.dateEmission <= filters.dateFin!);
      }

      if (filters?.estPostdate !== undefined) {
        filtered = filtered.filter((c) => c.estPostdate === filters.estPostdate);
      }

      filtered.sort((a, b) => b.dateEmission.getTime() - a.dateEmission.getTime());

      set({ cheques: filtered, isLoading: false });
      return filtered;
    }

    try {
      const params: Record<string, string> = {};
      if (filters?.dateDebut) {
        params.dateDebut = filters.dateDebut.toISOString();
      }
      if (filters?.dateFin) {
        params.dateFin = filters.dateFin.toISOString();
      }
      if (filters?.estPostdate !== undefined) {
        params.estPostdate = String(filters.estPostdate);
      }

      const queryString = new URLSearchParams(params).toString();
      const url = `/api/gestion-cheque/liste/${societe}/${compte}/${filiation}${queryString ? `?${queryString}` : ''}`;

      const response = await apiClient.get<ApiResponse<Cheque[]>>(url);

      const cheques = response.data.data ?? [];
      set({ cheques });
      return cheques;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur lors de la r√©cup√©ration des ch√®ques';
      set({ error: message, cheques: [] });
      return [];
    } finally {
      set({ isLoading: false });
    }
  },

  calculerTotaux: async (societe, compte, filiation) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const totalDepots = 12075.5;
      const totalRetraits = 4850.0;

      set({ totalDepots, totalRetraits, isLoading: false });
      return { totalDepots, totalRetraits };
    }

    try {
      const response = await apiClient.get<
        ApiResponse<{ totalDepots: number; totalRetraits: number }>
      >(`/api/gestion-cheque/totaux/${societe}/${compte}/${filiation}`);

      const data = response.data.data ?? { totalDepots: 0, totalRetraits: 0 };
      set({ totalDepots: data.totalDepots, totalRetraits: data.totalRetraits });
      return data;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur lors du calcul des totaux';
      set({ error: message, totalDepots: 0, totalRetraits: 0 });
      return { totalDepots: 0, totalRetraits: 0 };
    } finally {
      set({ isLoading: false });
    }
  },

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.