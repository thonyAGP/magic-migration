Review the generated code against the original specification.

Produce a JSON report:
```json
{
  "programId": 0,
  "programName": "",
  "coveragePct": 0,
  "rulesImplemented": 0,
  "rulesTotal": 0,
  "missingRules": [
    "rule descriptions not implemented"
  ],
  "recommendations": [
    "improvement suggestions"
  ]
}
```

Check:
1. Every business rule from the contract is implemented in the store
2. Every table from the contract has corresponding entity types
3. Every API endpoint is wired to the store
4. UI layout matches the spec description
5. Error handling is present for all actions

CONTRACT RULES:
[
  {
    "id": "RM-001",
    "description": "Condition: P. O/T/F [A] egale 'O'",
    "condition": "P. O/T/F [A]='O'",
    "variables": [
      "EN"
    ],
    "status": "IMPL",
    "targetFile": "adh-web/src/stores/saisieContenuCaisseStore.ts",
    "gapNotes": ""
  },
  {
    "id": "RM-002",
    "description": "Negation de (Date ()>[E]+Val ([G],'##')) OR VG3 (condition inversee)",
    "condition": "NOT (Date ()>[E]+Val ([G],'##')) OR VG3",
    "variables": [],
    "status": "IMPL",
    "targetFile": "adh-web/src/services/printer/generators/ouvertureTicketGenerator.ts",
    "gapNotes": ""
  },
  {
    "id": "RM-003",
    "description": "Condition composite: Date ()>[E]+Val ([G],'##') AND NOT(VG3)",
    "condition": "Date ()>[E]+Val ([G],'##') AND NOT(VG3)",
    "variables": [
      "EN"
    ],
    "status": "IMPL",
    "targetFile": "adh-web/src/__tests__/approTicketStore.test.ts",
    "gapNotes": ""
  },
  {
    "id": "RM-004",
    "description": "Condition: P. O/T/F [A] egale 'T'",
    "condition": "P. O/T/F [A]='T'",
    "variables": [
      "EN"
    ],
    "status": "MISSING",
    "targetFile": "",
    "gapNotes": ""
  },
  {
    "id": "RM-005",
    "description": "Negation de (Date ()*10^5+Time ()<[J]*10^5+[K]) (condition inversee)",
    "condition": "NOT (Date ()*10^5+Time ()<[J]*10^5+[K])",
    "variables": [
      "EN"
    ],
    "status": "MISSING",
    "targetFile": "",
    "gapNotes": ""
  },
  {
    "id": "RM-006",
    "description": "Condition: P. O/T/F [A] egale 'F'",
    "condition": "P. O/T/F [A]='F'",
    "variables": [
      "EN"
    ],
    "status": "MISSING",
    "targetFile": "",
    "gapNotes": ""
  },
  {
    "id": "RM-007",
    "description": "Negation de ([L]) (condition inversee)",
    "condition": "NOT ([L])",
    "variables": [],
    "status": "MISSING",
    "targetFile": "",
    "gapNotes": ""
  }
]

SPEC EXCERPT:
﻿# ADH IDE 48 - Contrôles - Integrite dates

> **Analyse**: Phases 1-4 2026-02-08 01:45 -> 01:45 (5s) | Assemblage 01:45
> **Pipeline**: V7.2 Enrichi
> **Structure**: 4 onglets (Resume | Ecrans | Donnees | Connexions)

<!-- TAB:Resume -->

## 1. FICHE D'IDENTITE

| Attribut | Valeur |
|----------|--------|
| Projet | ADH |
| IDE Position | 48 |
| Nom Programme | Contrôles - Integrite dates |
| Fichier source | `Prg_48.xml` |
| Dossier IDE | General |
| Taches | 5 (0 ecrans visibles) |
| Tables modifiees | 0 |
| Programmes appeles | 0 |
| Complexite | **BASSE** (score 0/100) |

## 2. DESCRIPTION FONCTIONNELLE

Le programme ADH IDE 48 effectue une vérification d'intégrité des dates dans le contexte de gestion de caisse. Il valide que les dates saisies ou manipulées respectent les contraintes métier imposées par le système de caisse (date de session, date d'ouverture/fermeture, etc.). Ce contrôle intervient à plusieurs points critiques du flux: lors de l'ouverture de session (IDE 121), lors de la gestion avancée de caisse (IDE 298), et lors de la navigation dans le menu scrollable de caisse (IDE 163).

Les vérifications d'intégrité portent typiquement sur l'ordre chronologique des dates (date d'ouverture antérieure à celle de fermeture), la cohérence avec la date système, et le respect des règles de plage de dates autorisées. Le programme retourne un code de validation permettant aux appelants de bloquer ou signaler les incohérences avant que des transactions ne soient engagées sur une session avec des paramètres temporels invalides.

Ce programme fait partie de la couche de validation partagée entre les différents écrans de gestion de caisse, garantissant une logique cohérente et fiable d'acceptation des paramètres de session indépendamment du point d'entrée utilisateur.

## 3. BLOCS FONCTIONNELS

## 5. REGLES METIER

7 regles identifiees:

### Autres (7 regles)

#### <a id="rm-RM-001"></a>[RM-001] Condition: P. O/T/F [A] egale 'O'

| Element | Detail |
|---------|--------|
| **Condition** | `P. O/T/F [A]='O'` |
| **Si vrai** | Action si vrai |
| **Variables** | EN (P. O/T/F) |
| **Expression source** | Expression 3 : `P. O/T/F [A]='O'` |
| **Exemple** | Si P. O/T/F [A]='O' â†’ Action si vrai |

#### <a id="rm-RM-002"></a>[RM-002] Negation de (Date ()>[E]+Val ([G],'##')) OR VG3 (condition inversee)

| Element | Detail |
|---------|--------|
| **Condition** | `NOT (Date ()>[E]+Val ([G],'##')) OR VG3` |
| **Si vrai** | Action si vrai |
| **Expression source** | Expression 4 : `NOT (Date ()>[E]+Val ([G],'##')) OR VG3` |
| **Exemple** | Si NOT (Date ()>[E]+Val ([G],'##')) OR VG3 â†’ Action si vrai |

#### <a id="rm-RM-003"></a>[RM-003] Condition composite: Date ()>[E]+Val ([G],'##') AND NOT(VG3)

| Element | Detail |
|---------|--------|
| **Condition** | `Date ()>[E]+Val ([G],'##') AND NOT(VG3)` |
| **Si vrai** | Action si vrai |
| **Expression source** | Expression 5 : `Date ()>[E]+Val ([G],'##') AND NOT(VG3)` |
| **Exemple** | Si Date ()>[E]+Val ([G],'##') AND NOT(VG3) â†’ Action si vrai |

#### <a id="rm-RM-004"></a>[RM-004] Condition: P. O/T/F [A] egale 'T'

| Element | Detail |
|---------|--------|
| **Condition** | `P. O/T/F [A]='T'` |
| **Si vrai** | Action si vrai |
| **Variables** | EN (P. O/T/F) |
| **Expression source** | Expression 6 : `P. O/T/F [A]='T'` |
| **Exemple** | Si P. O/T/F [A]='T' â†’ Action si vrai |

#### <a id="rm-RM-005"></a>[RM-005] Negation de (Date ()*10^5+Time ()<[J]*10^5+[K]) (condition inversee)

| Element | Detail |
|---------|--------|
| **Condition** | `NOT (Date ()*10^5+Time ()<[J]*10^5+[K])` |
| **Si vrai** | Action si vrai |
| **Expression source** | Expression 8 : `NOT (Date ()*10^5+Time ()<[J]*10^5+[K])` |
| **Exemple** | Si NOT (Date ()*10^5+Time ()<[J]*10^5+[K]) â†’ Action si vrai |

#### <a id="rm-RM-006"></a>[RM-006] Condition: P. O/T/F [A] egale 'F'

| Element | Detail |
|---------|--------|
| **Condition** | `P. O/T/F [A]='F'` |
| **Si vrai** | Action si vrai |
| **Variables** | EN (P. O/T/F) |
| **Expression source** | Expression 9 : `P. O/T/F [A]='F'` |
| **Exemple** | Si P. O/T/F [A]='F' â†’ Action si vrai |

#### <a id="rm-RM-007"></a>[RM-007] Negation de ([L]) (condition inversee)

| Element | Detail |
|---------|--------|
| **Condition** | `NOT ([L])` |
| **Si vrai** | Action si vrai |
| **Expression source** | Expression 10 : `NOT ([L])` |
| **Exemple** | Si NOT ([L]) â†’ Action si vrai |

## 6. CONTEXTE

- **Appele par**: [Gestion caisse (IDE 121)](ADH-IDE-121.md), [Gestion caisse 142 (IDE 298)](ADH-IDE-298.md), [Menu caisse GM - scroll (IDE 163)](ADH-IDE-163.md)
- **Appelle**: 0 programmes | **Tables**: 7 (W:0 R:5 L:2) | **Taches**: 5 | **Expressions**: 13

<!-- TAB:Ecrans -->

## 8. ECRANS

*(Programme sans ecran visible)*

## 9. NAVIGATION

### 9.3 Structure hierarchique (0 tache)

| Position | Tache | Type | Dimensions | Bloc |
|----------|-------|------|------------|------|

### 9.4 Algorigramme

```mermaid
flowchart TD
    START([START])
    INIT[Init 

GENERATED FILES:

--- types/integriteDates.ts ---
// Integrite Dates types (IDE 286)

export type DateCheckType = 'O' | 'T' | 'F';

export interface DateIntegrityCheck {
  checkType: DateCheckType;
  societe: string;
  isValid: boolean;
  hasClosureAnomaly: boolean;
  errorMessage?: string;
  timestamp: string;
}

export interface DateComptable {
  checkType: DateCheckType;
  societe: string;
  controleOk: boolean;
  anomalieFermeture: boolean;
  dateComptable: string;
  delaiJours: number;
}

export interface OuvertureValidation {
  isValid: boolean;
  dateComptable: string;
  currentDate: string;
  delaiExceeded: boolean;
}

export interface TransactionValidation {
  isValid: boolean;
  dateSession: string;
  heureSession: string;
  currentTimestamp: number;
  sessionTimestamp: number;
  isTimestampValid: boolean;
}

export interface FermetureValidation {
  isValid: boolean;
  hasAnomaly: boolean;
  blockedReason?: string;
}

export interface DateCheckRequest {
  checkType: DateCheckType;
  societe: string;
  dateSession?: string;
  heureSession?: string;
}

export interface DateCheckResponse {
  success: boolean;
  data?: DateIntegrityCheck;
  error?: string;
}

export interface DateComptableResponse {
  success: boolean;
  data?: DateComptable;
  error?: string;
}

export interface IntegriteDatesState {
  checkType: DateCheckType;
  societe: string;
  isLoading: boolean;
  error: string | null;
  validationResult: DateIntegrityCheck | null;
  ouvertureValidation: OuvertureValidation | null;
  transactionValidation: TransactionValidation | null;
  fermetureValidation: FermetureValidation | null;
  
  setCheckType: (checkType: DateCheckType) => void;
  setSociete: (societe: string) => void;
  setError: (error: string | null) => void;
  clearValidationResult: () => void;
  
  validateDateIntegrity: (checkType: DateCheckType, societe: string) => Promise<DateIntegrityCheck>;
  checkOuverture: (societe: string) => Promise<boolean>;
  checkTransaction: (societe: string, dateSession: string, heureSession: string) => Pr

--- stores/integriteDatesStore.ts ---
import { create } from 'zustand';
import type {
  DateIntegrityCheck,
  DateComptable,
  OuvertureValidation,
  TransactionValidation,
  FermetureValidation,
  DateCheckType,
} from '@/types/integriteDates';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface IntegriteDatesState {
  checkType: DateCheckType;
  societe: string;
  isLoading: boolean;
  error: string | null;
  validationResult: DateIntegrityCheck | null;
  ouvertureValidation: OuvertureValidation | null;
  transactionValidation: TransactionValidation | null;
  fermetureValidation: FermetureValidation | null;
}

interface IntegriteDatesActions {
  setCheckType: (checkType: DateCheckType) => void;
  setSociete: (societe: string) => void;
  setError: (error: string | null) => void;
  clearValidationResult: () => void;
  validateDateIntegrity: (checkType: DateCheckType, societe: string) => Promise<DateIntegrityCheck>;
  checkOuverture: (societe: string) => Promise<boolean>;
  checkTransaction: (societe: string, dateSession: string, heureSession: string) => Promise<boolean>;
  checkFermeture: (societe: string) => Promise<{ isValid: boolean; hasAnomaly: boolean }>;
  reset: () => void;
}

type IntegriteDatesStore = IntegriteDatesState & IntegriteDatesActions;

const MOCK_DATE_COMPTABLE: DateComptable = {
  checkType: 'O',
  societe: 'SOC1',
  controleOk: true,
  anomalieFermeture: false,
  dateComptable: '2026-02-20',
  delaiJours: 3,
};

const MOCK_VALIDATIONS: Record<DateCheckType, DateIntegrityCheck> = {
  O: {
    checkType: 'O',
    societe: 'SOC1',
    isValid: true,
    hasClosureAnomaly: false,
    timestamp: new Date().toISOString(),
  },
  T: {
    checkType: 'T',
    societe: 'SOC1',
    isValid: false,
    hasClosureAnomaly: false,
    errorMessage: 'Transaction timestamp invalide: session date/heure antérieure à maintenant',
    timestamp: new Date().toISOString(),
  

--- services/api/endpoints-integriteDates.ts ---
import { apiClient, type ApiResponse } from './apiClient';
import type {
  DateIntegrityCheck,
  DateComptable,
  DateCheckRequest,
} from '@/types/integriteDates';

export const integriteDatesApi = {
  checkIntegrity: (request: DateCheckRequest) =>
    apiClient.post<ApiResponse<DateIntegrityCheck>>(
      '/controles/integrite-dates',
      request,
    ),

  getDateComptable: (societe: string, checkType: string) =>
    apiClient.get<ApiResponse<DateComptable>>(
      `/controles/date-comptable?societe=${encodeURIComponent(societe)}&checkType=${encodeURIComponent(checkType)}`,
    ),
};

--- pages/IntegriteDatesPage.tsx ---
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Button, Dialog, Input } from '@/components/ui';
import { useIntegriteDatesStore } from '@/stores/integriteDatesStore';
import { useAuthStore } from '@/stores';
import type { DateCheckType } from '@/types/integriteDates';
import { cn } from '@/lib/utils';

const CHECK_TYPE_LABELS = {
  O: 'Ouverture',
  T: 'Transaction',
  F: 'Fermeture',
} as const;

export function IntegriteDatesPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);

  const checkType = useIntegriteDatesStore((s) => s.checkType);
  const societe = useIntegriteDatesStore((s) => s.societe);
  const isLoading = useIntegriteDatesStore((s) => s.isLoading);
  const error = useIntegriteDatesStore((s) => s.error);
  const validationResult = useIntegriteDatesStore((s) => s.validationResult);
  const ouvertureValidation = useIntegriteDatesStore((s) => s.ouvertureValidation);
  const transactionValidation = useIntegriteDatesStore((s) => s.transactionValidation);
  const fermetureValidation = useIntegriteDatesStore((s) => s.fermetureValidation);
  const setCheckType = useIntegriteDatesStore((s) => s.setCheckType);
  const setSociete = useIntegriteDatesStore((s) => s.setSociete);
  const validateDateIntegrity = useIntegriteDatesStore((s) => s.validateDateIntegrity);
  const checkOuverture = useIntegriteDatesStore((s) => s.checkOuverture);
  const checkTransaction = useIntegriteDatesStore((s) => s.checkTransaction);
  const checkFermeture = useIntegriteDatesStore((s) => s.checkFermeture);
  const clearValidationResult = useIntegriteDatesStore((s) => s.clearValidationResult);
  const reset = useIntegriteDatesStore((s) => s.reset);

  const [dateSession, setDateSession] = useState('');
  const [heureSession, setHeureSession] = useState('');
  const [showResultDialog, setShowResultDialog] = useState(false);

  useEffect

--- components/caisse/integriteDates/DateIntegrityValidationPanel.tsx ---
import type { FC } from 'react';
import { cn } from '@/lib/utils';
import type { DateCheckType } from '@/types/integriteDates';

interface DateIntegrityValidationPanelProps {
  checkType: DateCheckType;
  societe: string;
  isValid: boolean;
  hasClosureAnomaly?: boolean;
  errorMessage?: string;
  className?: string;
}

const CHECK_TYPE_LABELS = {
  O: 'Ouverture',
  T: 'Transaction',
  F: 'Fermeture',
} as const;

export const DateIntegrityValidationPanel: FC<DateIntegrityValidationPanelProps> = ({
  checkType,
  societe,
  isValid,
  hasClosureAnomaly = false,
  errorMessage,
  className,
}) => {
  const getStatusColor = () => {
    if (!isValid) return 'bg-red-100 border-red-500 text-red-800';
    if (hasClosureAnomaly) return 'bg-yellow-100 border-yellow-500 text-yellow-800';
    return 'bg-green-100 border-green-500 text-green-800';
  };

  const getStatusIcon = () => {
    if (!isValid) return '✕';
    if (hasClosureAnomaly) return '⚠';
    return '✓';
  };

  const getStatusText = () => {
    if (!isValid) return 'Invalide';
    if (hasClosureAnomaly) return 'Anomalie détectée';
    return 'Valide';
  };

  return (
    <div className={cn('space-y-4', className)}>
      <div className={cn(
        'flex items-center gap-3 p-4 rounded-lg border-2 transition-colors',
        getStatusColor()
      )}>
        <div className="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-white/80 font-semibold">
          {getStatusIcon()}
        </div>
        <div className="flex-1">
          <div className="font-semibold text-sm">
            Validation {CHECK_TYPE_LABELS[checkType]}
          </div>
          <div className="text-xs opacity-80 mt-0.5">
            Société: {societe}
          </div>
        </div>
        <div className="text-sm font-semibold">
          {getStatusText()}
        </div>
      </div>

      {errorMessage && (
        <div className="p-4 rounded-lg border-2 border-red-400 bg-red-50 text-red-800">
          <div clas