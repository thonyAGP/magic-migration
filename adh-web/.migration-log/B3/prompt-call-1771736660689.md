Generate a React component: ForbiddenCharsListPanel for the "CharacterValidation" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

COMPONENT REQUIREMENTS:
- Props interface at the top of the file
- Tailwind v4 classes for styling
- Use shared UI components from @/components/ui/ when applicable (DataGrid, Dialog, etc.)
- Handle loading and empty states

SECTION TO IMPLEMENT:
{
  "name": "forbiddenCharsList",
  "controls": [
    "characterList",
    "addCharButton",
    "removeCharButton"
  ]
}

PAGE (shows how this component is used):
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Button, Input, Dialog } from '@/components/ui';
import { useCharacterValidationStore } from '@/stores/characterValidationStore';
import { useAuthStore } from '@/stores';
import { cn } from '@/lib/utils';

export function CharacterValidationPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);

  const forbiddenCharacters = useCharacterValidationStore((s) => s.forbiddenCharacters);
  const lastValidationResult = useCharacterValidationStore((s) => s.lastValidationResult);
  const isValidating = useCharacterValidationStore((s) => s.isValidating);
  const error = useCharacterValidationStore((s) => s.error);
  const validateCharacters = useCharacterValidationStore((s) => s.validateCharacters);
  const loadForbiddenCharacters = useCharacterValidationStore((s) => s.loadForbiddenCharacters);
  const checkString = useCharacterValidationStore((s) => s.checkString);
  const setError = useCharacterValidationStore((s) => s.setError);
  const setIsValidating = useCharacterValidationStore((s) => s.setIsValidating);
  const reset = useCharacterValidationStore((s) => s.reset);

  const [inputValue, setInputValue] = useState('');
  const [showCharListDialog, setShowCharListDialog] = useState(false);
  const [newChar, setNewChar] = useState('');
  const [localForbiddenChars, setLocalForbiddenChars] = useState<string[]>([]);

  useEffect(() => {
    loadForbiddenCharacters();
    return () => reset();
  }, [loadForbiddenCharacters, reset]);

  useEffect(() => {
    setLocalForbiddenChars(forbiddenCharacters);
  }, [forbiddenCharacters]);

  const handleValidate = useCallback(async () => {
    if (!inputValue.trim()) {
      setError('Veuillez saisir un texte Ã  valider');
      return;
    }
    await validateCharacters(inputValue);
  }, [inputValue, validateCharacters, setError]);

  const

TYPES:
export interface ValidationResult {
  isValid: boolean;
  invalidCharacters: string;
  position: number | null;
}

export interface ValidateCharactersRequest {
  input: string;
}

export interface ValidateCharactersResponse {
  result: ValidationResult;
}

export interface CheckStringRequest {
  input: string;
  forbiddenChars: string[];
}

export interface CheckStringResponse {
  result: ValidationResult;
}

export interface ForbiddenCharactersResponse {
  characters: string[];
}

export interface CharacterValidationState {
  forbiddenCharacters: string[];
  lastValidationResult: ValidationResult | null;
  isValidating: boolean;
  error: string | null;
  validateCharacters: (input: string) => Promise<ValidationResult>;
  loadForbiddenCharacters: () => Promise<void>;
  checkString: (input: string, forbiddenChars: string[]) => ValidationResult;
  setError: (error: string | null) => void;
  setIsValidating: (isValidating: boolean) => void;
  reset: () => void;
}