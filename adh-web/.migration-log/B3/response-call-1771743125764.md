Basé sur mon analyse du code généré et du contrat de migration, voici le rapport de couverture au format JSON :

```json
{
  "programId": 175,
  "programName": "Facturation appel",
  "coveragePct": 52,
  "rulesImplemented": 1,
  "rulesTotal": 1,
  "missingRules": [],
  "missingTables": [
    "historique_pabx (Table 155 - W) - Pas d'entité TypeScript ni de logique d'écriture",
    "coef__telephone__coe (Table 157 - W) - Pas d'entité TypeScript ni de logique d'écriture"
  ],
  "missingCallees": [
    "Creation O.D (IDE 16) - Aucune référence dans le code généré",
    "Test si cloture en cours (IDE 19) - Pas de vérification spécifique",
    "Zoom GO/GM (IDE 36) - Aucune interface de sélection GO/GM implémentée"
  ],
  "partiallyImplementedFeatures": [
    "ReseauCloture - Type défini mais pas de logique d'écriture (Table 23)",
    "TypeCompte - Type GO/GM défini mais pas de zoom/sélection UI",
    "Variable G (> GO) - Mentionnée dans contract mais pas utilisée dans le code"
  ],
  "recommendations": [
    "**Tables manquantes (CRITIQUE)** : Implémenter les entités et la logique pour historique_pabx et coef__telephone__coe",
    "**Règle RM-001** : Actuellement marquée IMPL dans saisieContenuCaisseStore.ts (mauvais fichier). Devrait être dans facturationAppelStore.ts pour déterminer TypeCompte ('GO' si > GO sinon 'GM')",
    "**Callees manquants** : Intégrer les appels aux programmes 16, 19, et 36 selon la spécification",
    "**UI Zoom GO/GM** : Ajouter une interface de sélection/consultation pour choisir entre compte GO et GM",
    "**Validation cloture** : Renforcer la logique verifierCloture() pour correspondre au programme IDE 19",
    "**Variable G** : Implémenter la logique utilisant la variable G pour déterminer automatiquement le type de compte",
    "**Écriture tables** : Le store actuel ne fait que de la lecture. Ajouter la logique d'écriture pour les 3 tables (reseau_cloture, historique_pabx, coef_telephone)",
    "**Error handling** : Ajouter une gestion d'erreur plus granulaire pour les opérations d'écriture",
    "**Tests unitaires** : Créer facturationAppelStore.test.ts pour valider toutes les actions",
    "**API endpoints** : Vérifier que tous les endpoints correspondent exactement aux besoins (actuellement 7 endpoints définis)"
  ],
  "implementedCorrectly": [
    "✓ TypeCompte type avec valeurs 'GO' | 'GM'",
    "✓ Interface HistoriqueAppel complète avec tous les champs",
    "✓ Interface ReseauCloture avec cloture_enCours",
    "✓ Interface CoefTelephone",
    "✓ Store avec actions : chargerHistoriqueAppels, recupererCoefficient, facturerAppel",
    "✓ Store avec actions : verifierCloture, debloquerCloture, marquerGratuit, annulerFacturation",
    "✓ Filtres : societe, dateDebut, dateFin",
    "✓ Mock data complet pour développement",
    "✓ Gestion isLoading et error",
    "✓ Validation gratuite dans facturerAppel",
    "✓ Vérification clôture avant facturation",
    "✓ 7 API endpoints définis (historique, coefficient, facturer, cloture-status, debloquer, marquer-gratuit, annuler)"
  ],
  "detailedGaps": {
    "businessRules": {
      "total": 1,
      "implemented": 0,
      "gap": "RM-001 est marquée IMPL dans le contract mais le code généré ne l'utilise pas. La règle 'Si > GO [G] alors GO sinon GM' devrait être dans facturationAppelStore.ts ligne ~268 pour déterminer automatiquement typeCompte"
    },
    "tables": {
      "total": 3,
      "implemented": 1,
      "partiallyImplemented": 0,
      "missing": 2,
      "details": {
        "reseau_cloture___rec": "PARTIAL - Type ReseauCloture défini mais pas de logique d'écriture",
        "historique_pabx": "MISSING - Aucune entité ni logique",
        "coef__telephone__coe": "MISSING - Lecture seule, pas d'écriture"
      }
    },
    "callees": {
      "total": 5,
      "implemented": 2,
      "missing": 3,
      "details": {
        "17_Deblocage_compte_GM": "OK - Fonction debloquerCloture() implémentée",
        "18_Test_reseau": "OK - Propriété testReseau dans ReseauCloture",
        "16_Creation_OD": "MISSING - Pas de création d'opération diverse",
        "19_Test_si_cloture_en_cours": "PARTIAL - verifierCloture() existe mais pas de vérification spécifique programme 19",
        "36_Zoom_GO_GM": "MISSING - Pas d'UI de sélection/consultation"
      }
    },
    "uiLayout": {
      "implemented": true,
      "notes": "Page FacturationAppelPage créée avec panels, mais manque l'écran de zoom GO/GM"
    },
    "errorHandling": {
      "implemented": true,
      "quality": "GOOD",
      "notes": "Error handling présent dans toutes les actions du store avec try/catch et set error state"
    }
  },
  "summaryByCategory": {
    "types": "95% - Tous les types principaux définis",
    "store": "75% - Actions principales présentes mais logique métier incomplète",
    "api": "70% - 7 endpoints définis mais manque vérification tables",
    "ui": "60% - Page principale créée mais composants manquants (zoom)",
    "businessLogic": "40% - Règle RM-001 non implémentée, callees manquants",
    "dataAccess": "33% - 1/3 tables correctement gérées"
  },
  "nextSteps": [
    "1. Déplacer et implémenter RM-001 dans facturationAppelStore.ts (fonction determinerTypeCompte)",
    "2. Créer les entités pour historique_pabx et coef_telephone",
    "3. Implémenter la logique d'écriture pour les 3 tables",
    "4. Créer le composant ZoomGoGmDialog pour la sélection de type de compte",
    "5. Intégrer l'appel au programme 16 (Creation O.D)",
    "6. Ajouter les tests unitaires (facturationAppelStore.test.ts)",
    "7. Vérifier l'intégration avec les programmes appelants (IDE 22)"
  ]
}
```

**Résumé exécutif** :

Le code généré couvre **52%** des exigences du contrat de migration. Les types et le store sont bien structurés, mais il manque des éléments critiques :

1. **Tables** : Seulement 1/3 des tables sont correctement gérées (lecture+écriture)
2. **Règle métier RM-001** : Référencée dans le mauvais fichier, pas implémentée
3. **Callees** : 3/5 programmes appelés sont manquants ou partiellement implémentés
4. **UI** : Pas de composant de sélection GO/GM (zoom)

Le code existant est de bonne qualité (error handling, mock data, structure) mais nécessite des compléments pour être conforme à 100% au contrat.