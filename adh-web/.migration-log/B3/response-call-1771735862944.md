```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useCalculEquivalentStore } from '@/stores/calculEquivalentStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ConversionParams, TauxChange } from '@/types/calculEquivalent';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

const MOCK_TAUX_USD: TauxChange = {
  societe: '1',
  devise: 'USD',
  tauxAchat: 0.925,
  tauxVente: 1.08,
  typeDevise: 1,
  dateValidite: '2026-02-22',
  nbDecimales: 2,
};

const MOCK_TAUX_EUR: TauxChange = {
  societe: '1',
  devise: 'EUR',
  tauxAchat: 1,
  tauxVente: 1,
  typeDevise: 0,
  dateValidite: '2026-02-22',
  nbDecimales: 2,
};

const MOCK_TAUX_GBP: TauxChange = {
  societe: '1',
  devise: 'GBP',
  tauxAchat: 1.175,
  tauxVente: 1.29,
  typeDevise: 1,
  dateValidite: '2026-02-22',
  nbDecimales: 2,
};

const MOCK_TAUX_JPY: TauxChange = {
  societe: '1',
  devise: 'JPY',
  tauxAchat: 145.2,
  tauxVente: 145.8,
  typeDevise: 2,
  dateValidite: '2026-02-22',
  nbDecimales: 0,
};

const VALID_PARAMS: ConversionParams = {
  societe: '1',
  uniBi: 'U',
  deviseLocale: 'EUR',
  nombreDecimal: 2,
  devise: 'USD',
  modePaiement: 'ESP',
  quantite: 100,
  typeOperation: 'A',
  typeDevise: 1,
};

describe('calculEquivalentStore', () => {
  beforeEach(() => {
    useCalculEquivalentStore.setState({
      isCalculating: false,
      isValidating: false,
      error: null,
      validationErrors: [],
      lastConversion: null,
      conversionHistory: [],
      maxHistorySize: 20,
    });

    useDataSourceStore.setState({ isRealApi: false });
    vi.clearAllMocks();
  });

  describe('validateConversionParams', () => {
    it('should validate correct params successfully', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();

      const result = await validateConversionParams(VALID_PARAMS);

      expect(result.isValid).toBe(true);
      expect(result.errors).toEqual([]);
    });

    it('should reject when societe is empty', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();
      const invalidParams = { ...VALID_PARAMS, societe: '' };

      const result = await validateConversionParams(invalidParams);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual({
        field: 'societe',
        message: 'La société est requise',
      });
    });

    it('should reject when devise is empty', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();
      const invalidParams = { ...VALID_PARAMS, devise: '' };

      const result = await validateConversionParams(invalidParams);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual({
        field: 'devise',
        message: 'La devise est requise',
      });
    });

    it('should reject when deviseLocale is empty', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();
      const invalidParams = { ...VALID_PARAMS, deviseLocale: '' };

      const result = await validateConversionParams(invalidParams);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual({
        field: 'deviseLocale',
        message: 'La devise locale est requise',
      });
    });

    it('should reject when quantite is zero or negative', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();
      const invalidParams = { ...VALID_PARAMS, quantite: 0 };

      const result = await validateConversionParams(invalidParams);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual({
        field: 'quantite',
        message: 'La quantité doit être supérieure à 0',
      });
    });

    it('should reject when typeOperation is invalid', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();
      const invalidParams = { ...VALID_PARAMS, typeOperation: 'X' as 'A' };

      const result = await validateConversionParams(invalidParams);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual({
        field: 'typeOperation',
        message: "Le type d'opération doit être 'A' (Achat) ou 'V' (Vente)",
      });
    });

    it('should reject when uniBi is invalid', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();
      const invalidParams = { ...VALID_PARAMS, uniBi: 'Z' as 'U' };

      const result = await validateConversionParams(invalidParams);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual({
        field: 'uniBi',
        message: "Le type directionnel doit être 'U' (Unidirectionnel) ou 'B' (Bilateral)",
      });
    });

    it('should reject when modePaiement is empty', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();
      const invalidParams = { ...VALID_PARAMS, modePaiement: '' };

      const result = await validateConversionParams(invalidParams);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual({
        field: 'modePaiement',
        message: 'Le mode de paiement est requis',
      });
    });

    it('should collect multiple validation errors', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();
      const invalidParams = {
        ...VALID_PARAMS,
        societe: '',
        devise: '',
        quantite: -10,
      };

      const result = await validateConversionParams(invalidParams);

      expect(result.isValid).toBe(false);
      expect(result.errors.length).toBeGreaterThanOrEqual(3);
    });

    it('should set isValidating state during validation', async () => {
      const { validateConversionParams } = useCalculEquivalentStore.getState();

      const promise = validateConversionParams(VALID_PARAMS);
      expect(useCalculEquivalentStore.getState().isValidating).toBe(true);

      await promise;
      expect(useCalculEquivalentStore.getState().isValidating).toBe(false);
    });
  });

  describe('getTauxChange', () => {
    it('should return mock taux when using mock data', async () => {
      const { getTauxChange } = useCalculEquivalentStore.getState();

      const result = await getTauxChange({
        societe: '1',
        devise: 'USD',
        typeOperation: 'A',
        uniBi: 'U',
      });

      expect(result).toEqual(MOCK_TAUX_USD);
    });

    it('should throw when devise not found in mock data', async () => {
      const { getTauxChange } = useCalculEquivalentStore.getState();

      await expect(
        getTauxChange({
          societe: '1',
          devise: 'XXX',
          typeOperation: 'A',
          uniBi: 'U',
        })
      ).rejects.toThrow('Taux de change non trouvé pour la devise XXX');
    });

    it('should call API when using real data source', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValue({
        data: { success: true, data: MOCK_TAUX_USD },
      });

      const { getTauxChange } = useCalculEquivalentStore.getState();

      const result = await getTauxChange({
        societe: '1',
        devise: 'USD',
        typeOperation: 'A',
        uniBi: 'U',
      });

      expect(apiClient.get).toHaveBeenCalledWith('/api/change/taux', {
        params: {
          societe: '1',
          devise: 'USD',
          typeOperation: 'A',
          uniBi: 'U',
        },
      });
      expect(result).toEqual(MOCK_TAUX_USD);
    });

    it('should throw when API returns no data', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValue({
        data: { success: true, data: null },
      });

      const { getTauxChange } = useCalculEquivalentStore.getState();

      await expect(
        getTauxChange({
          societe: '1',
          devise: 'USD',
          typeOperation: 'A',
          uniBi: 'U',
        })
      ).rejects.toThrow("Aucun taux de change retourné par l'API");
    });

    it('should throw when API call fails', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValue(new Error('Network error'));

      const { getTauxChange } = useCalculEquivalentStore.getState();

      await expect(
        getTauxChange({
          societe: '1',
          devise: 'USD',
          typeOperation: 'A',
          uniBi: 'U',
        })
      ).rejects.toThrow('Network error');
    });
  });

  describe('calculerEquivalent', () => {
    describe('[RM-001] typeOperation=A ET uniBi<>B: taux achat unidirectionnel', () => {
      it('should apply achat unidirectional rate for USD', async () => {
        const { calculerEquivalent } = useCalculEquivalentStore.getState();
        const params: ConversionParams = {
          ...VALID_PARAMS,
          typeOperation: 'A',
          uniBi: 'U',
          quantite: 100,
        };

        const result = await calculerEquivalent(params);

        expect(result.equivalent).toBe(92.5);
        expect(result.taux).toBe(0.925);
      });

      it('should apply achat unidirectional rate for GBP', async () => {
        const { calculerEquivalent } = useCalculEquivalentStore.getState();
        const params: ConversionParams = {
          ...VALID_PARAMS,
          devise: 'GBP',
          typeOperation: 'A',
          uniBi: 'U',
          quantite: 50,
        };

        const result = await calculerEquivalent(params);

        expect(result.equivalent).toBe(58.75);
        expect(result.taux).toBe(1.175);
      });
    });

    describe('[RM-002] typeOperation=A ET uniBi=B: taux achat bilateral', () => {
      it('should apply bilateral rate for EUR', async () => {
        const { calculerEquivalent } = useCalculEquivalentStore.getState();
        const params: ConversionParams = {
          ...VALID_PARAMS,
          devise: 'EUR',
          typeOperation: 'A',
          uniBi: 'B',
          quantite: 100,
        };

        const result = await calculerEquivalent(params);

        expect(result.equivalent).toBe(100);
        expect(result.taux).toBe(1);
      });

      it('should apply bilateral rate inverse for USD', async () => {
        const { calculerEquivalent } = useCalculEquivalentStore.getState();
        const params: ConversionParams = {
          ...VALID_PARAMS,
          typeOperation: 'A',
          uniBi: 'B',
          quantite: 108,
        };

        const result = await calculerEquivalent(params);

        expect(result.equivalent).toBe(100);
        expect(result.taux).toBe(0.925);
      });
    });

    describe('[RM-003] uniBi<>B: calcul unidirectionnel standard', () => {
      it('should use unidirectional calculation for vente', async () => {
        const { calculerEquivalent } = useCalculEquivalentStore.getState();
        const params: ConversionParams = {
          ...VALID_PARAMS,
          typeOperation: 'V',
          uniBi: 'U',
          quantite: 50,
        };

        const result = await calculerEquivalent(params);

        expect(result.equivalent).toBe(46.25);
      });
    });

    describe('[RM-004] uniBi=B: calcul bilateral', () => {
      it('should use bilateral calculation dividing by taux vente', async () => {
        const { calculerEquivalent } = useCalculEquivalentStore.getState();
        const params: ConversionParams = {
          ...VALID_PARAMS,
          typeOperation: 'V',
          uniBi: 'B',
          quantite: 108,
          nombreDecimal: 2,
        };

        const result = await calculerEquivalent(params);

        expect(result.equivalent).toBe(100);
      });

      it('should handle JPY bilateral with 0 decimals', async () => {
        const { calculerEquivalent } = useCalculEquivalentStore.getState();
        const params: ConversionParams = {
          ...VALID_PARAMS,
          devise: 'JPY',
          typeOperation: 'V',
          uniBi: 'B',
          quantite: 10000,
          nombreDecimal: 0,
        };

        const result = await calculerEquivalent(params);

        expect(result.equivalent).toBe(69);
      });
    });

    describe('[RM-005] typeOperation<>A: logique vente', () => {
      it('should apply vente logic for GBP', async () => {
        const { calculerEquivalent } = useCalculEquivalentStore.getState();
        const params: ConversionParams = {
          ...VALID_PARAMS,
          devise: 'GBP',
          typeOperation: 'V',
          uniBi: 'U',
          quantite: 50,
        };

        const result = await calculerEquivalent(params);

        expect(result.equivalent).toBe(58.75);
        expect(result.taux).toBe(1.175);
      });
    });

    it('should set cdrtDeviseIn based on mode paiement', async () => {
      const { calculerEquivalent } = useCalculEquivalentStore.getState();
      const paramsESP = { ...VALID_PARAMS, modePaiement: 'ESP' };
      const paramsCB = { ...VALID_PARAMS, modePaiement: 'CB' };

      const resultESP = await calculerEquivalent(paramsESP);
      const resultCB = await calculerEquivalent(paramsCB);

      expect(resultESP.cdrtDeviseIn).toBe(true);
      expect(resultCB.cdrtDeviseIn).toBe(false);
    });

    it('should update lastConversion and history on success', async () => {
      const { calculerEquivalent } = useCalculEquivalentStore.getState();

      const result = await calculerEquivalent(VALID_PARAMS);

      const state = useCalculEquivalentStore.getState();
      expect(state.lastConversion).toEqual(result);
      expect(state.conversionHistory[0]).toEqual(result);
      expect(state.conversionHistory.length).toBe(1);
    });

    it('should limit history to maxHistorySize', async () => {
      const { calculerEquivalent } = useCalculEquivalentStore.getState();
      useCalculEquivalentStore.setState({ maxHistorySize: 3 });

      for (let i = 0; i < 5; i++) {
        await calculerEquivalent({ ...VALID_PARAMS, quantite: 100 + i });
      }

      const state = useCalculEquivalentStore.getState();
      expect(state.conversionHistory.length).toBe(3);
    });

    it('should set isCalculating during calculation', async () => {
      const { calculerEquivalent } = useCalculEquivalentStore.getState();

      const promise = calculerEquivalent(VALID_PARAMS);
      expect(useCalculEquivalentStore.getState().isCalculating).toBe(true);

      await promise;
      expect(useCalculEquivalentStore.getState().isCalculating).toBe(false);
    });

    it('should throw and set error when validation fails', async () => {
      const { calculerEquivalent } = useCalculEquivalentStore.getState();
      const invalidParams = { ...VALID_PARAMS, societe: '' };

      await expect(calculerEquivalent(invalidParams)).rejects.toThrow(
        'Paramètres de conversion invalides'
      );

      const state = useCalculEquivalentStore.getState();
      expect(state.error).toBe('Paramètres invalides');
      expect(state.isCalculating).toBe(false);
    });

    it('should throw when taux not found in mock', async () => {
      const { calculerEquivalent } = useCalculEquivalentStore.getState();
      const params = { ...VALID_PARAMS, devise: 'XXX' };

      await expect(calculerEquivalent(params)).rejects.toThrow(
        'Taux de change non trouvé pour XXX'
      );

      const state = useCalculEquivalentStore.getState();
      expect(state.error).toContain('Taux de change non trouvé');
      expect(state.isCalculating).toBe(false);
    });

    it('should call API when using real data source', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResult = {
        equivalent: 92.5,
        cdrtDeviseIn: true,
        taux: 0.925,
        quantiteOriginale: 100,
        deviseOriginale: 'USD',
        deviseLocale: 'EUR',
      };

      vi.mocked(apiClient.post).mockResolvedValue({
        data: { success: true, data: mockResult },
      });

      const { calculerEquivalent } = useCalculEquivalentStore.getState();

      const result = await calculerEquivalent(VALID_PARAMS);

      expect(apiClient.post).toHaveBeenCalledWith('/api/change/calculer-equivalent', {
        params: VALID_PARAMS,
      });
      expect(result).toEqual(mockResult);
    });

    it('should throw when API returns no result', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValue({
        data: { success: true, data: null },
      });

      const { calculerEquivalent } = useCalculEquivalentStore.getState();

      await expect(calculerEquivalent(VALID_PARAMS)).rejects.toThrow(
        'Aucun résultat de conversion retourné'
      );
    });

    it('should throw when API call fails', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValue(new Error('API failure'));

      const { calculerEquivalent } = useCalculEquivalentStore.getState();

      await expect(calculerEquivalent(VALID_PARAMS)).rejects.toThrow('API failure');

      const state = useCalculEquivalentStore.getState();
      expect(state.error).toBe('API failure');
    });
  });

  describe('clearError', () => {
    it('should clear error and validationErrors', () => {
      useCalculEquivalentStore.setState({
        error: 'Test error',
        validationErrors: [{ field: 'societe', message: 'Invalid' }],
      });

      const { clearError } = useCalculEquivalentStore.getState();
      clearError();

      const state = useCalculEquivalentStore.getState();
      expect(state.error).toBeNull();
      expect(state.validationErrors).toEqual([]);
    });
  });

  describe('clearHistory', () => {
    it('should clear conversion history and lastConversion', async () => {
      const { calculerEquivalent, clearHistory } = useCalculEquivalentStore.getState();

      await calculerEquivalent(VALID_PARAMS);
      expect(useCalculEquivalentStore.getState().conversionHistory.length).toBe(1);

      clearHistory();

      const state = useCalculEquivalentStore.getState();
      expect(state.conversionHistory).toEqual([]);
      expect(state.lastConversion).toBeNull();
    });
  });

  describe('resetState', () => {
    it('should reset all state to initial values', async () => {
      const { calculerEquivalent, resetState } = useCalculEquivalentStore.getState();

      await calculerEquivalent(VALID_PARAMS);
      useCalculEquivalentStore.setState({ error: 'Test error' });

      resetState();

      const state = useCalculEquivalentStore.getState();
      expect(state.isCalculating).toBe(false);
      expect(state.isValidating).toBe(false);
      expect(state.error).toBeNull();
      expect(state.validationErrors).toEqual([]);
      expect(state.lastConversion).toBeNull();
      expect(state.conversionHistory).toEqual([]);
      expect(state.maxHistorySize).toBe(20);
    });
  });
});
```