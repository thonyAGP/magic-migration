```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useEmailSearchStore } from '@/stores/emailSearchStore';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type { ApiResponse } from '@/services/api/apiClient';
import type {
  CreateEmailDto,
  UpdateEmailDto,
  GetEmailsResponse,
  CreateEmailResponse,
  UpdateEmailResponse,
  DeleteEmailResponse,
  SetPrincipalResponse,
  SearchFilters,
  EmailAddress,
} from '@/types/emailSearch';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(),
  },
}));

const MOCK_EMAIL_1: EmailAddress = {
  id: 1,
  societe: 'SKI',
  compte: '100001',
  filiation: 0,
  email: 'jean.dupont@email.com',
  isPrincipal: true,
  createdAt: new Date('2026-01-15T10:30:00'),
  updatedAt: new Date('2026-02-10T14:20:00'),
};

const MOCK_EMAIL_2: EmailAddress = {
  id: 2,
  societe: 'SKI',
  compte: '100001',
  filiation: 0,
  email: 'contact@dupont-family.fr',
  isPrincipal: false,
  createdAt: new Date('2026-01-20T09:15:00'),
  updatedAt: null,
};

const MOCK_EMAIL_3: EmailAddress = {
  id: 3,
  societe: 'EXCHANGE',
  compte: '100002',
  filiation: 1,
  email: 'marie.bernard@email.com',
  isPrincipal: true,
  createdAt: new Date('2026-01-08T10:00:00'),
  updatedAt: null,
};

const MOCK_EMAILS = [MOCK_EMAIL_1, MOCK_EMAIL_2, MOCK_EMAIL_3];

describe('emailSearchStore', () => {
  beforeEach(() => {
    useEmailSearchStore.getState().resetState();
    vi.clearAllMocks();
  });

  describe('searchEmails', () => {
    it('should fetch emails from API when isRealApi is true', async () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '100001',
        filiation: null,
        email: '',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValue({
        data: {
          success: true,
          data: { data: MOCK_EMAILS, count: MOCK_EMAILS.length },
        },
      } as ApiResponse<GetEmailsResponse>);

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(apiClient.get).toHaveBeenCalledWith('/api/email-search/emails', {
        params: { societe: 'SKI', compte: '100001' },
      });
      expect(store.emails).toEqual(MOCK_EMAILS);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe(null);
    });

    it('should filter mock emails when isRealApi is false', async () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: '',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(apiClient.get).not.toHaveBeenCalled();
      expect(store.emails.length).toBeGreaterThan(0);
      expect(store.emails.every((e) => e.societe === 'SKI' && e.compte === '100001')).toBe(true);
      expect(store.isLoading).toBe(false);
    });

    it('should filter by email pattern when isRealApi is false', async () => {
      const filters: SearchFilters = {
        societe: '',
        compte: '',
        filiation: null,
        email: 'contact',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(store.emails.every((e) => e.email.toLowerCase().includes('contact'))).toBe(true);
    });

    it('should set error when API call fails', async () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '',
        filiation: null,
        email: '',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockRejectedValue(new Error('Network error'));

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(store.emails).toEqual([]);
      expect(store.error).toBe('Network error');
      expect(store.isLoading).toBe(false);
    });

    it('should handle all filter criteria in API mode', async () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: 'jean',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValue({
        data: {
          success: true,
          data: { data: [MOCK_EMAIL_1], count: 1 },
        },
      } as ApiResponse<GetEmailsResponse>);

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(apiClient.get).toHaveBeenCalledWith('/api/email-search/emails', {
        params: { societe: 'SKI', compte: '100001', filiation: '0', email: 'jean' },
      });
    });
  });

  describe('createEmail', () => {
    it('should create email via API when isRealApi is true', async () => {
      const newEmail: CreateEmailDto = {
        societe: 'SKI',
        compte: '100003',
        filiation: 0,
        email: 'new@test.com',
        isPrincipal: false,
      };

      const createdEmail: EmailAddress = {
        id: 99,
        ...newEmail,
        isPrincipal: false,
        createdAt: new Date(),
        updatedAt: null,
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockResolvedValue({
        data: {
          success: true,
          data: { data: createdEmail },
        },
      } as ApiResponse<CreateEmailResponse>);

      const store = useEmailSearchStore.getState();
      await store.createEmail(newEmail);

      expect(apiClient.post).toHaveBeenCalledWith('/api/email-search/emails', newEmail);
      expect(store.emails).toContainEqual(createdEmail);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe(null);
    });

    it('should create email in mock mode and unset previous principal if isPrincipal is true', async () => {
      const newEmail: CreateEmailDto = {
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: 'new-principal@test.com',
        isPrincipal: true,
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.createEmail(newEmail);

      expect(store.emails.some((e) => e.email === 'new-principal@test.com' && e.isPrincipal)).toBe(true);
      expect(store.isLoading).toBe(false);
    });

    it('should set error when API creation fails', async () => {
      const newEmail: CreateEmailDto = {
        societe: 'SKI',
        compte: '100003',
        filiation: 0,
        email: 'fail@test.com',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockRejectedValue(new Error('Validation error'));

      const store = useEmailSearchStore.getState();
      await store.createEmail(newEmail);

      expect(store.error).toBe('Validation error');
      expect(store.isLoading).toBe(false);
    });

    it('should set createdAt timestamp when creating in mock mode', async () => {
      const beforeCreate = new Date();

      const newEmail: CreateEmailDto = {
        societe: 'SKI',
        compte: '100003',
        filiation: 0,
        email: 'timestamped@test.com',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.createEmail(newEmail);

      const created = store.emails.find((e) => e.email === 'timestamped@test.com');
      expect(created).toBeDefined();
      expect(created!.createdAt).toBeInstanceOf(Date);
      expect(created!.createdAt!.getTime()).toBeGreaterThanOrEqual(beforeCreate.getTime());
    });
  });

  describe('updateEmail', () => {
    it('should update email via API when isRealApi is true', async () => {
      const updateData: UpdateEmailDto = {
        email: 'updated@email.com',
      };

      const updatedEmail: EmailAddress = {
        ...MOCK_EMAIL_1,
        email: 'updated@email.com',
        updatedAt: new Date(),
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.put).mockResolvedValue({
        data: {
          success: true,
          data: { data: updatedEmail },
        },
      } as ApiResponse<UpdateEmailResponse>);

      const store = useEmailSearchStore.getState();
      store.emails = [MOCK_EMAIL_1];
      await store.updateEmail(1, updateData);

      expect(apiClient.put).toHaveBeenCalledWith('/api/email-search/emails/1', updateData);
      expect(store.emails[0].email).toBe('updated@email.com');
      expect(store.isLoading).toBe(false);
    });

    it('should update email in mock mode and set updatedAt timestamp', async () => {
      const updateData: UpdateEmailDto = {
        email: 'updated-mock@email.com',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.updateEmail(1, updateData);

      const updated = store.emails.find((e) => e.id === 1);
      expect(updated?.email).toBe('updated-mock@email.com');
      expect(updated?.updatedAt).toBeInstanceOf(Date);
    });

    it('should unset other principals when updating isPrincipal to true in mock mode', async () => {
      const updateData: UpdateEmailDto = {
        isPrincipal: true,
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.updateEmail(2, updateData);

      const updated = store.emails.find((e) => e.id === 2);
      expect(updated?.isPrincipal).toBe(true);
    });

    it('should set error when email not found in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.updateEmail(999, { email: 'test@email.com' });

      expect(store.error).toBe('Email introuvable');
      expect(store.isLoading).toBe(false);
    });

    it('should set error when API update fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.put).mockRejectedValue(new Error('Update failed'));

      const store = useEmailSearchStore.getState();
      await store.updateEmail(1, { email: 'fail@email.com' });

      expect(store.error).toBe('Update failed');
      expect(store.isLoading).toBe(false);
    });
  });

  describe('deleteEmail', () => {
    it('should delete email via API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.delete).mockResolvedValue({
        data: {
          success: true,
          data: { success: true },
        },
      } as ApiResponse<DeleteEmailResponse>);

      const store = useEmailSearchStore.getState();
      store.emails = [MOCK_EMAIL_1, MOCK_EMAIL_2];
      await store.deleteEmail(1);

      expect(apiClient.delete).toHaveBeenCalledWith('/api/email-search/emails/1');
      expect(store.emails).toHaveLength(1);
      expect(store.emails[0].id).toBe(2);
      expect(store.isLoading).toBe(false);
    });

    it('should delete email in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      const initialCount = store.emails.length;
      await store.deleteEmail(1);

      expect(store.emails.length).toBeLessThan(initialCount);
      expect(store.emails.find((e) => e.id === 1)).toBeUndefined();
    });

    it('should set error when email not found in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.deleteEmail(999);

      expect(store.error).toBe('Email introuvable');
      expect(store.isLoading).toBe(false);
    });

    it('should set error when API deletion fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.delete).mockRejectedValue(new Error('Delete failed'));

      const store = useEmailSearchStore.getState();
      await store.deleteEmail(1);

      expect(store.error).toBe('Delete failed');
      expect(store.isLoading).toBe(false);
    });
  });

  describe('setAsPrincipal', () => {
    it('should set email as principal via API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockResolvedValue({
        data: {
          success: true,
          data: { success: true },
        },
      } as ApiResponse<SetPrincipalResponse>);

      const store = useEmailSearchStore.getState();
      store.emails = [MOCK_EMAIL_1, MOCK_EMAIL_2];
      await store.setAsPrincipal(2);

      expect(apiClient.post).toHaveBeenCalledWith('/api/email-search/emails/2/set-principal');
      expect(store.emails.find((e) => e.id === 2)?.isPrincipal).toBe(true);
      expect(store.emails.find((e) => e.id === 1)?.isPrincipal).toBe(false);
      expect(store.isLoading).toBe(false);
    });

    it('should unset previous principal when setting new principal in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.setAsPrincipal(2);

      const emailsWithSameGM = store.emails.filter(
        (e) => e.societe === 'SKI' && e.compte === '100001' && e.filiation === 0,
      );
      const principalCount = emailsWithSameGM.filter((e) => e.isPrincipal).length;
      expect(principalCount).toBe(1);
      expect(store.emails.find((e) => e.id === 2)?.isPrincipal).toBe(true);
    });

    it('should set error when email not found in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.setAsPrincipal(999);

      expect(store.error).toBe('Email introuvable');
      expect(store.isLoading).toBe(false);
    });

    it('should set error when API call fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockRejectedValue(new Error('Principal update failed'));

      const store = useEmailSearchStore.getState();
      await store.setAsPrincipal(1);

      expect(store.error).toBe('Principal update failed');
      expect(store.isLoading).toBe(false);
    });

    it('should only affect emails with same GM identifier (societe+compte+filiation)', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.setAsPrincipal(2);

      const otherGMEmail = store.emails.find((e) => e.societe === 'EXCHANGE' && e.compte === '100002');
      expect(otherGMEmail?.isPrincipal).toBe(true);
    });
  });

  describe('selectEmail', () => {
    it('should set selected email', () => {
      const store = useEmailSearchStore.getState();
      store.selectEmail(MOCK_EMAIL_1);

      expect(store.selectedEmail).toEqual(MOCK_EMAIL_1);
    });

    it('should clear selected email when passed null', () => {
      const store = useEmailSearchStore.getState();
      store.selectEmail(MOCK_EMAIL_1);
      store.selectEmail(null);

      expect(store.selectedEmail).toBe(null);
    });
  });

  describe('setFilters', () => {
    it('should update filters', () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: 'test',
      };

      const store = useEmailSearchStore.getState();
      store.setFilters(filters);

      expect(store.filters).toEqual(filters);
    });
  });

  describe('clearFilters', () => {
    it('should reset all filters to initial state', () => {
      const store = useEmailSearchStore.getState();
      store.setFilters({
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: 'test',
      });
      store.clearFilters();

      expect(store.filters).toEqual({
        societe: '',
        compte: '',
        filiation: null,
        email: '',
      });
    });
  });

  describe('resetState', () => {
    it('should reset entire store to initial state', () => {
      const store = useEmailSearchStore.getState();
      store.emails = MOCK_EMAILS;
      store.selectedEmail = MOCK_EMAIL_1;
      store.error = 'Some error';
      store.setFilters({ societe: 'SKI', compte: '100001', filiation: 0, email: 'test' });

      store.resetState();

      expect(store.emails).toEqual([]);
      expect(store.selectedEmail).toBe(null);
      expect(store.error).toBe(null);
      expect(store.filters).toEqual({
        societe: '',
        compte: '',
        filiation: null,
        email: '',
      });
      expect(store.isLoading).toBe(false);
    });
  });
});
```