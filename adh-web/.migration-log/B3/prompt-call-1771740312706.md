Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
fidelisationRemiseStore getFidelisationRemise should fetch and calculate remise for valid GOLD fidelisation (mock): AssertionError: expected null to deeply equal { societe: 'SOC1', compte: 1001, â€¦(5) }
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:58:32
    at processTicksAn
fidelisationRemiseStore getFidelisationRemise should handle EXPIRED fidelisation as invalid (mock): AssertionError: expected null to deeply equal { societe: 'SOC1', compte: 1004, â€¦(5) }
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:71:32
    at processTicksAn
fidelisationRemiseStore getFidelisationRemise should handle no fidelisation program (mock): AssertionError: expected null to deeply equal { societe: 'SOC1', compte: 1005, â€¦(5) }
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:84:32
    at processTicksAn
fidelisationRemiseStore getFidelisationRemise should fetch from API when isRealApi is true: AssertionError: expected "vi.fn()" to be called with arguments: [ Array(2) ][90m

Number of calls: [1m0[22m
[39m
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.p
fidelisationRemiseStore getFidelisationRemise should handle API error: AssertionError: expected null to be 'Network error' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:146:27
    at processTicksAndRejections
fidelisationRemiseStore getFidelisationRemise should set loading state during fetch: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:156:63
    at file:///D:/Projects/Lecteur_Magic/a
fidelisationRemiseStore validateRemiseEligibility should validate eligible remise (mock): AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:167:23
    at file:///D:/Projects/Lecteur_Magic/a
fidelisationRemiseStore validateRemiseEligibility should call API when isRealApi is true: AssertionError: expected "vi.fn()" to be called with arguments: [ â€¦(2) ][90m

Number of calls: [1m0[22m
[39m
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.pnpm/
fidelisationRemiseStore validateRemiseEligibility should handle API error during validation: AssertionError: expected null to be 'Validation failed' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:221:59
    at file:///D:/Projects/L
fidelisationRemiseStore calculateMontantRemise should calculate remise amount for valid data (mock): AssertionError: expected +0 to be 15 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:229:23
    at file:///D:/Projects/Lecteur_Magic/adh-we
fidelisationRemiseStore calculateMontantRemise should call API when isRealApi is true: AssertionError: expected "vi.fn()" to be called with arguments: [ â€¦(2) ][90m

Number of calls: [1m0[22m
[39m
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.pnpm/
fidelisationRemiseStore calculateMontantRemise should handle API error during calculation: AssertionError: expected null to be 'Calculation failed' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:272:59
    at file:///D:/Projects/
fidelisationRemiseStore setError should set error message: AssertionError: expected null to be 'Custom error' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:295:59
    at file:///D:/Projects/Lecteu
fidelisationRemiseStore setError should clear error when null: AssertionError: expected 'Existing error' to be null
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:303:59
    at file:///D:/Projects/Lecteur_Magic/adh-web/node
fidelisationRemiseStore reset should reset store to initial state: AssertionError: expected true to be false // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:324:31
    at file:///D:/Projects/Lecteur_Magic/a
fidelisationRemiseStore business rules should apply configured remise rules and thresholds: AssertionError: expected 'GOLD' to be 'SILVER' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/fidelisationRemiseStore.test.ts:354:42
    at file:///D:/Projects/Lecteur_Ma

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useFidelisationRemiseStore } from '@/stores/fidelisationRemiseStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { FidelisationRemise } from '@/types/fidelisationRemise';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

const MOCK_GOLD_REMISE: FidelisationRemise = {
  societe: 'SOC1',
  compte: 1001,
  filiation: 0,
  service: 'RST',
  imputation: 101,
  fidelisation: 'GOLD',
  remise: 15,
};

const MOCK_EXPIRED_REMISE: FidelisationRemise = {
  societe: 'SOC1',
  compte: 1004,
  filiation: 0,
  service: 'BAR',
  imputation: 104,
  fidelisation: 'EXPIRED',
  remise: null,
};

const MOCK_NO_FIDELISATION: FidelisationRemise = {
  societe: 'SOC1',
  compte: 1005,
  filiation: 0,
  service: 'RST',
  imputation: 105,
  fidelisation: null,
  remise: null,
};

describe('fidelisationRemiseStore', () => {
  beforeEach(() => {
    useFidelisationRemiseStore.getState().reset();
    vi.clearAllMocks();
    useDataSourceStore.setState({ isRealApi: false });
  });

  describe('getFidelisationRemise', () => {
    it('should fetch and calculate remise for valid GOLD fidelisation (mock)', async () => {
      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);

      const state = useFidelisationRemiseStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.remiseData).toEqual(MOCK_GOLD_REMISE);
      expect(state.remiseResult).toEqual({
        fidelisationId: 'GOLD',
        montantRemise: 15,
        isValide: true,
        message: null,
      });
    });

    it('should handle EXPIRED fidelisation as invalid (mock)', async () => {
      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1004, 0, 'BAR', 104);

      const state = useFidelisationRemiseStore.getState();
      expect(state.remiseData).toEqual(MOCK_EXPIRED_REMISE);
      expect(state.remiseResult).toEqual({
        fidelisationId: 'EXPIRED',
        montantRemise: 0,
        isValide: false,
        message: 'Programme de fidelisation expire',
      });
    });

    it('should handle no fidelisation program (mock)', async () => {
      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1005, 0, 'RST', 105);

      const state = useFidelisationRemiseStore.getState();
      expect(state.remiseData).toEqual(MOCK_NO_FIDELISATION);
      expect(state.remiseResult).toEqual({
        fidelisationId: null,
        montantRemise: 0,
        isValide: false,
        message: 'Aucun programme de fidelisation actif',
      });
    });

    it('should handle non-existent compte (mock)', async () => {
      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 9999, 0, 'RST', 999);

      const state = useFidelisationRemiseStore.getState();
      expect(state.remiseData).toBeNull();
      expect(state.remiseResult).toBeNull();
    });

    it('should fetch from API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      const mockApiResponse = {
        data: {
          data: {
            fidelisationId: 'PLATINUM',
            montantRemise: 20,
            isValide: true,
            message: null,
          },
          success: true,
        },
      };

      vi.mocked(apiClient.get).mockResolvedValueOnce(mockApiResponse);

      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC2', 2001, 0, 'SPA', 201);

      const state = useFidelisationRemiseStore.getState();
      expect(apiClient.get).toHaveBeenCalledWith('/api/fidelisation-remise/get', {
        params: {
          societe: 'SOC2',
          compte: 2001,
          filiation: 0,
          service: 'SPA',
          imputation: 201,
        },
      });
      expect(state.remiseResult).toEqual({
        fidelisationId: 'PLATINUM',
        montantRemise: 20,
        isValide: true,
        message: null,
      });
    });

    it('should handle API error', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Network error'));

      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);

      const state = useFidelisationRemiseStore.getState();
      expect(state.error).toBe('Network error');
      expect(state.remiseData).toBeNull();
      expect(state.remiseResult).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should set loading state during fetch', async () => {
      const promise = useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);
      
      await new Promise(resolve => setTimeout(resolve, 0));
      expect(useFidelisationRemiseStore.getState().isLoading).toBe(true);

      await promise;
      expect(useFidelisationRemiseStore.getState().isLoading).toBe(false);
    });
  });

  describe('validateRemiseEligibility', () => {
    it('should validate eligible remise (mock)', async () => {
      const isValid = await useFidelisationRemiseStore.getState().validateRemiseEligibility(MOCK_GOLD_REMISE);

      expect(isValid).toBe(true);
      expect(useFidelisationRemiseStore.getState().isLoading).toBe(false);
      expect(useFidelisationRemiseStore.getState().error).toBeNull();
    });

    it('should reject expired fidelisation (mock)', async () => {
      const isValid = await useFidelisationRemiseStore.getState().validateRemiseEligibility(MOCK_EXPIRED_REMISE);

      expect(isValid).toBe(false);
    });

    it('should reject remise with no fidelisation (mock)', async () => {
      const isValid = await useFidelisationRemiseStore.getState().validateRemiseEligibility(MOCK_NO_FIDELISATION);

      expect(isValid).toBe(false);
    });

    it('should reject remise with zero amount (mock)', async () => {
      const zeroRemise: FidelisationRemise = {
        ...MOCK_GOLD_REMISE,
        remise: 0,
      };

      const isValid = await useFidelisationRemiseStore.getState().validateRemiseEligibility(zeroRemise);

      expect(isValid).toBe(false);
    });

    it('should call API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: {
          data: { isValide: true },
          success: true,
        },
      });

      const isValid = await useFidelisationRemiseStore.getState().validateRemiseEligibility(MOCK_GOLD_REMISE);

      expect(apiClient.post).toHaveBeenCalledWith('/api/fidelisation-remise/validate', {
        remiseData: MOCK_GOLD_REMISE,
      });
      expect(isValid).toBe(true);
    });

    it('should handle API error during validation', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Validation failed'));

      const isValid = await useFidelisationRemiseStore.getState().validateRemiseEligibility(MOCK_GOLD_REMISE);

      expect(isValid).toBe(false);
      expect(useFidelisationRemiseStore.getState().error).toBe('Validation failed');
    });
  });

  describe('calculateMontantRemise', () => {
    it('should calculate remise amount for valid data (mock)', async () => {
      const montant = await useFidelisationRemiseStore.getState().calculateMontantRemise(MOCK_GOLD_REMISE);

      expect(montant).toBe(15);
      expect(useFidelisationRemiseStore.getState().isLoading).toBe(false);
      expect(useFidelisationRemiseStore.getState().error).toBeNull();
    });

    it('should return 0 for expired fidelisation (mock)', async () => {
      const montant = await useFidelisationRemiseStore.getState().calculateMontantRemise(MOCK_EXPIRED_REMISE);

      expect(montant).toBe(0);
    });

    it('should return 0 for no fidelisation (mock)', async () => {
      const montant = await useFidelisationRemiseStore.getState().calculateMontantRemise(MOCK_NO_FIDELISATION);

      expect(montant).toBe(0);
    });

    it('should call API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: {
          data: { montantRemise: 25 },
          success: true,
        },
      });

      const montant = await useFidelisationRemiseStore.getState().calculateMontantRemise(MOCK_GOLD_REMISE);

      expect(apiClient.post).toHaveBeenCalledWith('/api/fidelisation-remise/calculate', {
        remiseData: MOCK_GOLD_REMISE,
      });
      expect(montant).toBe(25);
    });

    it('should handle API error during calculation', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Calculation failed'));

      const montant = await useFidelisationRemiseStore.getState().calculateMontantRemise(MOCK_GOLD_REMISE);

      expect(montant).toBe(0);
      expect(useFidelisationRemiseStore.getState().error).toBe('Calculation failed');
    });

    it('should return 0 when API returns no data', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: {
          data: undefined,
          success: true,
        },
      });

      const montant = await useFidelisationRemiseStore.getState().calculateMontantRemise(MOCK_GOLD_REMISE);

      expect(montant).toBe(0);
    });
  });

  describe('setError', () => {
    it('should set error message', () => {
      useFidelisationRemiseStore.getState().setError('Custom error');

      expect(useFidelisationRemiseStore.getState().error).toBe('Custom error');
    });

    it('should clear error when null', () => {
      useFidelisationRemiseStore.setState({ error: 'Existing error' });

      useFidelisationRemiseStore.getState().setError(null);

      expect(useFidelisationRemiseStore.getState().error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', () => {
      useFidelisationRemiseStore.setState({
        isLoading: true,
        error: 'Some error',
        remiseData: MOCK_GOLD_REMISE,
        remiseResult: {
          fidelisationId: 'GOLD',
          montantRemise: 15,
          isValide: true,
          message: null,
        },
      });

      useFidelisationRemiseStore.getState().reset();

      const state = useFidelisationRemiseStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.remiseData).toBeNull();
      expect(state.remiseResult).toBeNull();
    });
  });

  describe('business rules', () => {
    it('should validate remise is not used twice in same period', async () => {
      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);
      const firstResult = useFidelisationRemiseStore.getState().remiseResult;

      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);
      const secondResult = useFidelisationRemiseStore.getState().remiseResult;

      expect(firstResult).toEqual(secondResult);
    });

    it('should verify remise conforms to client profile', async () => {
      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1001, 0, 'RST', 101);
      const goldRemise = useFidelisationRemiseStore.getState().remiseData;

      expect(goldRemise?.fidelisation).toBe('GOLD');
      expect(goldRemise?.remise).toBe(15);
    });

    it('should apply configured remise rules and thresholds', async () => {
      await useFidelisationRemiseStore.getState().getFidelisationRemise('SOC1', 1002, 0, 'BTQ', 102);
      const silverRemise = useFidelisationRemiseStore.getState().remiseData;

      expect(silverRemise?.fidelisation).toBe('SILVER');
      expect(silverRemise?.remise).toBe(10);
      expect((silverRemise?.remise ?? 0) < 15).toBe(true);
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  FidelisationRemise,
  RemiseResult,
  FidelisationRemiseState,
} from '@/types/fidelisationRemise';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

interface FidelisationRemiseActions {
  getFidelisationRemise: (
    societe: string,
    compte: number,
    filiation: number,
    service: string,
    imputation: number,
  ) => Promise<void>;
  validateRemiseEligibility: (remiseData: FidelisationRemise) => Promise<boolean>;
  calculateMontantRemise: (remiseData: FidelisationRemise) => Promise<number>;
  setError: (error: string | null) => void;
  reset: () => void;
}

type FidelisationRemiseStore = FidelisationRemiseState & FidelisationRemiseActions;

const MOCK_REMISE_DATA: FidelisationRemise[] = [
  {
    societe: 'SOC1',
    compte: 1001,
    filiation: 0,
    service: 'RST',
    imputation: 101,
    fidelisation: 'GOLD',
    remise: 15,
  },
  {
    societe: 'SOC1',
    compte: 1002,
    filiation: 0,
    service: 'BTQ',
    imputation: 102,
    fidelisation: 'SILVER',
    remise: 10,
  },
  {
    societe: 'SOC1',
    compte: 1003,
    filiation: 1,
    service: 'SPA',
    imputation: 103,
    fidelisation: 'BRONZE',
    remise: 5,
  },
  {
    societe: 'SOC1',
    compte: 1004,
    filiation: 0,
    service: 'BAR',
    imputation: 104,
    fidelisation: 'EXPIRED',
    remise: null,
  },
  {
    societe: 'SOC1',
    compte: 1005,
    filiation: 0,
    service: 'RST',
    imputation: 105,
    fidelisation: null,
    remise: null,
  },
];

const calculateRemiseResult = (data: FidelisationRemise | null): RemiseResult | null => {
  if (!data) return null;

  if (!data.fidelisation) {
    return {
      fidelisationId: null,
      montantRemise: 0,
      isValide: false,
      message: 'Aucun programme de fidelisation actif',
    };
  }

  if (data.fidelisation === 'EXPIRED') {
    return {
      fidelisationId: data.fidelisation,
      montantRemise: 0,
      isValide: false,
      message: 'Programme de fidelisation expire',
    };
  }

  if (!data.remise || data.remise <= 0) {
    return {
      fidelisationId: data.fidelisation,
      montantRemise: 0,
      isValide: false,
      message: 'Aucune remise disponible pour ce profil',
    };
  }

  return {
    fidelisationId: data.fidelisation,
    montantRemise: data.remise,
    isValide: true,
    message: null,
  };
};

const initialState: FidelisationRemiseState = {
  isLoading: false,
  error: null,
  remiseData: null,
  remiseResult: null,
  getFidelisationRemise: async () => {},
  validateRemiseEligibility: async () => false,
  calculateMontantRemise: async () => 0,
  setError: () => {},
  reset: () => {},
};

export const useFidelisationRemiseStore = create<FidelisationRemiseStore>()((set, get) => ({
  ...initialState,

  getFidelisationRemise: async (societe, compte, filiation, service, imputation) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const mockData = MOCK_REMISE_DATA.find(
        (d) =>
          d.societe === societe &&
          d.compte === compte &&
          d.filiation === filiation &&
          d.service === service &&
          d.imputation === imputation,
      );

      const result = calculateRemiseResult(mockData ?? null);
      set({
        remiseData: mockData ?? null,
        remiseResult: result,
        isLoading: false,
      });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<RemiseResult>>(
        '/api/fidelisation-remise/get',
        {
          params: { societe, compte, filiation, service, imputation },
        },
      );

      const remiseData: FidelisationRemise = {
        societe,
        compte,
        filiation,
        service,
        imputation,
        fidelisation: response.data.data?.fidelisationId ?? null,
        remise: response.data.data?.montantRemise ?? null,
      };

      set({
        remiseData,
        remiseResult: response.data.data ?? null,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement fidelisation';
      set({ remiseData: null, remiseResult: null, error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  validateRemiseEligibility: async (remiseData) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const isValid = !!(
        remiseData.fidelisation &&
        remiseData.fidelisation !== 'EXPIRED' &&
        remiseData.remise &&
        remiseData.remise > 0
      );
      set({ isLoading: false });
      return isValid;
    }

    try {
      const response = await apiClient.post<
        ApiResponse<{ isValide: boolean; message?: string }>
      >('/api/fidelisation-remise/validate', { remiseData });

      set({ isLoading: false });
      return response.data.data?.isValide ?? false;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation remise';
      set({ error: message, isLoading: false });
      return false;
    }
  },

  calculateMontantRemise: async (remiseData) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const montant = remiseData.remise ?? 0;
      set({ isLoading: false });
      return montant;
    }

    try {
      const response = await apiClient.post<ApiResponse<{ montantRemise: number }>>(
        '/api/fidelisation-remise/calculate',
        { remiseData },
      );

      set({ isLoading: false });
      return response.data.data?.montantRemise ?? 0;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur calcul montant';
      set({ error: message, isLoading: false });
      return 0;
    }
  },

  setError: (error) => {
    set({ error });
  },

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.