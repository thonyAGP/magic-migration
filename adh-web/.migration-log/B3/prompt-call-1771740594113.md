Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/recapWorksheetStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
recapWorksheetStore calculateSummary should calculate total general: AssertionError: expected 10378.990000000002 to be 10378.99 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/recapWorksheetStore.test.ts:208:36
    at file:///D:/Projects/Le
recapWorksheetStore generateRecapWorksheet should generate recap with mock data when isRealApi is false: AssertionError: expected 10378.990000000002 to be 10378.99 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/recapWorksheetStore.test.ts:240:36
    at processTicksAndRejecti
recapWorksheetStore exportRecapWorksheet should export as txt format with mock data: AssertionError: expected '[object Blob]' to contain 'RECAP WORKSHEET SESSION 1001'
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/recapWorksheetStore.test.ts:317:20
    at file:///D:/Projects/
recapWorksheetStore exportRecapWorksheet should export as csv format with mock data: AssertionError: expected '[object Blob]' to contain 'Type,Devise,Montant'
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/recapWorksheetStore.test.ts:329:20
    at file:///D:/Projects/Lecteur_M
recapWorksheetStore exportRecapWorksheet should export as json format with mock data: SyntaxError: Unexpected token 'o', "[object Blob]" is not valid JSON
    at JSON.parse (<anonymous>)
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/recapWorksheetStore.test.ts:341:27
    at fi

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useRecapWorksheetStore } from '@/stores/recapWorksheetStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { RecapWorksheetEntry, RecapWorksheetSummary } from '@/types/recapWorksheet';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

const MOCK_ENTRIES: RecapWorksheetEntry[] = [
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'vente',
    typeApproVersCoffre: null,
    modePaiement: 'especes',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 1250.0,
    montantMonnaie: 1250.0,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 101,
    sousImputation: 1,
    libelle: 'Ventes espèces session matinale',
    libelleComplementaire: null,
    nomGm: 'MARTIN Sophie',
    quantiteArticle: 15,
    prixArticle: 83.33,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'vente',
    typeApproVersCoffre: null,
    modePaiement: 'carte',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 3450.0,
    montantMonnaie: null,
    montantProduits: null,
    montantCartes: 3450.0,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 102,
    sousImputation: 1,
    libelle: 'Ventes carte session matinale',
    libelleComplementaire: 'CB/Visa',
    nomGm: 'MARTIN Sophie',
    quantiteArticle: 28,
    prixArticle: 123.21,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'change',
    typeApproVersCoffre: null,
    modePaiement: 'especes',
    avecChange: 'O',
    codeDevise: 'USD',
    quantiteDevise: 500.0,
    tauxDevise: 1.12,
    montant: 446.43,
    montantMonnaie: 446.43,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 201,
    sousImputation: 1,
    libelle: 'Opération change USD',
    libelleComplementaire: 'Achat USD contre EUR',
    nomGm: 'MARTIN Sophie',
    quantiteArticle: null,
    prixArticle: null,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'change',
    typeApproVersCoffre: null,
    modePaiement: 'especes',
    avecChange: 'O',
    codeDevise: 'GBP',
    quantiteDevise: 200.0,
    tauxDevise: 0.86,
    montant: 232.56,
    montantMonnaie: 232.56,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 202,
    sousImputation: 1,
    libelle: 'Opération change GBP',
    libelleComplementaire: 'Vente GBP contre EUR',
    nomGm: 'MARTIN Sophie',
    quantiteArticle: null,
    prixArticle: null,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'approvisionnement',
    typeApproVersCoffre: 'coffre_vers_caisse',
    modePaiement: 'especes',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 5000.0,
    montantMonnaie: 5000.0,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 301,
    sousImputation: 1,
    libelle: 'Approvisionnement coffre vers caisse',
    libelleComplementaire: 'Fond de caisse matinal',
    nomGm: 'DUPONT Jean',
    quantiteArticle: null,
    prixArticle: null,
  },
];

const MOCK_SUMMARY: RecapWorksheetSummary = {
  numeroSession: 1001,
  dateComptable: new Date('2026-02-20'),
  totalParDevise: { EUR: 9700.0, USD: 446.43, GBP: 232.56 },
  totalParType: { vente: 4700.0, change: 678.99, approvisionnement: 5000.0 },
  totalParModePaiement: { especes: 6928.99, carte: 3450.0 },
  totalGeneral: 10378.99,
};

describe('recapWorksheetStore', () => {
  beforeEach(() => {
    useRecapWorksheetStore.setState({
      entries: [],
      summary: null,
      isGenerating: false,
      error: null,
      filters: {},
    });
    vi.clearAllMocks();
  });

  describe('calculateSummary', () => {
    it('should aggregate amounts by devise', () => {
      const { calculateSummary } = useRecapWorksheetStore.getState();

      const summary = calculateSummary(MOCK_ENTRIES);

      expect(summary.totalParDevise['EUR']).toBe(9700.0);
      expect(summary.totalParDevise['USD']).toBe(446.43);
      expect(summary.totalParDevise['GBP']).toBe(232.56);
    });

    it('should aggregate amounts by type', () => {
      const { calculateSummary } = useRecapWorksheetStore.getState();

      const summary = calculateSummary(MOCK_ENTRIES);

      expect(summary.totalParType['vente']).toBe(4700.0);
      expect(summary.totalParType['change']).toBe(678.99);
      expect(summary.totalParType['approvisionnement']).toBe(5000.0);
    });

    it('should aggregate amounts by mode paiement', () => {
      const { calculateSummary } = useRecapWorksheetStore.getState();

      const summary = calculateSummary(MOCK_ENTRIES);

      expect(summary.totalParModePaiement['especes']).toBe(6928.99);
      expect(summary.totalParModePaiement['carte']).toBe(3450.0);
    });

    it('should calculate total general', () => {
      const { calculateSummary } = useRecapWorksheetStore.getState();

      const summary = calculateSummary(MOCK_ENTRIES);

      expect(summary.totalGeneral).toBe(10378.99);
    });

    it('should handle empty entries array', () => {
      const { calculateSummary } = useRecapWorksheetStore.getState();

      const summary = calculateSummary([]);

      expect(summary.totalParDevise).toEqual({});
      expect(summary.totalParType).toEqual({});
      expect(summary.totalParModePaiement).toEqual({});
      expect(summary.totalGeneral).toBe(0);
    });

    it('should use first entry session and date', () => {
      const { calculateSummary } = useRecapWorksheetStore.getState();

      const summary = calculateSummary(MOCK_ENTRIES);

      expect(summary.numeroSession).toBe(1001);
      expect(summary.dateComptable).toEqual(new Date('2026-02-20'));
    });
  });

  describe('generateRecapWorksheet', () => {
    it('should generate recap with mock data when isRealApi is false', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const { generateRecapWorksheet } = useRecapWorksheetStore.getState();

      const summary = await generateRecapWorksheet(1001, new Date('2026-02-20'));

      expect(summary.numeroSession).toBe(1001);
      expect(summary.totalGeneral).toBe(10378.99);
      expect(useRecapWorksheetStore.getState().entries).toHaveLength(5);
      expect(useRecapWorksheetStore.getState().summary).toEqual(summary);
      expect(useRecapWorksheetStore.getState().isGenerating).toBe(false);
    });

    it('should set isGenerating to true during generation', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const { generateRecapWorksheet } = useRecapWorksheetStore.getState();

      const promise = generateRecapWorksheet(1001, new Date('2026-02-20'));
      
      await new Promise(resolve => setTimeout(resolve, 0));
      
      await promise;
      expect(useRecapWorksheetStore.getState().isGenerating).toBe(false);
    });

    it('should filter entries by numeroSession', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const { generateRecapWorksheet } = useRecapWorksheetStore.getState();

      await generateRecapWorksheet(1001, new Date('2026-02-20'));

      const entries = useRecapWorksheetStore.getState().entries;
      expect(entries.every((e) => e.numeroSession === 1001)).toBe(true);
    });

    it('should call API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: { data: MOCK_SUMMARY },
      });
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { data: MOCK_ENTRIES },
      });
      const { generateRecapWorksheet } = useRecapWorksheetStore.getState();

      const summary = await generateRecapWorksheet(1001, new Date('2026-02-20'));

      expect(apiClient.post).toHaveBeenCalledWith('/api/recapWorksheet/generate', {
        numeroSession: 1001,
        dateComptable: expect.any(String),
      });
      expect(summary).toEqual(MOCK_SUMMARY);
    });

    it('should handle API error', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Erreur serveur'));
      const { generateRecapWorksheet } = useRecapWorksheetStore.getState();

      await expect(generateRecapWorksheet(1001, new Date('2026-02-20'))).rejects.toThrow('Erreur serveur');
      expect(useRecapWorksheetStore.getState().error).toBe('Erreur serveur');
      expect(useRecapWorksheetStore.getState().isGenerating).toBe(false);
    });

    it('should handle missing summary data', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: { data: null },
      });
      const { generateRecapWorksheet } = useRecapWorksheetStore.getState();

      await expect(generateRecapWorksheet(1001, new Date('2026-02-20'))).rejects.toThrow('Aucun récapitulatif généré');
    });
  });

  describe('exportRecapWorksheet', () => {
    it('should export as txt format with mock data', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const { exportRecapWorksheet } = useRecapWorksheetStore.getState();

      const blob = await exportRecapWorksheet(MOCK_SUMMARY, 'txt');

      expect(blob.type).toBe('text/plain');
      const text = await new Response(blob).text();
      expect(text).toContain('RECAP WORKSHEET SESSION 1001');
      expect(text).toContain('EUR: 9700.00');
      expect(text).toContain('TOTAL GENERAL: 10378.99 EUR');
    });

    it('should export as csv format with mock data', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const { exportRecapWorksheet } = useRecapWorksheetStore.getState();

      const blob = await exportRecapWorksheet(MOCK_SUMMARY, 'csv');

      const text = await new Response(blob).text();
      expect(text).toContain('Type,Devise,Montant');
      expect(text).toContain('Devise,EUR,9700.00');
      expect(text).toContain('Type,vente,4700.00');
    });

    it('should export as json format with mock data', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const { exportRecapWorksheet } = useRecapWorksheetStore.getState();

      const blob = await exportRecapWorksheet(MOCK_SUMMARY, 'json');

      const text = await new Response(blob).text();
      const parsed = JSON.parse(text);
      expect(parsed.numeroSession).toBe(1001);
      expect(parsed.totalGeneral).toBe(10378.99);
    });

    it('should call API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockBlob = new Blob(['test'], { type: 'text/plain' });
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: mockBlob });
      const { exportRecapWorksheet } = useRecapWorksheetStore.getState();

      const blob = await exportRecapWorksheet(MOCK_SUMMARY, 'txt');

      expect(apiClient.post).toHaveBeenCalledWith(
        '/api/recapWorksheet/export',
        { summary: MOCK_SUMMARY, format: 'txt' },
        { responseType: 'blob' },
      );
      expect(blob).toBe(mockBlob);
    });

    it('should handle API error', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Erreur export'));
      const { exportRecapWorksheet } = useRecapWorksheetStore.getState();

      await expect(exportRecapWorksheet(MOCK_SUMMARY, 'txt')).rejects.toThrow('Erreur export');
      expect(useRecapWorksheetStore.getState().error).toBe('Erreur export');
    });
  });

  describe('fetchRecapEntries', () => {
    it('should fetch entries with mock data when isRealApi is false', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const { fetchRecapEntries } = useRecapWorksheetStore.getState();

      const entries = await fetchRecapEntries(1001);

      expect(entries).toHaveLength(5);
      expect(entries.every((e) => e.numeroSession === 1001)).toBe(true);
    });

    it('should call API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { data: MOCK_ENTRIES },
      });
      const { fetchRecapEntries } = useRecapWorksheetStore.getState();

      const entries = await fetchRecapEntries(1001);

      expect(apiClient.get).toHaveBeenCalledWith('/api/recapWorksheet/entries/1001');
      expect(entries).toEqual(MOCK_ENTRIES);
    });

    it('should handle API error', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Erreur chargement'));
      const { fetchRecapEntries } = useRecapWorksheetStore.getState();

      await expect(fetchRecapEntries(1001)).rejects.toThrow('Erreur chargement');
      expect(useRecapWorksheetStore.getState().error).toBe('Erreur chargement');
    });

    it('should return empty array when data is null', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { data: null },
      });
      const { fetchRecapEntries } = useRecapWorksheetStore.getState();

      const entries = await fetchRecapEntries(1001);

      expect(entries).toEqual([]);
    });
  });

  describe('state setters', () => {
    it('should set entries', () => {
      const { setEntries } = useRecapWorksheetStore.getState();

      setEntries(MOCK_ENTRIES);

      expect(useRecapWorksheetStore.getState().entries).toEqual(MOCK_ENTRIES);
    });

    it('should set summary', () => {
      const { setSummary } = useRecapWorksheetStore.getState();

      setSummary(MOCK_SUMMARY);

      expect(useRecapWorksheetStore.getState().summary).toEqual(MOCK_SUMMARY);
    });

    it('should set isGenerating', () => {
      const { setIsGenerating } = useRecapWorksheetStore.getState();

      setIsGenerating(true);

      expect(useRecapWorksheetStore.getState().isGenerating).toBe(true);
    });

    it('should set error', () => {
      const { setError } = useRecapWorksheetStore.getState();

      setError('Test error');

      expect(useRecapWorksheetStore.getState().error).toBe('Test error');
    });

    it('should set filters', () => {
      const { setFilters } = useRecapWorksheetStore.getState();
      const filters = { numeroSession: 1001 };

      setFilters(filters);

      expect(useRecapWorksheetStore.getState().filters).toEqual(filters);
    });
  });

  describe('clearRecapWorksheet', () => {
    it('should clear entries, summary and error', () => {
      useRecapWorksheetStore.setState({
        entries: MOCK_ENTRIES,
        summary: MOCK_SUMMARY,
        error: 'Test error',
      });
      const { clearRecapWorksheet } = useRecapWorksheetStore.getState();

      clearRecapWorksheet();

      expect(useRecapWorksheetStore.getState().entries).toEqual([]);
      expect(useRecapWorksheetStore.getState().summary).toBeNull();
      expect(useRecapWorksheetStore.getState().error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      useRecapWorksheetStore.setState({
        entries: MOCK_ENTRIES,
        summary: MOCK_SUMMARY,
        isGenerating: true,
        error: 'Test error',
        filters: { numeroSession: 1001 },
      });
      const { reset } = useRecapWorksheetStore.getState();

      reset();

      const state = useRecapWorksheetStore.getState();
      expect(state.entries).toEqual([]);
      expect(state.summary).toBeNull();
      expect(state.isGenerating).toBe(false);
      expect(state.error).toBeNull();
      expect(state.filters).toEqual({});
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  RecapWorksheetEntry,
  RecapWorksheetSummary,
  RecapWorksheetFilters,
  RecapWorksheetExportFormat,
} from '@/types/recapWorksheet';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

interface RecapWorksheetState {
  entries: RecapWorksheetEntry[];
  summary: RecapWorksheetSummary | null;
  isGenerating: boolean;
  error: string | null;
  filters: RecapWorksheetFilters;
}

interface RecapWorksheetActions {
  generateRecapWorksheet: (
    numeroSession: number,
    dateComptable: Date,
  ) => Promise<RecapWorksheetSummary>;
  exportRecapWorksheet: (
    summary: RecapWorksheetSummary,
    format: RecapWorksheetExportFormat,
  ) => Promise<Blob>;
  fetchRecapEntries: (numeroSession: number) => Promise<RecapWorksheetEntry[]>;
  calculateSummary: (entries: RecapWorksheetEntry[]) => RecapWorksheetSummary;
  setEntries: (entries: RecapWorksheetEntry[]) => void;
  setSummary: (summary: RecapWorksheetSummary | null) => void;
  setIsGenerating: (isGenerating: boolean) => void;
  setError: (error: string | null) => void;
  setFilters: (filters: RecapWorksheetFilters) => void;
  clearRecapWorksheet: () => void;
  reset: () => void;
}

type RecapWorksheetStore = RecapWorksheetState & RecapWorksheetActions;

const MOCK_ENTRIES: RecapWorksheetEntry[] = [
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'vente',
    typeApproVersCoffre: null,
    modePaiement: 'especes',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 1250.0,
    montantMonnaie: 1250.0,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 101,
    sousImputation: 1,
    libelle: 'Ventes espèces session matinale',
    libelleComplementaire: null,
    nomGm: 'MARTIN Sophie',
    quantiteArticle: 15,
    prixArticle: 83.33,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'vente',
    typeApproVersCoffre: null,
    modePaiement: 'carte',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 3450.0,
    montantMonnaie: null,
    montantProduits: null,
    montantCartes: 3450.0,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 102,
    sousImputation: 1,
    libelle: 'Ventes carte session matinale',
    libelleComplementaire: 'CB/Visa',
    nomGm: 'MARTIN Sophie',
    quantiteArticle: 28,
    prixArticle: 123.21,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'change',
    typeApproVersCoffre: null,
    modePaiement: 'especes',
    avecChange: 'O',
    codeDevise: 'USD',
    quantiteDevise: 500.0,
    tauxDevise: 1.12,
    montant: 446.43,
    montantMonnaie: 446.43,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 201,
    sousImputation: 1,
    libelle: 'Opération change USD',
    libelleComplementaire: 'Achat USD contre EUR',
    nomGm: 'MARTIN Sophie',
    quantiteArticle: null,
    prixArticle: null,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'change',
    typeApproVersCoffre: null,
    modePaiement: 'especes',
    avecChange: 'O',
    codeDevise: 'GBP',
    quantiteDevise: 200.0,
    tauxDevise: 0.86,
    montant: 232.56,
    montantMonnaie: 232.56,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 202,
    sousImputation: 1,
    libelle: 'Opération change GBP',
    libelleComplementaire: 'Vente GBP contre EUR',
    nomGm: 'MARTIN Sophie',
    quantiteArticle: null,
    prixArticle: null,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1001,
    type: 'approvisionnement',
    typeApproVersCoffre: 'coffre_vers_caisse',
    modePaiement: 'especes',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 5000.0,
    montantMonnaie: 5000.0,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 301,
    sousImputation: 1,
    libelle: 'Approvisionnement coffre vers caisse',
    libelleComplementaire: 'Fond de caisse matinal',
    nomGm: 'DUPONT Jean',
    quantiteArticle: null,
    prixArticle: null,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1002,
    type: 'vente',
    typeApproVersCoffre: null,
    modePaiement: 'cheque',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 780.0,
    montantMonnaie: null,
    montantProduits: null,
    montantCartes: null,
    montantCheque: 780.0,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 103,
    sousImputation: 1,
    libelle: 'Ventes chèque session après-midi',
    libelleComplementaire: null,
    nomGm: 'DURAND Pierre',
    quantiteArticle: 5,
    prixArticle: 156.0,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1002,
    type: 'vente',
    typeApproVersCoffre: null,
    modePaiement: 'od',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 125.0,
    montantMonnaie: null,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: 125.0,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 104,
    sousImputation: 1,
    libelle: 'Ordre de débit',
    libelleComplementaire: 'Régularisation compte',
    nomGm: 'DURAND Pierre',
    quantiteArticle: null,
    prixArticle: null,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1002,
    type: 'remboursement',
    typeApproVersCoffre: null,
    modePaiement: 'especes',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: -350.0,
    montantMonnaie: -350.0,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 401,
    sousImputation: 1,
    libelle: 'Remboursement client',
    libelleComplementaire: 'Annulation vente',
    nomGm: 'DURAND Pierre',
    quantiteArticle: null,
    prixArticle: null,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1002,
    type: 'ajustement',
    typeApproVersCoffre: null,
    modePaiement: 'especes',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: 15.5,
    montantMonnaie: 15.5,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 501,
    sousImputation: 1,
    libelle: 'Ajustement écart caisse',
    libelleComplementaire: 'Surplus constaté',
    nomGm: 'ADMIN',
    quantiteArticle: null,
    prixArticle: null,
  },
  {
    dateComptable: new Date('2026-02-20'),
    numeroSession: 1002,
    type: 'approvisionnement',
    typeApproVersCoffre: 'caisse_vers_coffre',
    modePaiement: 'especes',
    avecChange: 'N',
    codeDevise: 'EUR',
    quantiteDevise: null,
    tauxDevise: 1.0,
    montant: -3000.0,
    montantMonnaie: -3000.0,
    montantProduits: null,
    montantCartes: null,
    montantCheque: null,
    montantOd: null,
    societe: 'SOC1',
    compteVillage: 1001,
    filiation: 0,
    imputation: 302,
    sousImputation: 1,
    libelle: 'Déversement caisse vers coffre',
    libelleComplementaire: 'Fermeture session',
    nomGm: 'DURAND Pierre',
    quantiteArticle: null,
    prixArticle: null,
  },
];

const initialState: RecapWorksheetState = {
  entries: [],
  summary: null,
  isGenerating: false,
  error: null,
  filters: {},
};

export const useRecapWorksheetStore = create<RecapWorksheetStore>()((set, get) => ({
  ...initialState,

  generateRecapWorksheet: async (numeroSession, dateComptable) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isGenerating: true, error: null });

    if (!isRealApi) {
      const sessionEntries = MOCK_ENTRIES.filter((e) => e.numeroSession === numeroSession);
      const summary = get().calculateSummary(sessionEntries);
      set({
        entries: sessionEntries,
        summary,
        isGenerating: false,
      });
      return summary;
    }

    try {
      const response = await apiClient.post<
        ApiResponse<RecapWorksheetSummary>,
        { numeroSession: number; dateComptable: string }
      >('/api/recapWorksheet/generate', {
        numeroSession,
        dateComptable: dateComptable.toISOString(),
      });

      const summary = response.data.data;
      if (!summary) {
        throw new Error('Aucun récapitulatif généré');
      }

      const entries = await get().fetchRecapEntries(numeroSession);
      set({ summary, entries, isGenerating: false });
      return summary;
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur génération récapitulatif';
      set({ error: message, isGenerating: false });
      throw e;
    }
  },

  exportRecapWorksheet: async (summary, format) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      let content = '';
      if (format === 'txt') {
        content = `=== RECAP WORKSHEET SESSION ${summary.numeroSession} ===\n`;
        content += `Date comptable: ${summary.dateComptable.toLocaleDateString()}\n\n`;
        content += `TOTAUX PAR DEVISE:\n`;
        Object.entries(summary.totalParDevise).forEach(([devise, montant]) => {
          content += `  ${devise}: ${montant.toFixed(2)}\n`;
        });
        content += `\nTOTAUX PAR TYPE:\n`;
        Object.entries(summary.totalParType).forEach(([type, montant]) => {
          content += `  ${type}: ${montant.toFixed(2)}\n`;
        });
        content += `\nTOTAUX PAR MODE PAIEMENT:\n`;
        Object.entries(summary.totalParModePaiement).forEach(([mode, montant]) => {
          content += `  ${mode}: ${montant.toFixed(2)}\n`;
        });
        content += `\nTOTAL GENERAL: ${summary.totalGeneral.toFixed(2)} EUR\n`;
      } else if (format === 'csv') {
        content = 'Type,Devise,Montant\n';
        Object.entries(summary.totalParDevise).forEach(([devise, montant]) => {
          content += `Devise,${devise},${montant.toFixed(2)}\n`;
        });
        Object.entries(summary.totalParType).forEach(([type, montant]) => {
          content += `Type,${type},${montant.toFixed(2)}\n`;
        });
        Object.entries(summary.totalParModePaiement).forEach(([mode, montant]) => {
          content += `ModePaiement,${mode},${montant.toFixed(2)}\n`;
        });
      } else {
        content = JSON.stringify(summary, null, 2);
      }

      return new Blob([content], { type: 'text/plain' });
    }

    try {
      const response = await apiClient.post<Blob, { summary: RecapWorksheetSummary; format: RecapWorksheetExportFormat }>(
        '/api/recapWorksheet/export',
        { summary, format },
        { responseType: 'blob' },
      );
      return response.data;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur export récapitulatif';
      set({ error: message });
      throw e;
    }
  },

  fetchRecapEntries: async (numeroSession) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      const entries = MOCK_ENTRIES.filter((e) => e.numeroSession === numeroSession);
      return entries;
    }

    try {
      const response = await apiClient.get<ApiResponse<RecapWorksheetEntry[]>>(
        `/api/recapWorksheet/entries/${numeroSession}`,
      );
      return response.data.data ?? [];
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur chargement entrées récapitulatif';
      set({ error: message });
      throw e;
    }
  },

  calculateSummary: (entries) => {
    const totalParDevise: Record<string, number> = {};
    const totalParType: Record<string, number> = {};
    const totalParModePaiement: Record<string, number> = {};
    let totalGeneral = 0;

    entries.forEach((entry) => {
      totalParDevise[entry.codeDevise] =
        (totalParDevise[entry.codeDevise] ?? 0) + entry.montant;

      totalParType[entry.type] = (totalParType[entry.type] ?? 0) + entry.montant;

      if (entry.modePaiement) {
        totalParModePaiement[entry.modePaiement] =
          (totalParModePaiement[entry.modePaiement] ?? 0) + entry.montant;
      }

      totalGeneral += entry.montant;
    });

    return {
      numeroSession: entries[0]?.numeroSession ?? 0,
      dateComptable: entries[0]?.dateComptable ?? new Date(),
      totalParDevise,
      totalParType,
      totalParModePaiement,
      totalGeneral,
    };
  },

  setEntries: (entries) => set({ entries }),

  setSummary: (summary) => set({ summary }),

  setIsGenerating: (isGenerating) => set({ isGenerating }),

  setError: (error) => set({ error }),

  setFilters: (filters) => set({ filters }),

  clearRecapWorksheet: () =>
    set({
      entries: [],
      summary: null,
      error: null,
    }),

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.