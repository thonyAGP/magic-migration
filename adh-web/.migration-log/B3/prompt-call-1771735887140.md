Generate Vitest unit tests for the "saisieDateStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  DateRange,
  SaisieDateState,
  GetTitreResponse,
} from '@/types/saisieDate';
import { useDataSourceStore } from './dataSourceStore';
import { apiClient } from '@/services/api/apiClient';

const initialState: Omit<SaisieDateState, 'setDateMin' | 'setDateMax' | 'validateDates' | 'submitDates' | 'cancel' | 'reset'> = {
  dateMin: null,
  dateMax: null,
  isValid: false,
  errorMessage: null,
};

export const useSaisieDateStore = create<SaisieDateState>()((set, get) => ({
  ...initialState,

  setDateMin: (date) => {
    set({ dateMin: date });
    get().validateDates();
  },

  setDateMax: (date) => {
    set({ dateMax: date });
    get().validateDates();
  },

  validateDates: () => {
    const { dateMin, dateMax } = get();

    if (!dateMin && !dateMax) {
      set({ isValid: false, errorMessage: 'Au moins une date doit être saisie' });
      return false;
    }

    if (dateMin && dateMax && dateMin > dateMax) {
      set({ isValid: false, errorMessage: 'La date minimum doit être inférieure ou égale à la date maximum' });
      return false;
    }

    set({ isValid: true, errorMessage: null });
    return true;
  },

  submitDates: async () => {
    const { dateMin, dateMax, validateDates } = get();

    if (!validateDates()) {
      return null;
    }

    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      return { dateMin, dateMax };
    }

    try {
      const response = await apiClient.post<DateRange>('/api/saisie-date/submit', {
        dateMin,
        dateMax,
      });

      if (!response.data.success) {
        set({ errorMessage: response.data.error ?? 'Erreur lors de la soumission' });
        return null;
      }

      return response.data.data ?? { dateMin, dateMax };
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur lors de la soumission des dates';
      set({ errorMessage: message });
      return null;
    }
  },

  cancel: () => {
    set({ ...initialState });
  },

  reset: () => {
    set({ ...initialState });
  },
}));

export const getTitre = async (): Promise<string> => {
  const { isRealApi } = useDataSourceStore.getState();

  if (!isRealApi) {
    return 'Saisie dates';
  }

  try {
    const response = await apiClient.get<GetTitreResponse>('/api/saisie-date/titre');
    return response.data.data?.titre ?? 'Saisie dates';
  } catch (e: unknown) {
    return 'Saisie dates';
  }
};

TYPES:
export interface DateRange {
  dateMin: Date | null;
  dateMax: Date | null;
}

export interface SaisieDate {
  dateMin: Date | null;
  dateMax: Date | null;
  isValid: boolean;
  errorMessage: string | null;
}

export interface SaisieDateState {
  dateMin: Date | null;
  dateMax: Date | null;
  isValid: boolean;
  errorMessage: string | null;
  setDateMin: (date: Date | null) => void;
  setDateMax: (date: Date | null) => void;
  validateDates: () => boolean;
  submitDates: () => Promise<DateRange | null>;
  cancel: () => void;
  reset: () => void;
}

export interface GetTitreResponse {
  titre: string;
}

export type SaisieDateRequest = DateRange;

export type SaisieDateResponse = DateRange;

ACTIONS TO COVER:
[
  {
    "name": "setDateMin",
    "params": [
      "date: Date | null"
    ],
    "businessRules": [
      "Updates minimum date boundary",
      "Validates that dateMin <= dateMax if both are set"
    ],
    "returns": "void"
  },
  {
    "name": "setDateMax",
    "params": [
      "date: Date | null"
    ],
    "businessRules": [
      "Updates maximum date boundary",
      "Validates that dateMin <= dateMax if both are set"
    ],
    "returns": "void"
  },
  {
    "name": "validateDates",
    "params": [],
    "businessRules": [
      "[RM-001] If NOT valid (negation of v.ok), prevent submission",
      "dateMin must be <= dateMax if both are provided",
      "At least one date must be provided"
    ],
    "returns": "boolean"
  },
  {
    "name": "submitDates",
    "params": [],
    "businessRules": [
      "Validates date range before submission",
      "Returns selected date range to parent component/caller",
      "Sets isValid flag based on validation result"
    ],
    "returns": "Promise<DateRange | null>"
  },
  {
    "name": "cancel",
    "params": [],
    "businessRules": [
      "Resets form state",
      "Returns null to indicate cancellation"
    ],
    "returns": "void"
  },
  {
    "name": "reset",
    "params": [],
    "businessRules": [
      "Clears all date fields",
      "Resets validation state"
    ],
    "returns": "void"
  }
]