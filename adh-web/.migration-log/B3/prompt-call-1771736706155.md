Generate Vitest unit tests for the "fidelisationRemiseStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  FidelisationRemise,
  RemiseResult,
  FidelisationRemiseState,
} from '@/types/fidelisationRemise';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

interface FidelisationRemiseActions {
  getFidelisationRemise: (
    societe: string,
    compte: number,
    filiation: number,
    service: string,
    imputation: number,
  ) => Promise<void>;
  validateRemiseEligibility: (remiseData: FidelisationRemise) => Promise<boolean>;
  calculateMontantRemise: (remiseData: FidelisationRemise) => Promise<number>;
  setError: (error: string | null) => void;
  reset: () => void;
}

type FidelisationRemiseStore = FidelisationRemiseState & FidelisationRemiseActions;

const MOCK_REMISE_DATA: FidelisationRemise[] = [
  {
    societe: 'SOC1',
    compte: 1001,
    filiation: 0,
    service: 'RST',
    imputation: 101,
    fidelisation: 'GOLD',
    remise: 15,
  },
  {
    societe: 'SOC1',
    compte: 1002,
    filiation: 0,
    service: 'BTQ',
    imputation: 102,
    fidelisation: 'SILVER',
    remise: 10,
  },
  {
    societe: 'SOC1',
    compte: 1003,
    filiation: 1,
    service: 'SPA',
    imputation: 103,
    fidelisation: 'BRONZE',
    remise: 5,
  },
  {
    societe: 'SOC1',
    compte: 1004,
    filiation: 0,
    service: 'BAR',
    imputation: 104,
    fidelisation: 'EXPIRED',
    remise: null,
  },
  {
    societe: 'SOC1',
    compte: 1005,
    filiation: 0,
    service: 'RST',
    imputation: 105,
    fidelisation: null,
    remise: null,
  },
];

const calculateRemiseResult = (data: FidelisationRemise | null): RemiseResult | null => {
  if (!data) return null;

  if (!data.fidelisation) {
    return {
      fidelisationId: null,
      montantRemise: 0,
      isValide: false,
      message: 'Aucun programme de fidelisation actif',
    };
  }

  if (data.fidelisation === 'EXPIRED') {
    return {
      fidelisationId: data.fidelisation,
      montantRemise: 0,
      isValide: false,
      message: 'Programme de fidelisation expire',
    };
  }

  if (!data.remise || data.remise <= 0) {
    return {
      fidelisationId: data.fidelisation,
      montantRemise: 0,
      isValide: false,
      message: 'Aucune remise disponible pour ce profil',
    };
  }

  return {
    fidelisationId: data.fidelisation,
    montantRemise: data.remise,
    isValide: true,
    message: null,
  };
};

const initialState: FidelisationRemiseState = {
  isLoading: false,
  error: null,
  remiseData: null,
  remiseResult: null,
  getFidelisationRemise: async () => {},
  validateRemiseEligibility: async () => false,
  calculateMontantRemise: async () => 0,
  setError: () => {},
  reset: () => {},
};

export const useFidelisationRemiseStore = create<FidelisationRemiseStore>()((set, get) => ({
  ...initialState,

  getFidelisationRemise: async (societe, compte, filiation, service, imputation) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const mockData = MOCK_REMISE_DATA.find(
        (d) =>
          d.societe === societe &&
          d.compte === compte &&
          d.filiation === filiation &&
          d.service === service &&
          d.imputation === imputation,
      );

      const result = calculateRemiseResult(mockData ?? null);
      set({
        remiseData: mockData ?? null,
        remiseResult: result,
        isLoading: false,
      });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<RemiseResult>>(
        '/api/fidelisation-remise/get',
        {
          params: { societe, compte, filiation, service, imputation },
        },
      );

      const remiseData: FidelisationRemise = {
        societe,
        compte,
        filiation,
        service,
        imputation,
        fidelisation: response.data.data?.fidelisationId ?? null,
        remise: response.data.data?.montantRemise ?? null,
      };

      set({
        remiseData,
        remiseResult: response.data.data ?? null,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement fidelisation';
      set({ remiseData: null, remiseResult: null, error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  validateRemiseEligibility: async (remiseData) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const isValid = !!(
        remiseData.fidelisation &&
        remiseData.fidelisation !== 'EXPIRED' &&
        remiseData.remise &&
        remiseData.remise > 0
      );
      set({ isLoading: false });
      return isValid;
    }

    try {
      const response = await apiClient.post<
        ApiResponse<{ isValide: boolean; message?: string }>
      >('/api/fidelisation-remise/validate', { remiseData });

      set({ isLoading: false });
      return response.data.data?.isValide ?? false;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation remise';
      set({ error: message, isLoading: false });
      return false;
    }
  },

  calculateMontantRemise: async (remiseData) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const montant = remiseData.remise ?? 0;
      set({ isLoading: false });
      return montant;
    }

    try {
      const response = await apiClient.post<ApiResponse<{ montantRemise: number }>>(
        '/api/fidelisation-remise/calculate',
        { remiseData },
      );

      set({ isLoading: false });
      return response.data.data?.montantRemise ?? 0;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur calcul montant';
      set({ error: message, isLoading: false });
      return 0;
    }
  },

  setError: (error) => {
    set({ error });
  },

  reset: () => set({ ...initialState }),
}));

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

// Fidelisation Remise types (fidelisationRemise domain)

export interface FidelisationRemise {
  societe: string;
  compte: number;
  filiation: number;
  service: string;
  imputation: number;
  fidelisation: string | null;
  remise: number | null;
}

export interface RemiseResult {
  fidelisationId: string | null;
  montantRemise: number;
  isValide: boolean;
  message: string | null;
}

export interface FidelisationRemiseState {
  isLoading: boolean;
  error: string | null;
  remiseData: FidelisationRemise | null;
  remiseResult: RemiseResult | null;
  getFidelisationRemise: (
    societe: string,
    compte: number,
    filiation: number,
    service: string,
    imputation: number
  ) => Promise<void>;
  validateRemiseEligibility: (remiseData: FidelisationRemise) => Promise<boolean>;
  calculateMontantRemise: (remiseData: FidelisationRemise) => Promise<number>;
  setError: (error: string | null) => void;
  reset: () => void;
}

export interface GetFidelisationRemiseRequest {
  societe: string;
  compte: number;
  filiation: number;
  service: string;
  imputation: number;
}

export interface GetFidelisationRemiseResponse extends ApiResponse {
  data: RemiseResult;
}

export interface ValidateRemiseEligibilityRequest {
  remiseData: FidelisationRemise;
}

export interface ValidateRemiseEligibilityResponse extends ApiResponse {
  data: {
    isValide: boolean;
    message?: string;
  };
}

export interface CalculateMontantRemiseRequest {
  remiseData: FidelisationRemise;
}

export interface CalculateMontantRemiseResponse extends ApiResponse {
  data: {
    montantRemise: number;
  };
}

ACTIONS TO COVER:
[
  {
    "name": "getFidelisationRemise",
    "params": [
      "societe: string",
      "compte: number",
      "filiation: number",
      "service: string",
      "imputation: number"
    ],
    "businessRules": [
      "Extraire les informations de fidelisation et remise pour le compte client specifie",
      "Valider que la remise sollicitee correspond au profil du client",
      "Verifier que la remise n'a pas deja ete utilisee dans la periode en cours",
      "Calculer le montant de reduction eligible base sur les regles de remise configurees"
    ],
    "returns": "Promise<RemiseResult>"
  },
  {
    "name": "validateRemiseEligibility",
    "params": [
      "remiseData: FidelisationRemise"
    ],
    "businessRules": [
      "Verifier la conformite de la remise avec le profil client",
      "Valider les criteres de fidelisation",
      "Verifier les seuils et limites configurees"
    ],
    "returns": "Promise<boolean>"
  },
  {
    "name": "calculateMontantRemise",
    "params": [
      "remiseData: FidelisationRemise"
    ],
    "businessRules": [
      "Calculer le montant de reduction applicable",
      "Appliquer les regles de remise configurees en base",
      "Retourner le montant final de la remise"
    ],
    "returns": "Promise<number>"
  }
]