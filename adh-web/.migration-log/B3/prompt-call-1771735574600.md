Generate a complete Zustand store for the "facturationAppel" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

STORE REQUIREMENTS:
- Use `create` from zustand (import { create } from "zustand")
- Import types from @/types/facturationAppel
- Import useDataSourceStore from @/stores/dataSourceStore
- Mock/API branching via useDataSourceStore.getState().isRealApi
- try/catch with `e instanceof Error` for error handling
- Realistic mock data (not lorem ipsum)
- EVERY business rule from the analysis MUST be implemented
- Include reset() action to clear state

TYPES FILE (already generated):
import type { Transaction, OperationDetails } from "@/types/index";

export type CompteType = 'GO' | 'GM';

export interface HistoriqueAppel {
  id?: number;
  societe: string;
  dateAppel: Date;
  heureAppel: string;
  numeroTel: string;
  duree: string;
  montant: number;
  qualite: string | null;
  gratuite: boolean;
  raisonGratuite: string | null;
}

export interface CoefTelephone {
  coefficient: number;
  societe: string;
}

export interface ReseauCloture {
  clotureEnCours: boolean;
  testReseau: string;
}

export interface FacturationAppelFilters {
  dateDebut?: Date;
  dateFin?: Date;
  numeroTel?: string;
}

export interface FacturationAppelState {
  historiquesAppels: HistoriqueAppel[];
  coefficientTelephone: number | null;
  clotureEnCours: boolean;
  testReseau: string;
  isLoading: boolean;
  error: string | null;
  filters: FacturationAppelFilters;
  chargerHistoriquesAppels: (societe: string, dateDebut?: Date, dateFin?: Date) => Promise<void>;
  recupererCoefficient: (societe: string) => Promise<number>;
  verifierClotureEnCours: (societe: string) => Promise<boolean>;
  debloquerCloture: (societe: string) => Promise<void>;
  creerFactureAppel: (appel: HistoriqueAppel, typeCompte: CompteType) => Promise<void>;
  marquerAppelGratuit: (appelId: number, raison: string) => Promise<void>;
  setFilters: (filters: FacturationAppelFilters) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

export interface ChargerHistoriquesApelsRequest {
  societe: string;
  dateDebut?: Date;
  dateFin?: Date;
  numeroTel?: string;
}

export interface ChargerHistoriquesAppelsResponse {
  data: HistoriqueAppel[];
}

export interface RecupererCoefficientResponse {
  data: CoefTelephone;
}

export interface VerifierClotureEnCoursResponse {
  data: {
    clotureEnCours: boolean;
    testReseau: string;
  };
}

export interface DebloquerClotureRequest {
  societe: string;
}

export interface DebloquerClotureResponse {
  success: boolean;
}

export interface CreerFactureAppelRequest {
  appel: HistoriqueAppel;
  typeCompte: CompteType;
  coefficientTelephone: number;
}

export interface CreerFactureAppelResponse {
  success: boolean;
  operationId?: number;
  montantFacture?: number;
}

export interface MarquerAppelGratuitRequest {
  appelId: number;
  raison: string;
}

export interface MarquerAppelGratuitResponse {
  success: boolean;
}

export interface FacturationAppelSummary {
  totalAppels: number;
  totalMontant: number;
  totalGratuits: number;
  totalFacture: number;
  coefficientActuel: number;
  clotureEnCours: boolean;
}

export const QUALITE_OPTIONS = {
  BONNE: 'Bonne',
  MAUVAISE: 'Mauvaise',
  ACCEPTABLE: 'Acceptable',
} as const;

export const RAISON_GRATUITE_OPTIONS = {
  ERREUR_FACTURATION: 'Erreur facturation',
  APPEL_SERVICE: 'Appel service',
  TEST_RESEAU: 'Test réseau',
  AUTRE: 'Autre',
} as const;

export type QualiteType = typeof QUALITE_OPTIONS[keyof typeof QUALITE_OPTIONS];
export type RaisonGratuiteType = typeof RAISON_GRATUITE_OPTIONS[keyof typeof RAISON_GRATUITE_OPTIONS];

ANALYSIS DOCUMENT:
{
  "domain": "facturationAppel",
  "domainPascal": "FacturationAppel",
  "complexity": "MEDIUM",
  "entities": [
    {
      "name": "HistoriqueAppel",
      "fields": [
        {
          "name": "societe",
          "type": "string",
          "source": "historique_pabx.societe",
          "nullable": false
        },
        {
          "name": "dateAppel",
          "type": "Date",
          "source": "historique_pabx.date_appel",
          "nullable": false
        },
        {
          "name": "heureAppel",
          "type": "string",
          "source": "historique_pabx.heure_appel",
          "nullable": false
        },
        {
          "name": "numeroTel",
          "type": "string",
          "source": "historique_pabx.numero_tel",
          "nullable": false
        },
        {
          "name": "duree",
          "type": "string",
          "source": "historique_pabx.duree",
          "nullable": false
        },
        {
          "name": "montant",
          "type": "number",
          "source": "historique_pabx.montant",
          "nullable": false
        },
        {
          "name": "qualite",
          "type": "string",
          "source": "historique_pabx.qualite",
          "nullable": true
        },
        {
          "name": "gratuite",
          "type": "boolean",
          "source": "historique_pabx.gratuite",
          "nullable": false
        },
        {
          "name": "raisonGratuite",
          "type": "string",
          "source": "historique_pabx.raison_gratuite",
          "nullable": true
        }
      ]
    },
    {
      "name": "CoefTelephone",
      "fields": [
        {
          "name": "coefficient",
          "type": "number",
          "source": "coef__telephone__coe.coeff_tel",
          "nullable": false
        },
        {
          "name": "societe",
          "type": "string",
          "source": "coef__telephone__coe.societe",
          "nullable": false
        }
      ]
    },
    {
      "name": "ReseauCloture",
      "fields": [
        {
          "name": "clotureEnCours",
          "type": "boolean",
          "source": "reseau_cloture___rec.cloture_en_cours",
          "nullable": false
        },
        {
          "name": "testReseau",
          "type": "string",
          "source": "reseau_cloture___rec.test_reseau",
          "nullable": false
        }
      ]
    }
  ],
  "stateFields": [
    {
      "name": "historiquesAppels",
      "type": "HistoriqueAppel[]",
      "default": "[]"
    },
    {
      "name": "coefficientTelephone",
      "type": "number | null",
      "default": "null"
    },
    {
      "name": "clotureEnCours",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "testReseau",
      "type": "string",
      "default": "''"
    },
    {
      "name": "isLoading",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "error",
      "type": "string | null",
      "default": "null"
    },
    {
      "name": "filters",
      "type": "{ dateDebut?: Date; dateFin?: Date; numeroTel?: string }",
      "default": "{}"
    }
  ],
  "actions": [
    {
      "name": "chargerHistoriquesAppels",
      "params": [
        "societe: string",
        "dateDebut?: Date",
        "dateFin?: Date"
      ],
      "businessRules": [
        "Charger les appels pour la période spécifiée",
        "Filtrer par société",
        "Trier par date et heure décroissant"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "recupererCoefficient",
      "params": [
        "societe: string"
      ],
      "businessRules": [
        "Récupérer le coefficient téléphone pour la société",
        "Utiliser pour calcul du montant facturation"
      ],
      "returns": "Promise<number>"
    },
    {
      "name": "verifierClotureEnCours",
      "params": [
        "societe: string"
      ],
      "businessRules": [
        "Vérifier si une clôture est en cours",
        "Bloquer les opérations si clôture active"
      ],
      "returns": "Promise<boolean>"
    },
    {
      "name": "debloquerCloture",
      "params": [
        "societe: string"
      ],
      "businessRules": [
        "Débloquer une clôture en cours",
        "Mettre à jour le statut réseau"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "creerFactureAppel",
      "params": [
        "appel: HistoriqueAppel",
        "typeCompte: 'GO' | 'GM'"
      ],
      "businessRules": [
        "RM-001: Si > GO alors type='GO' sinon type='GM'",
        "Créer une opération débit pour l'appel",
        "Appliquer le coefficient téléphone",
        "Gérer les appels gratuits (montant = 0)"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "marquerAppelGratuit",
      "params": [
        "appelId: number",
        "raison: string"
      ],
      "businessRules": [
        "Marquer l'appel comme gratuit",
        "Enregistrer la raison de gratuité",
        "Ne pas créer d'opération débit"
      ],
      "returns": "Promise<void>"
    }
  ],
  "apiEndpoints": [
    {
      "method": "GET",
      "path": "/api/facturation-appel/historiques",
      "queryParams": [
        "societe",
        "dateDebut?",
        "dateFin?",
        "numeroTel?"
      ],
      "response": "HistoriqueAppel[]"
    },
    {
      "method": "GET",
      "path": "/api/facturation-appel/coefficient/{societe}",
      "queryParams": [],
      "response": "CoefTelephone"
    },
    {
      "method": "GET",
      "path": "/api/facturation-appel/cloture-status/{societe}",
      "queryParams": [],
      "response": "{ clotureEnCours: boolean; testReseau: string }"
    },
    {
      "method": "POST",
      "path": "/api/facturation-appel/debloquer-cloture",
      "queryParams": [
        "societe"
      ],
      "response": "{ success: boolean }"
    },
    {
      "method": "POST",
      "path": "/api/facturation-appel/creer-facture",
      "queryParams": [],
      "response": "{ success: boolean; operationId?: number }"
    },
    {
      "method": "PATCH",
      "path": "/api/facturation-appel/marquer-gratuit/{appelId}",
      "queryParams": [],
      "response": "{ success: boolean }"
    }
  ],
  "uiLayout": {
    "type": "data-list-page",
    "sections": [
      {
        "name": "filters",
        "controls": [
          "DateRangePicker (dateDebut, dateFin)",
          "TextInput (numeroTel)",
          "Button (Rechercher)"
        ]
      },
      {
        "name": "appelsList",
        "controls": [
          "DataGrid avec colonnes: dateAppel, heureAppel, numeroTel, duree, montant, qualite, gratuite",
          "Actions par ligne: Facturer, Marquer gratuit",
          "Indicateur si clôture en cours"
        ]
      },
      {
        "name": "facturationPanel",
        "controls": [
          "RadioGroup (Type compte: GO/GM)",
          "TextInput (Montant calculé - readonly)",
          "Checkbox (Appel gratuit)",
          "TextInput (Raison gratuité - si gratuit)",
          "Button (Confirmer facturation)"
        ]
      },
      {
        "name": "statusBar",
        "controls": [
          "Label (Coefficient téléphone actuel)",
          "Label (Statut clôture)",
          "Button (Débloquer clôture - si clôture active)"
        ]
      }
    ]
  },
  "mockData": {
    "count": 10,
    "description": "10 appels téléphoniques sur 3 jours avec différents numéros, durées variées (30s à 15min), montants calculés (0.50€ à 8.00€), 2 appels gratuits avec raisons (erreur facturation, appel service)"
  },
  "dependencies": {
    "stores": [
      "useParametresStore (pour société courante)",
      "useSessionStore (pour opérateur courant)",
      "useTransactionStore (pour création OD)"
    ],
    "sharedTypes": [
      "Transaction",
      "OperationDetails"
    ],
    "externalApis": [
      "Test reseau (ADH IDE 18)",
      "Test si cloture en cours (ADH IDE 19)",
      "Deblocage compte GM (ADH IDE 17)",
      "Creation O.D (ADH IDE 16)"
    ]
  }
}

SPEC EXCERPT (business rules):
﻿# ADH IDE 173 - Facturation appel

> **Analyse**: Phases 1-4 2026-02-03 10:54 -> 10:54 (16s) | Assemblage 07:23
> **Pipeline**: V7.2 Enrichi
> **Structure**: 4 onglets (Resume | Ecrans | Donnees | Connexions)

<!-- TAB:Resume -->

## 1. FICHE D'IDENTITE

| Attribut | Valeur |
|----------|--------|
| Projet | ADH |
| IDE Position | 173 |
| Nom Programme | Facturation appel |
| Fichier source | `Prg_173.xml` |
| Dossier IDE | Operations |
| Taches | 6 (0 ecrans visibles) |
| Tables modifiees | 3 |
| Programmes appeles | 5 |

## 2. DESCRIPTION FONCTIONNELLE

**Facturation appel** assure la gestion complete de ce processus, accessible depuis [Menu caisse GM - scroll @ (IDE 22)](ADH-IDE-22.md).

Le flux de traitement s'organise en **1 blocs fonctionnels** :

- **Traitement** (6 taches) : traitements metier divers

**Donnees modifiees** : 3 tables en ecriture (reseau_cloture___rec, historique_pabx, coef__telephone__coe).

**Logique metier** : 1 regles identifiees couvrant conditions metier.

<details>
<summary>Detail : phases du traitement</summary>

#### Phase 1 : Traitement (6 taches)

- **T1** - Facturation appel
- **T2** - Historique appel
- **T3** - Historique appel
- **T4** - Recuperation coef
- **T5** - Deblocage cloture
- **T8** - Deblocage cloture

Delegue a : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

#### Tables impactees

| Table | Operations | Role metier |
|-------|-----------|-------------|
| reseau_cloture___rec | **W** (2 usages) | Donnees reseau/cloture |
| historique_pabx | **W** (2 usages) | Historique / journal |
| coef__telephone__coe | **W** (1 usages) |  |

</details>

## 3. BLOCS FONCTIONNELS

### 3.1 Traitement (6 taches)

Traitements internes.

---

#### <a id="t1"></a>T1 - Facturation appel

**Role** : Tache d'orchestration : point d'entree du programme (6 sous-taches). Coordonne l'enchainement des traitements.

<details>
<summary>5 sous-taches directes</summary>

| Tache | Nom | Bloc |
|-------|-----|------|
| [T2](#t2) | Historique appel | Traitement |
| [T3](#t3) | Historique appel | Traitement |
| [T4](#t4) | Recuperation coef | Traitement |
| [T5](#t5) | Deblocage cloture | Traitement |
| [T8](#t8) | Deblocage cloture | Traitement |

</details>
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t2"></a>T2 - Historique appel

**Role** : Consultation/chargement : Historique appel.
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t3"></a>T3 - Historique appel

**Role** : Consultation/chargement : Historique appel.
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t4"></a>T4 - Recuperation coef

**Role** : Consultation/chargement : Recuperation coef.
**Variables liees** : V (w0 coeff tel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t5"></a>T5 - Deblocage cloture

**Role** : Traitement : Deblocage cloture.
**Variables liees** : W (w0 cloture en cours)
**Delegue a** : [  Deblocage compte GM (IDE 17)](ADH-IDE-17.md), [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t8"></a>T8 - Deblocage cloture

**Role** : Traitement : Deblocage cloture.
**Variables liees** : W (w0 cloture en cours)
**Delegue a** : [  Deblocage compte GM (IDE 17)](ADH-IDE-17.md), [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)


## 5. REGLES METIER

1 regles identifiees:

### Autres (1 regles)

#### <a id="rm-RM-001"></a>[RM-001] Si > GO [G] alors 'GO' sinon 'GM')

| Element | Detail |
|---------|--------|
| **Condition** | `> GO [G]` |
| **Si vrai** | 'GO' |
| **Si faux** | 'GM') |
| **Variables** | G (> GO) |
| **Expression source** | Expression 4 : `IF (> GO [G],'GO','GM')` |
| **Exemple** | Si > GO [G] â†’ 'GO'. Sinon â†’ 'GM') |

## 6. CONTEXTE

- **Appele par**: [Menu caisse GM - scroll @ (IDE 22)](ADH-IDE-22.md)
- **Appelle**: 5 programmes | **Tables**: 3 (W:3 R:0 L:0) | **Taches**: 6 | **Expressions**: 15

<!-- TAB:Ecrans -->

## 8. ECRANS

*(Programme sans ecran visible)*

## 9. NAVIGATION

### 9.3 Structure hierarchique (6 taches)

| Position | Tache | Type | Dimensions | Bloc |
|----------|-------|------|------------|------|
| **173.1** | [**Facturation appel** (T1)](#t1) | MDI | - | Traitement |
| 173.1.1 | [Historique appel (T2)](#t2) | MDI | - | |
| 173.1.2 | [Historique appel (T3)](#t3) | MDI | - | |
| 173.1.3 | [Recuperation coef (T4)](#t4) | MDI | - | |
| 173.1.4 | [Deblocage cloture (T5)](#t5) | MDI | - | |
| 173.1.5 | [Deblocage cloture (T8)](#t8) | MDI | - | |

### 9.4 Algorigramme

```mermaid
flowchart TD
    START([START])
    PROCESS[Traitement 6 taches]
    ENDOK([END])
    START --> PROCESS --> ENDOK
    style START fill:#3fb950,color:#000
    style ENDOK fill:#3fb950,color:#000
```

> *algo-data indisponible. Utiliser `/algorigramme` pour generer.*

<!-- TAB:Donnees -->

## 10. TABLES

### Tables utilisees (3)

| ID | Nom | Description | Type | R | W | L | Usages |
|----|-----|-------------|------|---|---|---|--------|
| 23 | reseau_cloture___rec | Donnees reseau/cloture | DB |   | **W** |   | 2 |
| 155 | historique_pabx | Historique / journal | DB |   | **W** |   | 2 |
| 157 | coef__telephone__coe |  | DB |   | **W** |   | 1 |

### Colonnes par table (2 / 3 tables avec colonnes identifiees)

<details>
<summary>Table 23 - reseau_cloture___rec (**W**) - 2 usages</summary>

| Lettre | Variable | Acces | Type |
|--------|----------|-------|------|
| W | w0 cloture en cours | W | Logical |
| X | w0 test reseau | W | Alpha |

</details>



REFERENCE PATTERN (follow this exact structure):
```typescript
import { create } from 'zustand';
import type {
  ExtraitAccountInfo,
  ExtraitTransaction,
  ExtraitSummary,
  ExtraitPrintFormat,
} from '@/types/extrait';
import { extraitApi } from '@/services/api/endpoints-lot3';
import { useDataSourceStore } from './dataSourceStore';

interface ExtraitState {
  selectedAccount: ExtraitAccountInfo | null;
  transactions: ExtraitTransaction[];
  summary: ExtraitSummary | null;
  searchResults: ExtraitAccountInfo[];
  isSearching: boolean;
  isLoadingExtrait: boolean;
  isPrinting: boolean;
  error: string | null;
}

interface ExtraitActions {
  searchAccount: (societe: string, query: string) => Promise<void>;
  selectAccount: (account: ExtraitAccountInfo) => void;
  loadExtrait: (
    societe: string,
    codeAdherent: number,
    filiation: number,
    dateDebut?: string,
    dateFin?: string,
  ) => Promise<void>;
  printExtrait: (
    societe: string,
    codeAdherent: number,
    filiation: number,
    format: ExtraitPrintFormat,
  ) => Promise<void>;
  reset: () => void;
}

type ExtraitStore = ExtraitState & ExtraitActions;

const MOCK_ACCOUNTS: ExtraitAccountInfo[] = [
  { societe: 'SOC1', codeAdherent: 1001, filiation: 0, nom: 'DUPONT', prenom: 'Jean', statut: 'normal', hasGiftPass: false },
  { societe: 'SOC1', codeAdherent: 1002, filiation: 0, nom: 'MARTIN', prenom: 'Sophie', statut: 'normal', hasGiftPass: true },
  { societe: 'SOC1', codeAdherent: 1003, filiation: 1, nom: 'DURAND', prenom: 'Pierre', statut: 'bloque', hasGiftPass: false },
];

const MOCK_TRANSACTIONS: ExtraitTransaction[] = [
  { id: 1, date: '2026-02-10', heure: '09:15', libelle: 'Achat boutique', debit: 45.50, credit: 0, solde: -45.50, codeService: 'BTQ', codeImputation: 'IMP01', giftPassFlag: false, nbArticles: 3, status: 'debit', numeroPiece: 'VTE-001', modePaiement: 'CB', caissier: 'MARTIN S.' },
  { id: 2, date: '2026-02-10', heure: '14:30', libelle: 'Credit compte', debit: 0, credit: 200, solde: 154.50, codeService: 'CAI', codeImputation: 'IMP02', giftPassFlag: false, status: 'credit', numeroPiece: 'CRD-042', modePaiement: 'Especes', caissier: 'DUPONT J.' },
  { id: 3, date: '2026-02-09', heure: '12:45', libelle: 'Repas restaurant', libelleSupplementaire: 'Menu du jour', debit: 32.00, credit: 0, solde: 122.50, codeService: 'RST', codeImputation: 'IMP03', giftPassFlag: true, nbArticles: 1, status: 'debit', numeroPiece: 'RST-117', modePaiement: 'GiftPass', caissier: 'MARTIN S.' },
  { id: 4, date: '2026-02-08', heure: '16:00', libelle: 'Annulation vente', debit: 0, credit: 15.00, solde: 154.50, codeService: 'BTQ', codeImputation: 'IMP01', giftPassFlag: false, status: 'annule', numeroPiece: 'ANN-003', modePaiement: 'CB', caissier: 'DUPONT J.', commentaire: 'Erreur de saisie' },
  { id: 5, date: '2026-02-08', heure: '10:20', libelle: 'Regularisation solde', debit: 0, credit: 5.00, solde: 139.50, codeService: 'CAI', codeImputation: 'IMP02', giftPassFlag: false, status: 'regularise', numeroPiece: 'REG-007', modePaiement: 'Interne', caissier: 'ADMIN' },
];

const MOCK_SUMMARY: ExtraitSummary = {
  totalDebit: 77.50,
  totalCredit: 220,
  soldeActuel: 142.50,
  nbTransactions: 5,
};

const initialState: ExtraitState = {
  selectedAccount: null,
  transactions: [],
  summary: null,
  searchResults: [],
  isSearching: false,
  isLoadingExtrait: false,
  isPrinting: false,
  error: null,
};

export const useExtraitStore = create<ExtraitStore>()((set) => ({
  ...initialState,

  searchAccount: async (societe, query) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isSearching: true, error: null });

    if (!isRealApi) {
      const filtered = MOCK_ACCOUNTS.filter(
        (a) =>
          a.nom.toLowerCase().includes(query.toLowerCase()) ||
          a.prenom.toLowerCase().includes(query.toLowerCase()) ||
          String(a.codeAdherent).includes(query),
      );
      set({ searchResults: filtered, isSearching: false });
      return;
    }

    try {
      const response = await extraitApi.searchAccount(societe, query);
      set({ searchResults: response.data.data ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur recherche compte';
      set({ searchResults: [], error: message });
    } finally {
      set({ isSearching: false });
    }
  },

  selectAccount: (account) => {
    set({ selectedAccount: account, transactions: [], summary: null, error: null });
  },

  loadExtrait: async (societe, codeAdherent, filiation, dateDebut, dateFin) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoadingExtrait: true, error: null });

    if (!isRealApi) {
      set({
        transactions: MOCK_TRANSACTIONS,
        summary: MOCK_SUMMARY,
        isLoadingExtrait: false,
      });
      return;
    }

    try {
      const response = await extraitApi.getExtrait(
        societe,
        codeAdherent,
        filiation,
        dateDebut,
        dateFin,
      );
      const data = response.data.data;
      set({
        transactions: data?.transactions ?? [],
        summary: data?.summary ?? null,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement extrait';
      set({ transactions: [], summary: null, error: message });
    } finally {
      set({ isLoadingExtrait: false });
    }
  },

  printExtrait: async (societe, codeAdherent, filiation, format) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isPrinting: true, error: null });

    if (!isRealApi) {
      set({ isPrinting: false });
      return;
    }

    try {
      await extraitApi.printExtrait({
        societe,
        codeAdherent,
        filiation,
        format,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur impression';
      set({ error: message });
    } finally {
      set({ isPrinting: false });
    }
  },

  reset: () => set({ ...initialState }),
}));

```