Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/integriteDatesStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
integriteDatesStore checkOuverture should detect exceeded delay with mock data: AssertionError: expected true to be false // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/integriteDatesStore.test.ts:262:22
    at processTicksAndRejections (node:interna

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useIntegriteDatesStore } from '@/stores/integriteDatesStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import type { DateIntegrityCheck, DateComptable } from '@/types/integriteDates';
import { useDataSourceStore } from '@/stores/dataSourceStore';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(),
  },
}));

const MOCK_DATE_COMPTABLE: DateComptable = {
  checkType: 'O',
  societe: 'SOC1',
  controleOk: true,
  anomalieFermeture: false,
  dateComptable: '2026-02-20',
  delaiJours: 3,
};

const MOCK_VALIDATION_O: DateIntegrityCheck = {
  checkType: 'O',
  societe: 'SOC1',
  isValid: true,
  hasClosureAnomaly: false,
  timestamp: new Date().toISOString(),
};

const MOCK_VALIDATION_T: DateIntegrityCheck = {
  checkType: 'T',
  societe: 'SOC1',
  isValid: false,
  hasClosureAnomaly: false,
  errorMessage: 'Transaction timestamp invalide: session date/heure antérieure à maintenant',
  timestamp: new Date().toISOString(),
};

const MOCK_VALIDATION_F: DateIntegrityCheck = {
  checkType: 'F',
  societe: 'SOC1',
  isValid: false,
  hasClosureAnomaly: true,
  errorMessage: 'Anomalie détectée: fermeture bloquée',
  timestamp: new Date().toISOString(),
};

describe('integriteDatesStore', () => {
  beforeEach(() => {
    useIntegriteDatesStore.setState({
      checkType: 'O',
      societe: '',
      isLoading: false,
      error: null,
      validationResult: null,
      ouvertureValidation: null,
      transactionValidation: null,
      fermetureValidation: null,
    });
    vi.clearAllMocks();
  });

  describe('setCheckType', () => {
    it('should update checkType and clear error', () => {
      const store = useIntegriteDatesStore.getState();
      store.setError('previous error');
      
      store.setCheckType('T');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.checkType).toBe('T');
      expect(state.error).toBeNull();
    });
  });

  describe('setSociete', () => {
    it('should update societe and clear error', () => {
      const store = useIntegriteDatesStore.getState();
      store.setError('previous error');
      
      store.setSociete('SOC2');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.societe).toBe('SOC2');
      expect(state.error).toBeNull();
    });
  });

  describe('clearValidationResult', () => {
    it('should clear all validation results and error', () => {
      useIntegriteDatesStore.setState({
        validationResult: MOCK_VALIDATION_O,
        ouvertureValidation: { isValid: true, dateComptable: '2026-02-20', currentDate: '2026-02-21', delaiExceeded: false },
        error: 'some error',
      });
      
      const store = useIntegriteDatesStore.getState();
      store.clearValidationResult();
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toBeNull();
      expect(state.ouvertureValidation).toBeNull();
      expect(state.transactionValidation).toBeNull();
      expect(state.fermetureValidation).toBeNull();
      expect(state.error).toBeNull();
    });
  });

  describe('validateDateIntegrity', () => {
    it('should validate ouverture with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.validateDateIntegrity('O', 'SOC1');
      
      expect(result.checkType).toBe('O');
      expect(result.isValid).toBe(true);
      expect(result.hasClosureAnomaly).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toEqual(result);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should validate transaction with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.validateDateIntegrity('T', 'SOC1');
      
      expect(result.checkType).toBe('T');
      expect(result.isValid).toBe(false);
      expect(result.errorMessage).toBeDefined();
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toEqual(result);
      expect(state.isLoading).toBe(false);
    });

    it('should validate fermeture with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.validateDateIntegrity('F', 'SOC1');
      
      expect(result.checkType).toBe('F');
      expect(result.hasClosureAnomaly).toBe(true);
      expect(result.isValid).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toEqual(result);
    });

    it('should call API and update state when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: MOCK_VALIDATION_O,
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.validateDateIntegrity('O', 'SOC1');
      
      expect(apiClient.post).toHaveBeenCalledWith('/api/controles/integrite-dates', {
        checkType: 'O',
        societe: 'SOC1',
      });
      expect(result).toEqual(MOCK_VALIDATION_O);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toEqual(MOCK_VALIDATION_O);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should handle API error and set error state', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const error = new Error('API error');
      vi.mocked(apiClient.post).mockRejectedValue(error);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.validateDateIntegrity('O', 'SOC1')).rejects.toThrow('API error');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.validationResult).toBeNull();
      expect(state.error).toBe('API error');
      expect(state.isLoading).toBe(false);
    });

    it('should throw error when API returns invalid response', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: null as never,
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.validateDateIntegrity('O', 'SOC1')).rejects.toThrow('Réponse invalide du serveur');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.error).toBe('Réponse invalide du serveur');
    });
  });

  describe('checkOuverture', () => {
    it('should validate opening with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkOuverture('SOC1');
      
      expect(result).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.ouvertureValidation).toBeDefined();
      expect(state.ouvertureValidation?.dateComptable).toBe('2026-02-20');
      expect(state.isLoading).toBe(false);
    });

    it('should detect exceeded delay with mock data', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const pastDate = new Date();
      pastDate.setDate(pastDate.getDate() - 10);
      const mockPastData = {
        ...MOCK_DATE_COMPTABLE,
        dateComptable: pastDate.toISOString().split('T')[0],
      };
      
      useIntegriteDatesStore.setState({
        checkType: 'O',
        societe: 'SOC1',
        isLoading: false,
        error: null,
        validationResult: null,
        ouvertureValidation: null,
        transactionValidation: null,
        fermetureValidation: null,
      });
      
      const store = useIntegriteDatesStore.getState();
      const originalMock = MOCK_DATE_COMPTABLE.dateComptable;
      MOCK_DATE_COMPTABLE.dateComptable = mockPastData.dateComptable;
      
      const result = await store.checkOuverture('SOC1');
      
      MOCK_DATE_COMPTABLE.dateComptable = originalMock;
      
      expect(result).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.ouvertureValidation?.delaiExceeded).toBe(true);
    });

    it('should call API and validate against date comptable when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 5);
      const mockData: DateComptable = {
        ...MOCK_DATE_COMPTABLE,
        dateComptable: futureDate.toISOString().split('T')[0],
      };
      const mockResponse: ApiResponse<DateComptable> = {
        success: true,
        data: mockData,
      };
      vi.mocked(apiClient.get).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkOuverture('SOC1');
      
      expect(apiClient.get).toHaveBeenCalledWith('/api/controles/date-comptable', {
        params: { societe: 'SOC1', checkType: 'O' },
      });
      expect(result).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.ouvertureValidation?.isValid).toBe(true);
      expect(state.ouvertureValidation?.delaiExceeded).toBe(false);
    });

    it('should handle API error during ouverture check', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const error = new Error('Network error');
      vi.mocked(apiClient.get).mockRejectedValue(error);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.checkOuverture('SOC1')).rejects.toThrow('Network error');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.ouvertureValidation).toBeNull();
      expect(state.error).toBe('Network error');
    });
  });

  describe('checkTransaction', () => {
    it('should validate transaction timestamp with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const pastDate = new Date();
      pastDate.setHours(pastDate.getHours() - 1);
      const dateSession = pastDate.toISOString().split('T')[0];
      const heureSession = `${pastDate.getHours().toString().padStart(2, '0')}:${pastDate.getMinutes().toString().padStart(2, '0')}`;
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkTransaction('SOC1', dateSession, heureSession);
      
      expect(result).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.transactionValidation).toBeDefined();
      expect(state.transactionValidation?.isTimestampValid).toBe(true);
    });

    it('should detect invalid future timestamp with mock data', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const futureDate = new Date();
      futureDate.setHours(futureDate.getHours() + 2);
      const dateSession = futureDate.toISOString().split('T')[0];
      const heureSession = `${futureDate.getHours().toString().padStart(2, '0')}:${futureDate.getMinutes().toString().padStart(2, '0')}`;
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkTransaction('SOC1', dateSession, heureSession);
      
      expect(result).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.transactionValidation?.isValid).toBe(false);
    });

    it('should call API and validate transaction when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: { ...MOCK_VALIDATION_T, isValid: true },
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkTransaction('SOC1', '2026-02-20', '10:30');
      
      expect(apiClient.post).toHaveBeenCalledWith('/api/controles/integrite-dates', {
        checkType: 'T',
        societe: 'SOC1',
        dateSession: '2026-02-20',
        heureSession: '10:30',
      });
      expect(result).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.transactionValidation?.isValid).toBe(true);
    });

    it('should handle API error during transaction check', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const error = new Error('Validation failed');
      vi.mocked(apiClient.post).mockRejectedValue(error);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.checkTransaction('SOC1', '2026-02-20', '10:30')).rejects.toThrow('Validation failed');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.transactionValidation).toBeNull();
      expect(state.error).toBe('Validation failed');
    });
  });

  describe('checkFermeture', () => {
    it('should detect closure anomaly with mock data when isRealApi is false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkFermeture('SOC1');
      
      expect(result.isValid).toBe(false);
      expect(result.hasAnomaly).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.fermetureValidation?.hasAnomaly).toBe(true);
      expect(state.fermetureValidation?.blockedReason).toBeDefined();
    });

    it('should call API and detect closure anomaly when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: MOCK_VALIDATION_F,
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkFermeture('SOC1');
      
      expect(apiClient.post).toHaveBeenCalledWith('/api/controles/integrite-dates', {
        checkType: 'F',
        societe: 'SOC1',
      });
      expect(result.isValid).toBe(false);
      expect(result.hasAnomaly).toBe(true);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.fermetureValidation?.hasAnomaly).toBe(true);
      expect(state.fermetureValidation?.blockedReason).toBe('Anomalie détectée: fermeture bloquée');
    });

    it('should validate successful closure when no anomaly', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const mockResponse: ApiResponse<DateIntegrityCheck> = {
        success: true,
        data: { ...MOCK_VALIDATION_F, isValid: true, hasClosureAnomaly: false, errorMessage: undefined },
      };
      vi.mocked(apiClient.post).mockResolvedValue({ data: mockResponse } as never);
      
      const store = useIntegriteDatesStore.getState();
      const result = await store.checkFermeture('SOC1');
      
      expect(result.isValid).toBe(true);
      expect(result.hasAnomaly).toBe(false);
      
      const state = useIntegriteDatesStore.getState();
      expect(state.fermetureValidation?.isValid).toBe(true);
      expect(state.fermetureValidation?.hasAnomaly).toBe(false);
      expect(state.fermetureValidation?.blockedReason).toBeUndefined();
    });

    it('should handle API error during fermeture check', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      const error = new Error('Server error');
      vi.mocked(apiClient.post).mockRejectedValue(error);
      
      const store = useIntegriteDatesStore.getState();
      
      await expect(store.checkFermeture('SOC1')).rejects.toThrow('Server error');
      
      const state = useIntegriteDatesStore.getState();
      expect(state.fermetureValidation).toBeNull();
      expect(state.error).toBe('Server error');
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      useIntegriteDatesStore.setState({
        checkType: 'F',
        societe: 'SOC2',
        isLoading: true,
        error: 'some error',
        validationResult: MOCK_VALIDATION_O,
        ouvertureValidation: { isValid: true, dateComptable: '2026-02-20', currentDate: '2026-02-21', delaiExceeded: false },
      });
      
      const store = useIntegriteDatesStore.getState();
      store.reset();
      
      const state = useIntegriteDatesStore.getState();
      expect(state.checkType).toBe('O');
      expect(state.societe).toBe('');
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.validationResult).toBeNull();
      expect(state.ouvertureValidation).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  DateIntegrityCheck,
  DateComptable,
  OuvertureValidation,
  TransactionValidation,
  FermetureValidation,
  DateCheckType,
} from '@/types/integriteDates';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface IntegriteDatesState {
  checkType: DateCheckType;
  societe: string;
  isLoading: boolean;
  error: string | null;
  validationResult: DateIntegrityCheck | null;
  ouvertureValidation: OuvertureValidation | null;
  transactionValidation: TransactionValidation | null;
  fermetureValidation: FermetureValidation | null;
}

interface IntegriteDatesActions {
  setCheckType: (checkType: DateCheckType) => void;
  setSociete: (societe: string) => void;
  setError: (error: string | null) => void;
  clearValidationResult: () => void;
  validateDateIntegrity: (checkType: DateCheckType, societe: string) => Promise<DateIntegrityCheck>;
  checkOuverture: (societe: string) => Promise<boolean>;
  checkTransaction: (societe: string, dateSession: string, heureSession: string) => Promise<boolean>;
  checkFermeture: (societe: string) => Promise<{ isValid: boolean; hasAnomaly: boolean }>;
  reset: () => void;
}

type IntegriteDatesStore = IntegriteDatesState & IntegriteDatesActions;

const MOCK_DATE_COMPTABLE: DateComptable = {
  checkType: 'O',
  societe: 'SOC1',
  controleOk: true,
  anomalieFermeture: false,
  dateComptable: '2026-02-20',
  delaiJours: 3,
};

const MOCK_VALIDATIONS: Record<DateCheckType, DateIntegrityCheck> = {
  O: {
    checkType: 'O',
    societe: 'SOC1',
    isValid: true,
    hasClosureAnomaly: false,
    timestamp: new Date().toISOString(),
  },
  T: {
    checkType: 'T',
    societe: 'SOC1',
    isValid: false,
    hasClosureAnomaly: false,
    errorMessage: 'Transaction timestamp invalide: session date/heure antérieure à maintenant',
    timestamp: new Date().toISOString(),
  },
  F: {
    checkType: 'F',
    societe: 'SOC1',
    isValid: false,
    hasClosureAnomaly: true,
    errorMessage: 'Anomalie détectée: fermeture bloquée',
    timestamp: new Date().toISOString(),
  },
};

const initialState: IntegriteDatesState = {
  checkType: 'O',
  societe: '',
  isLoading: false,
  error: null,
  validationResult: null,
  ouvertureValidation: null,
  transactionValidation: null,
  fermetureValidation: null,
};

export const useIntegriteDatesStore = create<IntegriteDatesStore>()((set, get) => ({
  ...initialState,

  setCheckType: (checkType) => {
    set({ checkType, error: null });
  },

  setSociete: (societe) => {
    set({ societe, error: null });
  },

  setError: (error) => {
    set({ error });
  },

  clearValidationResult: () => {
    set({
      validationResult: null,
      ouvertureValidation: null,
      transactionValidation: null,
      fermetureValidation: null,
      error: null,
    });
  },

  validateDateIntegrity: async (checkType, societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const mockResult = MOCK_VALIDATIONS[checkType];
      set({
        validationResult: mockResult,
        isLoading: false,
      });
      return mockResult;
    }

    try {
      const response = await apiClient.post<ApiResponse<DateIntegrityCheck>>(
        '/api/controles/integrite-dates',
        { checkType, societe },
      );

      const result = response.data.data;
      if (!result) {
        throw new Error('Réponse invalide du serveur');
      }

      set({ validationResult: result });
      return result;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation intégrité dates';
      set({ validationResult: null, error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  checkOuverture: async (societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const currentDate = new Date();
      const dateComptable = new Date(MOCK_DATE_COMPTABLE.dateComptable);
      const delai = MOCK_DATE_COMPTABLE.delaiJours;
      const dateLimit = new Date(dateComptable);
      dateLimit.setDate(dateLimit.getDate() + delai);

      const isValid = currentDate <= dateLimit;
      const validation: OuvertureValidation = {
        isValid,
        dateComptable: MOCK_DATE_COMPTABLE.dateComptable,
        currentDate: currentDate.toISOString().split('T')[0],
        delaiExceeded: currentDate > dateLimit,
      };

      set({
        ouvertureValidation: validation,
        isLoading: false,
      });
      return isValid;
    }

    try {
      const response = await apiClient.get<ApiResponse<DateComptable>>(
        '/api/controles/date-comptable',
        { params: { societe, checkType: 'O' } },
      );

      const data = response.data.data;
      if (!data) {
        throw new Error('Réponse invalide du serveur');
      }

      const currentDate = new Date();
      const dateComptable = new Date(data.dateComptable);
      const dateLimit = new Date(dateComptable);
      dateLimit.setDate(dateLimit.getDate() + data.delaiJours);

      const isValid = currentDate <= dateLimit && data.controleOk;
      const validation: OuvertureValidation = {
        isValid,
        dateComptable: data.dateComptable,
        currentDate: currentDate.toISOString().split('T')[0],
        delaiExceeded: currentDate > dateLimit,
      };

      set({ ouvertureValidation: validation });
      return isValid;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur contrôle ouverture';
      set({ ouvertureValidation: null, error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  checkTransaction: async (societe, dateSession, heureSession) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const currentTimestamp = Date.now();
      const sessionDate = new Date(dateSession);
      const [hours, minutes] = heureSession.split(':').map(Number);
      sessionDate.setHours(hours, minutes, 0, 0);
      const sessionTimestamp = sessionDate.getTime();

      const isValid = currentTimestamp >= sessionTimestamp;
      const validation: TransactionValidation = {
        isValid,
        dateSession,
        heureSession,
        currentTimestamp,
        sessionTimestamp,
        isTimestampValid: isValid,
      };

      set({
        transactionValidation: validation,
        isLoading: false,
      });
      return isValid;
    }

    try {
      const response = await apiClient.post<ApiResponse<DateIntegrityCheck>>(
        '/api/controles/integrite-dates',
        { checkType: 'T', societe, dateSession, heureSession },
      );

      const result = response.data.data;
      if (!result) {
        throw new Error('Réponse invalide du serveur');
      }

      const currentTimestamp = Date.now();
      const sessionDate = new Date(dateSession);
      const [hours, minutes] = heureSession.split(':').map(Number);
      sessionDate.setHours(hours, minutes, 0, 0);
      const sessionTimestamp = sessionDate.getTime();

      const validation: TransactionValidation = {
        isValid: result.isValid,
        dateSession,
        heureSession,
        currentTimestamp,
        sessionTimestamp,
        isTimestampValid: result.isValid,
      };

      set({ transactionValidation: validation });
      return result.isValid;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur contrôle transaction';
      set({ transactionValidation: null, error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  checkFermeture: async (societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const hasAnomaly = MOCK_VALIDATIONS.F.hasClosureAnomaly;
      const validation: FermetureValidation = {
        isValid: !hasAnomaly,
        hasAnomaly,
        blockedReason: hasAnomaly ? 'Anomalie de fermeture détectée' : undefined,
      };

      set({
        fermetureValidation: validation,
        isLoading: false,
      });
      return { isValid: !hasAnomaly, hasAnomaly };
    }

    try {
      const response = await apiClient.post<ApiResponse<DateIntegrityCheck>>(
        '/api/controles/integrite-dates',
        { checkType: 'F', societe },
      );

      const result = response.data.data;
      if (!result) {
        throw new Error('Réponse invalide du serveur');
      }

      const validation: FermetureValidation = {
        isValid: result.isValid && !result.hasClosureAnomaly,
        hasAnomaly: result.hasClosureAnomaly,
        blockedReason: result.hasClosureAnomaly ? result.errorMessage : undefined,
      };

      set({ fermetureValidation: validation });
      return { isValid: validation.isValid, hasAnomaly: result.hasClosureAnomaly };
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur contrôle fermeture';
      set({ fermetureValidation: null, error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.