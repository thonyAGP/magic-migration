```json
{
  "programId": 254,
  "programName": "Solde Resort Credit",
  "coveragePct": 0,
  "rulesImplemented": 0,
  "rulesTotal": 1,
  "missingRules": [
    "RM-001: Calcul du solde Resort Credit (IF attribué > utilisé THEN attribué - utilisé ELSE 0) - MANQUANT dans le store TypeScript"
  ],
  "missingImplementations": [
    "Table 980 (resort_credit) - Aucune entité TypeScript définie",
    "API endpoint GET /api/ventes/solde-resortcredit/{societe}/{compte}/{filiation}/{service} - Non câblé",
    "Logique métier: Le calcul 'IF([J]>[K], [J]-[K], 0)' où J=attribué, K=utilisé n'est pas visible dans le code généré"
  ],
  "foundImplementations": [
    "ResortCreditDisplayPanel.tsx - Affichage UI des soldes avec mock data",
    "Type SoldeResortCredit défini avec propriétés: societe, compte, filiation, service, attribue, utilise, solde",
    "Formatage devise via Intl.NumberFormat FR",
    "Gestion du mock avec données statiques (SPA: 500-150=350, RESTAURANT: 1000-450=550, BAR: 300-300=0)"
  ],
  "gapAnalysis": {
    "businessLogic": "MANQUANT - La règle RM-001 devrait être implémentée dans le store lors de la récupération des données, mais le calcul est présent uniquement dans les données MOCK statiques",
    "dataLayer": "INCOMPLET - Pas d'entité TypeScript pour la table resort_credit (T980), utilise directement l'interface inline",
    "apiIntegration": "MANQUANT - L'endpoint API /api/ventes/solde-resortcredit n'est pas dans endpoints-saisieContenuCaisse.ts",
    "stateManagement": "MANQUANT - Aucune action Zustand pour récupérer/calculer les soldes Resort Credit dans saisieContenuCaisseStore.ts"
  },
  "recommendations": [
    "CRITIQUE: Implémenter la règle RM-001 dans le store - Ajouter une méthode computeSolde(attribue: number, utilise: number): number { return attribue > utilise ? attribue - utilise : 0; }",
    "CRITIQUE: Créer types/resortCredit.ts avec l'entité ResortCreditEntity (basée sur table T980)",
    "CRITIQUE: Ajouter l'endpoint dans services/api/endpoints-resortCredit.ts: getResortCreditSolde(societe, compte, filiation, service?)",
    "IMPORTANT: Intégrer la récupération des soldes dans saisieContenuCaisseStore via une action loadResortCredits()",
    "IMPORTANT: Remplacer les données MOCK statiques par un appel API réel avec fallback sur mock (pattern useDataSourceStore)",
    "IMPORTANT: Ajouter la validation du calcul dans les tests unitaires (__tests__/resortCreditStore.test.ts)",
    "MINEUR: Le composant ResortCreditDisplayPanel devrait être dans components/caisse/resortCredit/ pour cohérence avec la structure",
    "MINEUR: Ajouter un indicateur visuel (badge rouge/vert) quand solde = 0 pour UX",
    "SUGGESTION: Documenter la correspondance [J]=attribue, [K]=utilise dans un commentaire du code source"
  ],
  "testCoverage": {
    "unitTests": "MANQUANT - Aucun fichier __tests__/resortCreditStore.test.ts trouvé",
    "integrationTests": "MANQUANT - Aucun test E2E pour le workflow Resort Credit",
    "mockDataQuality": "BON - Les données MOCK respectent la logique métier (SPA: 500-150=350, BAR: 300-300=0)"
  },
  "architectureCompliance": {
    "storePattern": "NON RESPECTÉ - La logique métier RM-001 devrait être dans le store, pas dans les données statiques",
    "apiPattern": "NON RESPECTÉ - Endpoint manquant dans endpoints-*.ts",
    "typePattern": "PARTIEL - Interface définie mais pas d'entité TypeScript dédiée",
    "uiPattern": "RESPECTÉ - Composant UI séparé avec formatage correct"
  },
  "securityCheck": {
    "sqlInjection": "N/A - Pas de requête SQL directe",
    "xss": "OK - Utilise formatCurrency pour sanitize",
    "authz": "À VÉRIFIER - Pas de vérification visible des droits d'accès au compte/filiation"
  },
  "overallScore": 15,
  "scoreBreakdown": {
    "businessRules": "0/25 - Règle RM-001 non implémentée dans le code métier",
    "dataLayer": "5/20 - Interface définie mais pas d'entité ni d'endpoint",
    "stateManagement": "0/20 - Pas de gestion d'état Zustand pour Resort Credit",
    "uiImplementation": "10/15 - UI présente et fonctionnelle avec mock",
    "testCoverage": "0/10 - Aucun test",
    "documentation": "0/10 - Pas de commentaires sur la règle métier"
  },
  "criticalIssues": [
    "La règle métier RM-001 'IF(attribué > utilisé, attribué - utilisé, 0)' N'EST PAS implémentée dans le code TypeScript - elle existe uniquement dans les données MOCK statiques",
    "L'endpoint API /api/ventes/solde-resortcredit n'existe pas, donc impossible de passer en mode API réel",
    "Aucun test pour valider le calcul du solde"
  ],
  "verdict": "❌ ÉCHEC - Le code généré est un prototype UI avec données statiques, mais la règle métier contractuelle RM-001 n'est PAS implémentée dans la logique applicative. Le contrat indique 100% de couverture (status: enriched) mais c'est une fausse représentation."
}
```

**Résumé Exécutif:**

Le code généré pour ADH IDE 254 (Solde Resort Credit) présente une **discordance critique** entre le contrat (qui indique 100% de couverture) et l'implémentation réelle:

1. **Règle métier RM-001 NON implémentée** - Le calcul `IF(attribué > utilisé, attribué - utilisé, 0)` existe uniquement dans les données MOCK statiques, pas dans la logique applicative du store

2. **Couche données incomplète** - Pas d'entité TypeScript pour table T980, pas d'endpoint API

3. **Tests absents** - Aucune validation du comportement attendu

**Action requise:** Implémenter la règle RM-001 dans le store Zustand avec méthode dédiée + tests unitaires avant de pouvoir considérer ce programme comme "migré".