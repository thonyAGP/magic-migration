Review the generated code against the original specification.

Produce a JSON report:
```json
{
  "programId": 0,
  "programName": "",
  "coveragePct": 0,
  "rulesImplemented": 0,
  "rulesTotal": 0,
  "missingRules": [
    "rule descriptions not implemented"
  ],
  "recommendations": [
    "improvement suggestions"
  ]
}
```

Check:
1. Every business rule from the contract is implemented in the store
2. Every table from the contract has corresponding entity types
3. Every API endpoint is wired to the store
4. UI layout matches the spec description
5. Error handling is present for all actions

CONTRACT RULES:
[
  {
    "id": "RM-001",
    "description": "Si > GO [G] alors 'GO' sinon 'GM')",
    "condition": "> GO [G]",
    "variables": [
      "G"
    ],
    "status": "IMPL",
    "targetFile": "adh-web/src/stores/saisieContenuCaisseStore.ts",
    "gapNotes": ""
  }
]

SPEC EXCERPT:
﻿# ADH IDE 173 - Facturation appel

> **Analyse**: Phases 1-4 2026-02-03 10:54 -> 10:54 (16s) | Assemblage 07:23
> **Pipeline**: V7.2 Enrichi
> **Structure**: 4 onglets (Resume | Ecrans | Donnees | Connexions)

<!-- TAB:Resume -->

## 1. FICHE D'IDENTITE

| Attribut | Valeur |
|----------|--------|
| Projet | ADH |
| IDE Position | 173 |
| Nom Programme | Facturation appel |
| Fichier source | `Prg_173.xml` |
| Dossier IDE | Operations |
| Taches | 6 (0 ecrans visibles) |
| Tables modifiees | 3 |
| Programmes appeles | 5 |

## 2. DESCRIPTION FONCTIONNELLE

**Facturation appel** assure la gestion complete de ce processus, accessible depuis [Menu caisse GM - scroll @ (IDE 22)](ADH-IDE-22.md).

Le flux de traitement s'organise en **1 blocs fonctionnels** :

- **Traitement** (6 taches) : traitements metier divers

**Donnees modifiees** : 3 tables en ecriture (reseau_cloture___rec, historique_pabx, coef__telephone__coe).

**Logique metier** : 1 regles identifiees couvrant conditions metier.

<details>
<summary>Detail : phases du traitement</summary>

#### Phase 1 : Traitement (6 taches)

- **T1** - Facturation appel
- **T2** - Historique appel
- **T3** - Historique appel
- **T4** - Recuperation coef
- **T5** - Deblocage cloture
- **T8** - Deblocage cloture

Delegue a : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

#### Tables impactees

| Table | Operations | Role metier |
|-------|-----------|-------------|
| reseau_cloture___rec | **W** (2 usages) | Donnees reseau/cloture |
| historique_pabx | **W** (2 usages) | Historique / journal |
| coef__telephone__coe | **W** (1 usages) |  |

</details>

## 3. BLOCS FONCTIONNELS

### 3.1 Traitement (6 taches)

Traitements internes.

---

#### <a id="t1"></a>T1 - Facturation appel

**Role** : Tache d'orchestration : point d'entree du programme (6 sous-taches). Coordonne l'enchainement des traitements.

<details>
<summary>5 sous-taches directes</summary>

| Tache | Nom | Bloc |
|-------|-----|------|
| [T2](#t2) | Historique appel | Traitement |
| [T3](#t3) | Historique appel | Traitement |
| [T4](#t4) | Recuperation coef | Traitement |
| [T5](#t5) | Deblocage cloture | Traitement |
| [T8](#t8) | Deblocage cloture | Traitement |

</details>
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t2"></a>T2 - Historique appel

**Role** : Consultation/chargement : Historique appel.
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t3"></a>T3 - Historique appel

**Role** : Consultation/chargement : Historique appel.
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t4"></a>T4 - Recuperation coef

**Role** : Consultation/chargement : Recuperation coef.
**Variables liees** : V (w0 coeff tel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t5"></a>T5 - Deblocage cloture

**Role** : Traitement : Deblocage cloture.
**Variables liees** : W (w0 cloture en cours)
**Delegue a** : [  Deblocage compte GM (IDE 17)](ADH-IDE-17.md), [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t8"></a>T8 - Deblocage cloture

**Role** : Traitement : Deblocage cloture.
**Variables liees** : W (w0 cloture en cours)
**Delegue a** : [  Deblocage compte GM (IDE 17)](ADH-IDE-17.md), [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)


## 5. REGLES METIER

1 regles identifiees:

### Autres (1 regles)

#### <a id="rm-RM-001"></a>[RM-001] Si > GO [G] alors 'GO' sinon 'GM')

| Element | Detail |
|---------|--------|
| **Condition** | `> GO [G]` |
| **Si vrai** | 'GO' |
| **Si faux** | 'GM') |
| **Variables** | G (> GO) |
| **Expression source** | Expression 4 : `IF (> GO [G],'GO','GM')` |
| **Exemple** | Si > GO [G] â†’ 'GO'. Sinon â†’ 'GM') |

## 6. CONTEXTE

- **Appele par**: [Menu caisse GM - scroll @ (IDE 22)](ADH-IDE-22.md)
- **Appelle**: 5 programmes | **Tables**: 3 (W:3 R:0 L:0) | **Taches**: 6 | **Expressions**: 15

<!-- TAB:Ecrans -->

## 8. ECRANS

*(Programme sans ecran visible)*

## 9. NAVIGATION

### 9.3 Structure hierarchique (6 taches)

| Position | Tache | Type | Dimensions | Bloc |
|----------|-------|------|------------|------|
| **173.1** | [**Facturation appel** (T1)](#t1) | MDI | - | Traitement |
| 173.1.1 | [Historique appel (T2)](#t2) | MDI | - | |
| 173.1.2 | [Historique appel (T3)](#t3) | MDI | - | |
| 173.1.3 | [Recuperation coef (T4)](#t4) | MDI | - | |
| 173.1.4 | [Deblocage cloture (T5)](#t5) | MDI | - | |
| 173.1.5 | [Deblocage cloture (T8)](#t8) | MDI | - | 

GENERATED FILES:

--- types/facturationAppel.ts ---
import type { ApiResponse } from "@/services/api/apiClient";

export type QualiteAppel = 'OK' | 'Mauvaise' | 'Interruption';
export type TypeCompte = 'GO' | 'GM';

export interface HistoriqueAppel {
  id?: number;
  societe: string;
  prefixe: string;
  dateAppel: Date;
  heureAppel: string;
  numeroTel: string;
  duree: string;
  montant: number;
  qualite: QualiteAppel | null;
  gratuite: boolean;
  raisonGratuite: string | null;
  facture?: boolean;
  operationId?: number;
}

export interface CoefTelephone {
  coefficient: number;
}

export interface ReseauCloture {
  cloture_enCours: boolean;
  testReseau: string | null;
}

export interface FacturationRequest {
  appel: HistoriqueAppel;
  numeroCompte: number;
  filiation: number;
  typeCompte: TypeCompte;
}

export interface FacturationResponse {
  success: boolean;
  operationId?: number;
  message?: string;
}

export interface MarquerGratuitRequest {
  appelId: number;
  raison: string;
}

export interface AnnulerFacturationRequest {
  appelId: number;
}

export interface FacturationAppelState {
  historiqueAppels: HistoriqueAppel[];
  coefficientTelephone: number | null;
  cloture: ReseauCloture | null;
  isLoading: boolean;
  error: string | null;
  filterSociete: string;
  filterDateDebut: Date | null;
  filterDateFin: Date | null;
}

export interface FacturationAppelActions {
  chargerHistoriqueAppels: (
    societe: string,
    prefixe: string,
    dateDebut?: Date,
    dateFin?: Date
  ) => Promise<void>;
  recupererCoefficient: () => Promise<void>;
  facturationAppel: (request: FacturationRequest) => Promise<void>;
  verifierCloture: () => Promise<boolean>;
  debloquerCloture: () => Promise<void>;
  marquerGratuit: (appelId: number, raison: string) => Promise<void>;
  annulerFacturation: (appelId: number) => Promise<void>;
  setFilterSociete: (societe: string) => void;
  setFilterDateDebut: (date: Date | null) => void;
  setFilterDateFin: (date: Date | null) => void;
  resetFilters: () => void;
  setEr

--- stores/facturationAppelStore.ts ---
import { create } from 'zustand';
import type {
  HistoriqueAppel,
  CoefTelephone,
  ReseauCloture,
  FacturationRequest,
  MarquerGratuitRequest,
  AnnulerFacturationRequest,
  GetHistoriqueAppelsResponse,
  GetCoefficientResponse,
  FacturerAppelResponse,
  GetClotureStatusResponse,
  DebloquerClotureResponse,
  MarquerGratuitResponse,
  AnnulerFacturationResponse,
} from '@/types/facturationAppel';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface FacturationAppelState {
  historiqueAppels: HistoriqueAppel[];
  coefficientTelephone: number | null;
  cloture: ReseauCloture | null;
  isLoading: boolean;
  error: string | null;
  filterSociete: string;
  filterDateDebut: Date | null;
  filterDateFin: Date | null;
}

interface FacturationAppelActions {
  chargerHistoriqueAppels: (
    societe: string,
    prefixe: string,
    dateDebut?: Date,
    dateFin?: Date
  ) => Promise<void>;
  recupererCoefficient: () => Promise<void>;
  facturerAppel: (request: FacturationRequest) => Promise<void>;
  verifierCloture: () => Promise<boolean>;
  debloquerCloture: () => Promise<void>;
  marquerGratuit: (appelId: number, raison: string) => Promise<void>;
  annulerFacturation: (appelId: number) => Promise<void>;
  setFilterSociete: (societe: string) => void;
  setFilterDateDebut: (date: Date | null) => void;
  setFilterDateFin: (date: Date | null) => void;
  resetFilters: () => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

type FacturationAppelStore = FacturationAppelState & FacturationAppelActions;

const MOCK_HISTORIQUE: HistoriqueAppel[] = [
  {
    id: 1,
    societe: 'SOC1',
    prefixe: 'CAI01',
    dateAppel: new Date('2026-02-20T09:15:00'),
    heureAppel: '09:15:23',
    numeroTel: '+33612345678',
    duree: '00:12:35',
    montant: 1.89,
    qualite: 'OK',
    gratuite: false,
    raisonGratuite: null,
    facture: false,
  },
  {
    id: 2,
    societe: 'SOC1',
  

--- services/api/endpoints-facturationAppel.ts ---
import { apiClient, type ApiResponse } from './apiClient';
import type {
  HistoriqueAppel,
  CoefTelephone,
  ReseauCloture,
  FacturationRequest,
  FacturationResponse,
  MarquerGratuitRequest,
  AnnulerFacturationRequest,
  GetHistoriqueAppelsResponse,
  GetCoefficientResponse,
  FacturerAppelResponse,
  GetClotureStatusResponse,
  DebloquerClotureResponse,
  MarquerGratuitResponse,
  AnnulerFacturationResponse,
} from '@/types/facturationAppel';

export const facturationAppelApi = {
  getHistoriqueAppels: (
    societe: string,
    prefixe: string,
    dateDebut?: Date,
    dateFin?: Date,
  ) => {
    const params = new URLSearchParams();
    params.append('societe', societe);
    params.append('prefixe', prefixe);
    if (dateDebut) {
      params.append('dateDebut', dateDebut.toISOString().split('T')[0]);
    }
    if (dateFin) {
      params.append('dateFin', dateFin.toISOString().split('T')[0]);
    }
    return apiClient.get<GetHistoriqueAppelsResponse>(
      `/api/facturation-appel/historique?${params.toString()}`,
    );
  },

  getCoefficient: () =>
    apiClient.get<GetCoefficientResponse>(
      '/api/facturation-appel/coefficient',
    ),

  facturer: (request: FacturationRequest) =>
    apiClient.post<FacturerAppelResponse>(
      '/api/facturation-appel/facturer',
      request,
    ),

  getClotureStatus: () =>
    apiClient.get<GetClotureStatusResponse>(
      '/api/facturation-appel/cloture-status',
    ),

  debloquerCloture: () =>
    apiClient.post<DebloquerClotureResponse>(
      '/api/facturation-appel/debloquer-cloture',
      {},
    ),

  marquerGratuit: (id: number, request: MarquerGratuitRequest) =>
    apiClient.put<MarquerGratuitResponse>(
      `/api/facturation-appel/marquer-gratuit/${id}`,
      request,
    ),

  annulerFacturation: (id: number, request: AnnulerFacturationRequest) =>
    apiClient.delete<AnnulerFacturationResponse>(
      `/api/facturation-appel/annuler/${id}`,
      request,
    ),
};

--- pages/FacturationAppelPage.tsx ---
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Button, Dialog, Input } from '@/components/ui';
import { useFacturationAppelStore } from '@/stores/facturationAppelStore';
import { useAuthStore } from '@/stores';
import type { HistoriqueAppel, FacturationRequest } from '@/types/facturationAppel';
import { cn } from '@/lib/utils';

export function FacturationAppelPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);

  const historiqueAppels = useFacturationAppelStore((s) => s.historiqueAppels);
  const coefficientTelephone = useFacturationAppelStore((s) => s.coefficientTelephone);
  const cloture = useFacturationAppelStore((s) => s.cloture);
  const isLoading = useFacturationAppelStore((s) => s.isLoading);
  const error = useFacturationAppelStore((s) => s.error);
  const filterSociete = useFacturationAppelStore((s) => s.filterSociete);
  const filterDateDebut = useFacturationAppelStore((s) => s.filterDateDebut);
  const filterDateFin = useFacturationAppelStore((s) => s.filterDateFin);

  const chargerHistoriqueAppels = useFacturationAppelStore((s) => s.chargerHistoriqueAppels);
  const recupererCoefficient = useFacturationAppelStore((s) => s.recupererCoefficient);
  const facturerAppel = useFacturationAppelStore((s) => s.facturerAppel);
  const verifierCloture = useFacturationAppelStore((s) => s.verifierCloture);
  const debloquerCloture = useFacturationAppelStore((s) => s.debloquerCloture);
  const marquerGratuit = useFacturationAppelStore((s) => s.marquerGratuit);
  const annulerFacturation = useFacturationAppelStore((s) => s.annulerFacturation);
  const setFilterSociete = useFacturationAppelStore((s) => s.setFilterSociete);
  const setFilterDateDebut = useFacturationAppelStore((s) => s.setFilterDateDebut);
  const setFilterDateFin = useFacturationAppelStore((s) => s.setFilterDateFin);
  const resetFilters = useFact

--- components/caisse/facturationAppel/ActionsPanel.tsx ---
import type { HistoriqueAppel } from "@/types/facturationAppel";
import { Button } from "@/components/ui";
import { cn } from "@/lib/utils";

interface ActionsPanelProps {
  selectedAppel: HistoriqueAppel | null;
  onFacturer: () => void;
  onMarquerGratuit: () => void;
  onAnnuler: () => void;
  isLoading: boolean;
  className?: string;
}

export const ActionsPanel = ({
  selectedAppel,
  onFacturer,
  onMarquerGratuit,
  onAnnuler,
  isLoading,
  className,
}: ActionsPanelProps) => {
  const canFacturer = selectedAppel && !selectedAppel.facture && !selectedAppel.gratuite;
  const canMarquerGratuit = selectedAppel && !selectedAppel.facture && !selectedAppel.gratuite;
  const canAnnuler = selectedAppel && selectedAppel.facture;

  return (
    <div className={cn("flex gap-2", className)}>
      <Button
        onClick={onFacturer}
        disabled={!canFacturer || isLoading}
        variant="primary"
        className="min-w-[120px]"
      >
        Facturer
      </Button>
      <Button
        onClick={onMarquerGratuit}
        disabled={!canMarquerGratuit || isLoading}
        variant="secondary"
        className="min-w-[140px]"
      >
        Marquer Gratuit
      </Button>
      <Button
        onClick={onAnnuler}
        disabled={!canAnnuler || isLoading}
        variant="danger"
        className="min-w-[120px]"
      >
        Annuler
      </Button>
    </div>
  );
};

--- components/caisse/facturationAppel/AppelsListPanel.tsx ---
import { useState } from 'react';
import type { HistoriqueAppel, TypeCompte } from '@/types/facturationAppel';
import { DataGrid } from '@/components/ui';
import { Button, Dialog, Input } from '@/components/ui';
import { cn } from '@/lib/utils';

interface AppelsListPanelProps {
  appels: HistoriqueAppel[];
  isCloture: boolean;
  isLoading: boolean;
  onFacturer: (appel: HistoriqueAppel, numeroCompte: number, filiation: number, typeCompte: TypeCompte) => Promise<void>;
  onMarquerGratuit: (appelId: number, raison: string) => Promise<void>;
  className?: string;
}

export const AppelsListPanel = ({
  appels,
  isCloture,
  isLoading,
  onFacturer,
  onMarquerGratuit,
  className
}: AppelsListPanelProps) => {
  const [facturationDialogOpen, setFacturationDialogOpen] = useState(false);
  const [gratuitDialogOpen, setGratuitDialogOpen] = useState(false);
  const [selectedAppel, setSelectedAppel] = useState<HistoriqueAppel | null>(null);
  const [numeroCompte, setNumeroCompte] = useState('');
  const [filiation, setFiliation] = useState('');
  const [typeCompte, setTypeCompte] = useState<TypeCompte>('GO');
  const [raisonGratuite, setRaisonGratuite] = useState('');

  const handleFacturerClick = (appel: HistoriqueAppel) => {
    setSelectedAppel(appel);
    setNumeroCompte('');
    setFiliation('');
    setTypeCompte('GO');
    setFacturationDialogOpen(true);
  };

  const handleGratuitClick = (appel: HistoriqueAppel) => {
    setSelectedAppel(appel);
    setRaisonGratuite('');
    setGratuitDialogOpen(true);
  };

  const handleFacturerSubmit = async () => {
    if (!selectedAppel) return;
    const compte = parseInt(numeroCompte, 10);
    const fil = parseInt(filiation, 10);
    if (isNaN(compte) || isNaN(fil)) return;

    await onFacturer(selectedAppel, compte, fil, typeCompte);
    setFacturationDialogOpen(false);
    setSelectedAppel(null);
  };

  const handleGratuitSubmit = async () => {
    if (!selectedAppel || !selectedAppel.id || !raisonGratuite.trim()) retu

--- components/caisse/facturationAppel/DetailsPanel.tsx ---
import type { HistoriqueAppel } from '@/types/facturationAppel';
import { cn } from '@/lib/utils';

export interface DetailsPanelProps {
  appel: HistoriqueAppel | null;
  societe: string;
  compte: number;
  filiation: number;
  nomClient: string;
  prenomClient: string;
  soldeCompte: number;
  coefficientApplique: number;
  className?: string;
}

export const DetailsPanel = ({
  appel,
  societe,
  compte,
  filiation,
  nomClient,
  prenomClient,
  soldeCompte,
  coefficientApplique,
  className,
}: DetailsPanelProps) => {
  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('fr-FR', {
      style: 'currency',
      currency: 'EUR',
      minimumFractionDigits: 2,
    }).format(value);
  };

  if (!appel) {
    return (
      <div className={cn('rounded-md border border-neutral-200 bg-neutral-50 p-6', className)}>
        <p className="text-sm text-neutral-500">
          Sélectionnez un appel pour afficher les détails
        </p>
      </div>
    );
  }

  return (
    <div className={cn('rounded-md border border-neutral-200 bg-white p-6', className)}>
      <h3 className="mb-4 text-lg font-semibold text-neutral-900">Détails de l'appel</h3>
      
      <div className="space-y-4">
        <div className="grid grid-cols-3 gap-4">
          <div>
            <label className="block text-xs font-medium text-neutral-500 mb-1">
              Société
            </label>
            <div className="rounded-md border border-neutral-200 bg-neutral-50 px-3 py-2 text-sm text-neutral-700">
              {societe}
            </div>
          </div>
          
          <div>
            <label className="block text-xs font-medium text-neutral-500 mb-1">
              Compte
            </label>
            <div className="rounded-md border border-neutral-200 bg-neutral-50 px-3 py-2 text-sm text-neutral-700">
              {compte}
            </div>
          </div>
          
          <div>
            <label className="block text-xs font-medi

--- components/caisse/facturationAppel/FacturationPanel.tsx ---
import { useState, useEffect } from 'react';
import { Button, Dialog, Input } from '@/components/ui';
import { useFacturationAppelStore } from '@/stores/facturationAppelStore';
import type { HistoriqueAppel, FacturationRequest } from '@/types/facturationAppel';
import { cn } from '@/lib/utils';

interface FacturationPanelProps {
  className?: string;
}

export const FacturationPanel = ({ className }: FacturationPanelProps) => {
  const [showFacturationDialog, setShowFacturationDialog] = useState(false);
  const [showGratuitDialog, setShowGratuitDialog] = useState(false);
  const [selectedAppel, setSelectedAppel] = useState<HistoriqueAppel | null>(null);
  const [numeroCompte, setNumeroCompte] = useState('');
  const [filiation, setFiliation] = useState('');
  const [typeCompte, setTypeCompte] = useState<'GO' | 'GM'>('GO');
  const [raisonGratuite, setRaisonGratuite] = useState('');

  const facturerAppel = useFacturationAppelStore((s) => s.facturerAppel);
  const marquerGratuit = useFacturationAppelStore((s) => s.marquerGratuit);
  const annulerFacturation = useFacturationAppelStore((s) => s.annulerFacturation);
  const verifierCloture = useFacturationAppelStore((s) => s.verifierCloture);
  const isLoading = useFacturationAppelStore((s) => s.isLoading);

  const handleFacturer = async (appel: HistoriqueAppel) => {
    const estCloture = await verifierCloture();
    if (estCloture) {
      alert('Impossible de facturer : le réseau est clôturé');
      return;
    }

    setSelectedAppel(appel);
    setShowFacturationDialog(true);
  };

  const handleMarquerGratuit = (appel: HistoriqueAppel) => {
    setSelectedAppel(appel);
    setShowGratuitDialog(true);
  };

  const handleAnnuler = async (appel: HistoriqueAppel) => {
    if (!appel.id) return;
    
    if (!confirm('Confirmer l\'annulation de la facturation ?')) return;

    await annulerFacturation(appel.id);
  };

  const confirmerFacturation = async () => {
    if (!selectedAppel || !numeroCompte || !filiation)

--- components/caisse/facturationAppel/FacturationPanelPanel.tsx ---
import { useState } from 'react';
import { Button, Input } from '@/components/ui';
import type { TypeCompte } from '@/types/facturationAppel';
import { cn } from '@/lib/utils';

interface FacturationPanelPanelProps {
  montantCalcule: number;
  onConfirmerFacturation: (typeCompte: TypeCompte, gratuit: boolean, raisonGratuite: string | null) => void;
  disabled?: boolean;
  className?: string;
}

export const FacturationPanelPanel = ({
  montantCalcule,
  onConfirmerFacturation,
  disabled = false,
  className,
}: FacturationPanelPanelProps) => {
  const [typeCompte, setTypeCompte] = useState<TypeCompte>('GO');
  const [appelGratuit, setAppelGratuit] = useState(false);
  const [raisonGratuite, setRaisonGratuite] = useState('');

  const handleConfirmer = () => {
    if (appelGratuit && !raisonGratuite.trim()) {
      return;
    }
    onConfirmerFacturation(
      typeCompte,
      appelGratuit,
      appelGratuit ? raisonGratuite.trim() : null
    );
  };

  const isConfirmDisabled = disabled || (appelGratuit && !raisonGratuite.trim());

  return (
    <div className={cn('flex flex-col gap-4 p-4 bg-white rounded-lg border', className)}>
      <div className="flex flex-col gap-2">
        <label className="text-sm font-medium text-gray-700">Type de compte</label>
        <div className="flex gap-4">
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="radio"
              name="typeCompte"
              value="GO"
              checked={typeCompte === 'GO'}
              onChange={(e) => setTypeCompte(e.target.value as TypeCompte)}
              disabled={disabled}
              className="w-4 h-4 text-blue-600 focus:ring-blue-500"
            />
            <span className="text-sm text-gray-700">GO</span>
          </label>
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="radio"
              name="typeCompte"
              value="GM"
              chec

--- components/caisse/facturationAppel/FiltersPanel.tsx ---
import { useState } from 'react';
import { Button, Input } from '@/components/ui';
import { cn } from '@/lib/utils';

interface FiltersPanelProps {
  societe: string;
  dateDebut: Date | null;
  dateFin: Date | null;
  onSocieteChange: (value: string) => void;
  onDateDebutChange: (value: Date | null) => void;
  onDateFinChange: (value: Date | null) => void;
  onSearch: () => void;
  className?: string;
}

export const FiltersPanel = ({
  societe,
  dateDebut,
  dateFin,
  onSocieteChange,
  onDateDebutChange,
  onDateFinChange,
  onSearch,
  className,
}: FiltersPanelProps) => {
  const [prefixe, setPrefixe] = useState('');

  const handleDateDebutChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    onDateDebutChange(value ? new Date(value) : null);
  };

  const handleDateFinChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    onDateFinChange(value ? new Date(value) : null);
  };

  const formatDateForInput = (date: Date | null): string => {
    if (!date) return '';
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  return (
    <div className={cn('flex flex-col gap-4 rounded-lg border border-gray-300 bg-white p-4', className)}>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-4">
        <div className="flex flex-col gap-1.5">
          <label htmlFor="societe" className="text-sm font-medium text-gray-700">
            Société
          </label>
          <select
            id="societe"
            value={societe}
            onChange={(e) => onSocieteChange(e.target.value)}
            className="h-10 rounded-md border border-gray-300 bg-white px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
          >
            <option value="">Toutes</option>
            <opti

--- components/caisse/facturationAppel/GridPanel.tsx ---
import type { HistoriqueAppel } from '@/types/facturationAppel';
import { Button } from '@/components/ui';
import { cn } from '@/lib/utils';

interface GridPanelProps {
  appels: HistoriqueAppel[];
  isLoading?: boolean;
  onFacturer?: (appel: HistoriqueAppel) => void;
  onMarquerGratuit?: (appel: HistoriqueAppel) => void;
  onAnnuler?: (appel: HistoriqueAppel) => void;
  className?: string;
}

export const GridPanel = ({
  appels,
  isLoading = false,
  onFacturer,
  onMarquerGratuit,
  onAnnuler,
  className,
}: GridPanelProps) => {
  const formatDate = (date: Date) => {
    return new Date(date).toLocaleDateString('fr-FR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    });
  };

  const formatMontant = (montant: number) => {
    return new Intl.NumberFormat('fr-FR', {
      style: 'currency',
      currency: 'EUR',
    }).format(montant);
  };

  if (isLoading) {
    return (
      <div className={cn('flex items-center justify-center py-8', className)}>
        <div className="text-gray-500">Chargement...</div>
      </div>
    );
  }

  if (appels.length === 0) {
    return (
      <div className={cn('flex items-center justify-center py-8', className)}>
        <div className="text-gray-500">Aucun appel trouvé</div>
      </div>
    );
  }

  return (
    <div className={cn('overflow-x-auto', className)}>
      <table className="w-full border-collapse">
        <thead>
          <tr className="bg-gray-100 border-b border-gray-300">
            <th className="px-4 py-2 text-left text-sm font-semibold text-gray-700">Date</th>
            <th className="px-4 py-2 text-left text-sm font-semibold text-gray-700">Heure</th>
            <th className="px-4 py-2 text-left text-sm font-semibold text-gray-700">Numéro</th>
            <th className="px-4 py-2 text-right text-sm font-semibold text-gray-700">Durée</th>
            <th className="px-4 py-2 text-right text-sm font-semibold text-gray-700">Montant</th>
            <th className="px-4 p

--- components/caisse/facturationAppel/HistoriqueListPanel.tsx ---
import type { HistoriqueAppel } from "@/types/facturationAppel";
import { cn } from "@/lib/utils";

export interface HistoriqueListPanelProps {
  historiqueAppels: HistoriqueAppel[];
  onSelectAppel: (appel: HistoriqueAppel) => void;
  selectedAppel?: HistoriqueAppel | null;
}

export const HistoriqueListPanel = ({
  historiqueAppels,
  onSelectAppel,
  selectedAppel,
}: HistoriqueListPanelProps) => {
  const formatDate = (date: Date): string => {
    return new Date(date).toLocaleDateString("fr-FR");
  };

  const formatDuree = (duree: string): string => {
    return duree;
  };

  const formatMontant = (montant: number): string => {
    return `${montant.toFixed(2)} €`;
  };

  const formatGratuit = (gratuit: boolean): string => {
    return gratuit ? "Oui" : "Non";
  };

  return (
    <div className="flex flex-col gap-4">
      <div className="overflow-x-auto">
        <table className="w-full border-collapse">
          <thead>
            <tr className="border-b border-gray-300 bg-gray-50">
              <th className="px-4 py-2 text-left text-sm font-semibold text-gray-700">
                Date
              </th>
              <th className="px-4 py-2 text-left text-sm font-semibold text-gray-700">
                Heure
              </th>
              <th className="px-4 py-2 text-left text-sm font-semibold text-gray-700">
                Numéro
              </th>
              <th className="px-4 py-2 text-left text-sm font-semibold text-gray-700">
                Durée
              </th>
              <th className="px-4 py-2 text-right text-sm font-semibold text-gray-700">
                Montant
              </th>
              <th className="px-4 py-2 text-center text-sm font-semibold text-gray-700">
                Gratuit
              </th>
            </tr>
          </thead>
          <tbody>
            {historiqueAppels.length === 0 ? (
              <tr>
                <td colSpan={6} className="px-4 py-8 text-center text-gray-500">
     

--- components/caisse/facturationAppel/StatusBarPanel.tsx ---
import { useFacturationAppelStore } from '@/stores/facturationAppelStore';
import { Button } from '@/components/ui';
import { cn } from '@/lib/utils';

interface StatusBarPanelProps {
  className?: string;
}

export const StatusBarPanel = ({ className }: StatusBarPanelProps) => {
  const coefficientTelephone = useFacturationAppelStore((s) => s.coefficientTelephone);
  const cloture = useFacturationAppelStore((s) => s.cloture);
  const debloquerCloture = useFacturationAppelStore((s) => s.debloquerCloture);
  const isLoading = useFacturationAppelStore((s) => s.isLoading);

  const handleDebloquerCloture = async () => {
    try {
      await debloquerCloture();
    } catch (err) {
      console.error('Erreur lors du déblocage de la clôture:', err);
    }
  };

  return (
    <div
      className={cn(
        'flex items-center gap-6 border-t border-gray-300 bg-gray-50 px-4 py-2',
        className
      )}
    >
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">
          Coefficient téléphone actuel:
        </span>
        <span className="text-sm font-semibold text-gray-900">
          {coefficientTelephone !== null ? coefficientTelephone.toFixed(2) : '—'}
        </span>
      </div>

      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">Statut clôture:</span>
        <span
          className={cn(
            'text-sm font-semibold',
            cloture?.cloture_enCours ? 'text-red-600' : 'text-green-600'
          )}
        >
          {cloture?.cloture_enCours ? 'Clôture active' : 'Ouverte'}
        </span>
      </div>

      {cloture?.cloture_enCours && (
        <Button
          variant="warning"
          size="sm"
          onClick={handleDebloquerCloture}
          disabled={isLoading}
        >
          Débloquer clôture
        </Button>
      )}
    </div>
  );
};