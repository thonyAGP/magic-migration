```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useChoixPyrStore } from '@/stores/choixPyrStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { FetchHebergementsResponse, SelectChambreResponse, Hebergement, ClientGm } from '@/types/choixPyr';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

const MOCK_CLIENT: ClientGm = {
  societe: 1,
  compte: 1001,
  filiation: 0,
  nom: 'DUBOIS',
  prenom: 'Marc',
};

const TODAY = new Date('2026-02-22');
const PAST_DATE = new Date('2026-02-15');
const FUTURE_DATE = new Date('2026-02-28');

const MOCK_HEBERGEMENTS: Hebergement[] = [
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '101',
    dateDebut: PAST_DATE,
    dateFin: FUTURE_DATE,
    statut: 'ACTIF',
  },
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '203',
    dateDebut: PAST_DATE,
    dateFin: null,
    statut: 'ACTIF',
  },
];

const EXPIRED_HEBERGEMENT: Hebergement = {
  societe: 1,
  compte: 1001,
  filiation: 0,
  chambre: '305',
  dateDebut: new Date('2026-01-10'),
  dateFin: new Date('2026-02-10'),
  statut: 'ACTIF',
};

describe('choixPyrStore', () => {
  beforeEach(() => {
    useChoixPyrStore.getState().reset();
    useDataSourceStore.setState({ isRealApi: false });
    vi.clearAllMocks();
    vi.setSystemTime(TODAY);
  });

  describe('fetchHebergements', () => {
    it('should load hebergements in mock mode and filter by date', async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();

      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      expect(state.hebergements).toHaveLength(2);
      expect(state.hebergements.find(h => h.chambre === '101')).toBeDefined();
      expect(state.hebergements.find(h => h.chambre === '203')).toBeDefined();
      expect(state.hebergements.find(h => h.chambre === '305')).toBeUndefined();
      expect(state.clientInfo).toEqual(MOCK_CLIENT);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should set loading state during fetch', async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();
      
      let isLoadingDuringFetch = false;
      
      const promise = fetchHebergements(1, 1001, 0);
      
      await new Promise(resolve => setTimeout(resolve, 0));
      isLoadingDuringFetch = useChoixPyrStore.getState().isLoading;
      
      await promise;
      
      expect(isLoadingDuringFetch).toBe(true);
      expect(useChoixPyrStore.getState().isLoading).toBe(false);
    });

    it('should exclude expired hebergements (dateFin < today)', async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();

      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      const hasExpired = state.hebergements.some(h => h.chambre === '305');
      expect(hasExpired).toBe(false);
      expect(state.hebergements.every(h => h.dateFin === null || h.dateFin >= TODAY)).toBe(true);
    });

    it('should include hebergements with null dateFin', async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();

      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      const nullDateFin = state.hebergements.find(h => h.chambre === '203');
      expect(nullDateFin).toBeDefined();
      expect(nullDateFin?.dateFin).toBeNull();
    });

    it('should call API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: FetchHebergementsResponse = {
        success: true,
        data: {
          hebergements: MOCK_HEBERGEMENTS,
          clientInfo: MOCK_CLIENT,
        },
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce({ data: mockResponse });

      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);

      expect(apiClient.get).toHaveBeenCalledWith(
        '/api/choixPyr/hebergements?societe=1&compte=1001&filiation=0'
      );
      const state = useChoixPyrStore.getState();
      expect(state.hebergements).toEqual(MOCK_HEBERGEMENTS);
      expect(state.clientInfo).toEqual(MOCK_CLIENT);
    });

    it('should handle API error', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Network error'));

      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Network error');
      expect(state.hebergements).toEqual([]);
      expect(state.clientInfo).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should handle unknown error type', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce('string error');

      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Erreur chargement hebergements');
    });

    it('should handle null data in API response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: FetchHebergementsResponse = {
        success: true,
        data: {
          hebergements: [],
          clientInfo: MOCK_CLIENT,
        },
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce({ data: mockResponse });

      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      expect(state.hebergements).toEqual([]);
    });

    it('should clear previous error on new fetch', async () => {
      const store = useChoixPyrStore.getState();
      store.setError('Previous error');
      
      await store.fetchHebergements(1, 1001, 0);

      expect(useChoixPyrStore.getState().error).toBeNull();
    });
  });

  describe('selectChambre', () => {
    beforeEach(async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);
    });

    it('should select chambre in mock mode', async () => {
      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      const hebergement = hebergements[0];

      await selectChambre(hebergement);

      const state = useChoixPyrStore.getState();
      expect(state.selectedHebergement).toEqual(hebergement);
      expect(state.error).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should validate hebergement belongs to client', async () => {
      const { selectChambre } = useChoixPyrStore.getState();
      const invalidHebergement: Hebergement = {
        ...MOCK_HEBERGEMENTS[0],
        compte: 9999,
      };

      await selectChambre(invalidHebergement);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Hebergement non valide pour ce client');
      expect(state.selectedHebergement).toBeNull();
    });

    it('should validate societe matches', async () => {
      const { selectChambre } = useChoixPyrStore.getState();
      const invalidHebergement: Hebergement = {
        ...MOCK_HEBERGEMENTS[0],
        societe: 999,
      };

      await selectChambre(invalidHebergement);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Hebergement non valide pour ce client');
    });

    it('should validate filiation matches', async () => {
      const { selectChambre } = useChoixPyrStore.getState();
      const invalidHebergement: Hebergement = {
        ...MOCK_HEBERGEMENTS[0],
        filiation: 99,
      };

      await selectChambre(invalidHebergement);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Hebergement non valide pour ce client');
    });

    it('should handle missing clientInfo', async () => {
      useChoixPyrStore.setState({ clientInfo: null });
      const { selectChambre, hebergements } = useChoixPyrStore.getState();

      await selectChambre(hebergements[0]);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Aucune information client disponible');
    });

    it('should call API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: SelectChambreResponse = {
        success: true,
        data: {
          success: true,
          selectedChambre: '101',
        },
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: mockResponse });

      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      const hebergement = hebergements[0];

      await selectChambre(hebergement);

      expect(apiClient.post).toHaveBeenCalledWith('/api/choixPyr/select', {
        societe: 1,
        compte: 1001,
        filiation: 0,
        chambre: hebergement.chambre,
      });
      expect(useChoixPyrStore.getState().selectedHebergement).toEqual(hebergement);
    });

    it('should handle API error during selection', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Selection failed'));

      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      await selectChambre(hebergements[0]);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Selection failed');
      expect(state.isLoading).toBe(false);
    });

    it('should handle API success=false response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: SelectChambreResponse = {
        success: false,
        data: {
          success: false,
          selectedChambre: '',
        },
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: mockResponse });

      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      await selectChambre(hebergements[0]);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Echec selection chambre');
    });

    it('should handle unknown error type during selection', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce('unknown error');

      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      await selectChambre(hebergements[0]);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Erreur selection chambre');
    });

    it('should set loading state during selection', async () => {
      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      
      let isLoadingDuringSelection = false;
      
      const promise = selectChambre(hebergements[0]);
      
      await new Promise(resolve => setTimeout(resolve, 0));
      isLoadingDuringSelection = useChoixPyrStore.getState().isLoading;
      
      await promise;
      
      expect(isLoadingDuringSelection).toBe(true);
      expect(useChoixPyrStore.getState().isLoading).toBe(false);
    });
  });

  describe('cancelSelection', () => {
    it('should clear selected hebergement', () => {
      useChoixPyrStore.setState({ selectedHebergement: MOCK_HEBERGEMENTS[0] });

      const { cancelSelection } = useChoixPyrStore.getState();
      cancelSelection();

      const state = useChoixPyrStore.getState();
      expect(state.selectedHebergement).toBeNull();
    });

    it('should clear error on cancel', () => {
      useChoixPyrStore.setState({ 
        selectedHebergement: MOCK_HEBERGEMENTS[0],
        error: 'Some error',
      });

      const { cancelSelection } = useChoixPyrStore.getState();
      cancelSelection();

      const state = useChoixPyrStore.getState();
      expect(state.error).toBeNull();
    });
  });

  describe('setError', () => {
    it('should set error message', () => {
      const { setError } = useChoixPyrStore.getState();

      setError('Test error');

      expect(useChoixPyrStore.getState().error).toBe('Test error');
    });

    it('should clear error when passed null', () => {
      useChoixPyrStore.setState({ error: 'Existing error' });
      const { setError } = useChoixPyrStore.getState();

      setError(null);

      expect(useChoixPyrStore.getState().error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      useChoixPyrStore.setState({
        hebergements: MOCK_HEBERGEMENTS,
        selectedHebergement: MOCK_HEBERGEMENTS[0],
        clientInfo: MOCK_CLIENT,
        isLoading: true,
        error: 'Some error',
      });

      const { reset } = useChoixPyrStore.getState();
      reset();

      const state = useChoixPyrStore.getState();
      expect(state.hebergements).toEqual([]);
      expect(state.selectedHebergement).toBeNull();
      expect(state.clientInfo).toBeNull();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });
  });
});
```