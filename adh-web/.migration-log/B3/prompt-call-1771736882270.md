Generate Vitest component tests for "ChoixPyrPage".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { render, screen, fireEvent, waitFor } from "@testing-library/react"
- Mock the store with vi.mock()
- CRITICAL: import the page component using @/ alias: import { ChoixPyrPage } from "@/pages/ChoixPyrPage"
- Place vi.mock() calls BEFORE the page import (vitest hoisting)
- Test: renders without crashing
- Test: displays loading state
- Test: displays data when loaded
- Test: handles user interactions (clicks, form submits)
- Test: displays error state

PAGE COMPONENT:
import { useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { useChoixPyrStore } from '@/stores/choixPyrStore';
import { useAuthStore } from '@/stores';
import type { Hebergement } from '@/types/choixPyr';
import { cn } from '@/lib/utils';

export function ChoixPyrPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);

  const hebergements = useChoixPyrStore((s) => s.hebergements);
  const selectedHebergement = useChoixPyrStore((s) => s.selectedHebergement);
  const clientInfo = useChoixPyrStore((s) => s.clientInfo);
  const isLoading = useChoixPyrStore((s) => s.isLoading);
  const error = useChoixPyrStore((s) => s.error);
  const fetchHebergements = useChoixPyrStore((s) => s.fetchHebergements);
  const selectChambre = useChoixPyrStore((s) => s.selectChambre);
  const cancelSelection = useChoixPyrStore((s) => s.cancelSelection);
  const reset = useChoixPyrStore((s) => s.reset);

  useEffect(() => {
    fetchHebergements(1, 1001, 0);
    return () => reset();
  }, [fetchHebergements, reset]);

  const handleSelectRow = useCallback((heb: Hebergement) => {
    selectChambre(heb);
  }, [selectChambre]);

  const handleValider = useCallback(async () => {
    if (!selectedHebergement) return;
    navigate('/caisse/menu');
  }, [selectedHebergement, navigate]);

  const handleAnnuler = useCallback(() => {
    cancelSelection();
    navigate('/caisse/menu');
  }, [cancelSelection, navigate]);

  const formatDate = (date: Date | null) => {
    if (!date) return 'N/A';
    return new Date(date).toLocaleDateString('fr-FR');
  };

  const sortedHebergements = [...hebergements].sort((a, b) =>
    a.chambre.localeCompare(b.chambre)
  );

  return (
    <ScreenLayout>
      <div className="max-w-4xl mx-auto space-y-6">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold">Choix chambre PYR</h2>
            {clientInfo && (
              <p className="text-on-surface-muted text-sm mt-1">
                Client: {clientInfo.nom} {clientInfo.prenom}
              </p>
            )}
          </div>
          {user && (
            <span className="text-xs text-on-surface-muted">
              {user.prenom} {user.nom}
            </span>
          )}
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md text-sm">
            {error}
          </div>
        )}

        <div className="bg-blue-50 border border-blue-200 text-blue-700 px-4 py-3 rounded-md text-sm">
          Veuillez choisir la chambre pour le paiement PYR
        </div>

        {isLoading ? (
          <div className="flex items-center justify-center py-12">
            <div className="text-on-surface-muted">Chargement...</div>
          </div>
        ) : hebergements.length === 0 ? (
          <div className="text-center py-12 text-on-surface-muted">
            Aucun hébergement actif trouvé
          </div>
        ) : (
          <div className="border border-border rounded-md overflow-hidden">
            <table className="w-full">
              <thead className="bg-surface-hover border-b border-border">
                <tr>
                  <th className="px-4 py-3 text-left text-sm font-semibold">Chambre</th>
                  <th className="px-4 py-3 text-left text-sm font-semibold">Date début</th>
                  <th className="px-4 py-3 text-left text-sm font-semibold">Date fin</th>
                  <th className="px-4 py-3 text-left text-sm font-semibold">Statut</th>
                </tr>
              </thead>
              <tbody>
                {sortedHebergements.map((heb) => {
                  const isSelected =
                    selectedHebergement?.chambre === heb.chambre &&
                    selectedHebergement?.dateDebut === heb.dateDebut;
                  return (
                    <tr
                      key={`${heb.chambre}-${heb.dateDebut}`}
                      onClick={() => handleSelectRow(heb)}
                      className={cn(
                        'border-b border-border cursor-pointer hover:bg-surface-hover transition-colors',
                        isSelected && 'bg-primary-light'
                      )}
                    >
                      <td className="px-4 py-3 text-sm">{heb.chambre}</td>
                      <td className="px-4 py-3 text-sm">{formatDate(heb.dateDebut)}</td>
                      <td className="px-4 py-3 text-sm">{formatDate(heb.dateFin)}</td>
                      <td className="px-4 py-3 text-sm">{heb.statut}</td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        )}

        <div className="flex gap-3 justify-end">
          <button
            onClick={handleAnnuler}
            className="px-6 py-2 border border-border rounded-md text-on-surface hover:bg-surface-hover"
          >
            Annuler
          </button>
          <button
            onClick={handleValider}
            disabled={!selectedHebergement}
            className={cn(
              'px-6 py-2 rounded-md text-white',
              selectedHebergement
                ? 'bg-primary hover:bg-primary-dark'
                : 'bg-gray-300 cursor-not-allowed'
            )}
          >
            Valider
          </button>
        </div>
      </div>
    </ScreenLayout>
  );
}

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export interface Hebergement {
  societe: number;
  compte: number;
  filiation: number;
  chambre: string;
  dateDebut: Date;
  dateFin: Date | null;
  statut: string;
}

export interface ClientGm {
  societe: number;
  compte: number;
  filiation: number;
  nom: string;
  prenom: string | null;
}

export interface ChoixPyrState {
  hebergements: Hebergement[];
  selectedHebergement: Hebergement | null;
  clientInfo: ClientGm | null;
  isLoading: boolean;
  error: string | null;
  fetchHebergements: (
    societe: number,
    compte: number,
    filiation: number
  ) => Promise<void>;
  selectChambre: (hebergement: Hebergement) => Promise<void>;
  cancelSelection: () => Promise<void>;
  setError: (error: string | null) => void;
  reset: () => void;
}

export interface FetchHebergementsRequest {
  societe: number;
  compte: number;
  filiation: number;
}

export interface FetchHebergementsResponse extends ApiResponse {
  data: {
    hebergements: Hebergement[];
    clientInfo: ClientGm;
  };
}

export interface SelectChambreRequest {
  societe: number;
  compte: number;
  filiation: number;
  chambre: string;
}

export interface SelectChambreResponse extends ApiResponse {
  data: {
    success: boolean;
    selectedChambre: string;
  };
}

export type ChoixPyrActionType =
  | "FETCH_HEBERGEMENTS_START"
  | "FETCH_HEBERGEMENTS_SUCCESS"
  | "FETCH_HEBERGEMENTS_ERROR"
  | "SELECT_CHAMBRE"
  | "CANCEL_SELECTION"
  | "SET_ERROR"
  | "RESET";

UI SECTIONS:
[
  {
    "name": "header",
    "controls": [
      "Client info display (nom, prenom)",
      "Message: 'Veuillez choisir la chambre pour le paiement PYR'"
    ]
  },
  {
    "name": "chambresGrid",
    "controls": [
      "DataGrid with columns: Chambre, Date debut, Date fin, Statut",
      "Single selection mode",
      "Sort by chambre number"
    ]
  },
  {
    "name": "actions",
    "controls": [
      "Button: Valider (primary, enabled when selection)",
      "Button: Annuler (secondary)"
    ]
  }
]