Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
emailSearchStore searchEmails should fetch emails from API when isRealApi is true: AssertionError: expected [] to deeply equal [ …(3) ]
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:97:28
    at processTicksAndRejections (node:internal/process/task_
emailSearchStore searchEmails should filter mock emails when isRealApi is false: AssertionError: expected 0 to be greater than 0
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:116:35
    at processTicksAndRejections (node:internal/process/task_queu
emailSearchStore searchEmails should set error when API call fails: AssertionError: expected null to be 'Network error' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:152:27
    at processTicksAndRejections (node:
emailSearchStore createEmail should create email via API when isRealApi is true: AssertionError: expected [] to deep equally contain { id: 99, societe: 'SKI', …(6) }
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:211:28
    at processTicksAndReject
emailSearchStore createEmail should create email in mock mode and unset previous principal if isPrincipal is true: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:230:95
    at processTicksAndRejections (node:internal/p
emailSearchStore createEmail should set error when API creation fails: AssertionError: expected null to be 'Validation error' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:248:27
    at processTicksAndRejections (no
emailSearchStore createEmail should set createdAt timestamp when creating in mock mode: AssertionError: expected undefined to be defined
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:268:23
    at processTicksAndRejections (node:internal/process/task_que
emailSearchStore updateEmail should update email via API when isRealApi is true: AssertionError: expected 'jean.dupont@email.com' to be 'updated@email.com' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:299:37
    at processTi
emailSearchStore updateEmail should update email in mock mode and set updatedAt timestamp: AssertionError: expected undefined to be 'updated-mock@email.com' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:314:30
    at processTicksAndRej
emailSearchStore updateEmail should unset other principals when updating isPrincipal to true in mock mode: AssertionError: expected undefined to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:329:36
    at processTicksAndRejections (node:intern
emailSearchStore updateEmail should set error when email not found in mock mode: AssertionError: expected null to be 'Email introuvable' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:338:27
    at processTicksAndRejections (n
emailSearchStore updateEmail should set error when API update fails: AssertionError: expected null to be 'Update failed' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:349:27
    at processTicksAndRejections (node:
emailSearchStore deleteEmail should delete email via API when isRealApi is true: AssertionError: expected [ …(2) ] to have a length of 1 but got 2
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.pnpm/@vitest+expect@4.0.18/node_modules/@vitest/expe
emailSearchStore deleteEmail should delete email in mock mode: AssertionError: expected 0 to be less than 0
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:381:35
    at processTicksAndRejections (node:internal/process/task_queues:
emailSearchStore deleteEmail should set error when email not found in mock mode: AssertionError: expected null to be 'Email introuvable' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:391:27
    at processTicksAndRejections (n
emailSearchStore deleteEmail should set error when API deletion fails: AssertionError: expected null to be 'Delete failed' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:402:27
    at processTicksAndRejections (node:
emailSearchStore setAsPrincipal should set email as principal via API when isRealApi is true: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:422:65
    at processTicksAndRejections (node:internal/p
emailSearchStore setAsPrincipal should unset previous principal when setting new principal in mock mode: AssertionError: expected +0 to be 1 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:437:30
    at processTicksAndRejections (node:internal/process
emailSearchStore setAsPrincipal should set error when email not found in mock mode: AssertionError: expected null to be 'Email introuvable' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:447:27
    at processTicksAndRejections (n
emailSearchStore setAsPrincipal should set error when API call fails: AssertionError: expected null to be 'Principal update failed' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:458:27
    at processTicksAndRejecti
emailSearchStore setAsPrincipal should only affect emails with same GM identifier (societe+compte+filiation): AssertionError: expected undefined to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:469:41
    at processTicksAndRejections (node:intern
emailSearchStore selectEmail should set selected email: AssertionError: expected null to deeply equal { id: 1, societe: 'SKI', …(6) }
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:478:35
    at file:///D:/Projects/Lecteur_
emailSearchStore setFilters should update filters: AssertionError: expected { societe: '', compte: '', …(2) } to deeply equal { societe: 'SKI', …(3) }
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:502:29
    at file:/
emailSearchStore resetState should reset entire store to initial state: AssertionError: expected [ …(3) ] to deeply equal []
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/emailSearchStore.test.ts:536:28
    at file:///D:/Projects/Lecteur_Magic/adh-web/node_module

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useEmailSearchStore } from '@/stores/emailSearchStore';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type { ApiResponse } from '@/services/api/apiClient';
import type {
  CreateEmailDto,
  UpdateEmailDto,
  GetEmailsResponse,
  CreateEmailResponse,
  UpdateEmailResponse,
  DeleteEmailResponse,
  SetPrincipalResponse,
  SearchFilters,
  EmailAddress,
} from '@/types/emailSearch';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(),
  },
}));

const MOCK_EMAIL_1: EmailAddress = {
  id: 1,
  societe: 'SKI',
  compte: '100001',
  filiation: 0,
  email: 'jean.dupont@email.com',
  isPrincipal: true,
  createdAt: new Date('2026-01-15T10:30:00'),
  updatedAt: new Date('2026-02-10T14:20:00'),
};

const MOCK_EMAIL_2: EmailAddress = {
  id: 2,
  societe: 'SKI',
  compte: '100001',
  filiation: 0,
  email: 'contact@dupont-family.fr',
  isPrincipal: false,
  createdAt: new Date('2026-01-20T09:15:00'),
  updatedAt: null,
};

const MOCK_EMAIL_3: EmailAddress = {
  id: 3,
  societe: 'EXCHANGE',
  compte: '100002',
  filiation: 1,
  email: 'marie.bernard@email.com',
  isPrincipal: true,
  createdAt: new Date('2026-01-08T10:00:00'),
  updatedAt: null,
};

const MOCK_EMAILS = [MOCK_EMAIL_1, MOCK_EMAIL_2, MOCK_EMAIL_3];

describe('emailSearchStore', () => {
  beforeEach(() => {
    useEmailSearchStore.getState().resetState();
    vi.clearAllMocks();
  });

  describe('searchEmails', () => {
    it('should fetch emails from API when isRealApi is true', async () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '100001',
        filiation: null,
        email: '',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValue({
        data: {
          success: true,
          data: { data: MOCK_EMAILS, count: MOCK_EMAILS.length },
        },
      } as ApiResponse<GetEmailsResponse>);

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(apiClient.get).toHaveBeenCalledWith('/api/email-search/emails', {
        params: { societe: 'SKI', compte: '100001' },
      });
      expect(store.emails).toEqual(MOCK_EMAILS);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe(null);
    });

    it('should filter mock emails when isRealApi is false', async () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: '',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(apiClient.get).not.toHaveBeenCalled();
      expect(store.emails.length).toBeGreaterThan(0);
      expect(store.emails.every((e) => e.societe === 'SKI' && e.compte === '100001')).toBe(true);
      expect(store.isLoading).toBe(false);
    });

    it('should filter by email pattern when isRealApi is false', async () => {
      const filters: SearchFilters = {
        societe: '',
        compte: '',
        filiation: null,
        email: 'contact',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(store.emails.every((e) => e.email.toLowerCase().includes('contact'))).toBe(true);
    });

    it('should set error when API call fails', async () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '',
        filiation: null,
        email: '',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockRejectedValue(new Error('Network error'));

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(store.emails).toEqual([]);
      expect(store.error).toBe('Network error');
      expect(store.isLoading).toBe(false);
    });

    it('should handle all filter criteria in API mode', async () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: 'jean',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValue({
        data: {
          success: true,
          data: { data: [MOCK_EMAIL_1], count: 1 },
        },
      } as ApiResponse<GetEmailsResponse>);

      const store = useEmailSearchStore.getState();
      await store.searchEmails(filters);

      expect(apiClient.get).toHaveBeenCalledWith('/api/email-search/emails', {
        params: { societe: 'SKI', compte: '100001', filiation: '0', email: 'jean' },
      });
    });
  });

  describe('createEmail', () => {
    it('should create email via API when isRealApi is true', async () => {
      const newEmail: CreateEmailDto = {
        societe: 'SKI',
        compte: '100003',
        filiation: 0,
        email: 'new@test.com',
        isPrincipal: false,
      };

      const createdEmail: EmailAddress = {
        id: 99,
        ...newEmail,
        isPrincipal: false,
        createdAt: new Date(),
        updatedAt: null,
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockResolvedValue({
        data: {
          success: true,
          data: { data: createdEmail },
        },
      } as ApiResponse<CreateEmailResponse>);

      const store = useEmailSearchStore.getState();
      await store.createEmail(newEmail);

      expect(apiClient.post).toHaveBeenCalledWith('/api/email-search/emails', newEmail);
      expect(store.emails).toContainEqual(createdEmail);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBe(null);
    });

    it('should create email in mock mode and unset previous principal if isPrincipal is true', async () => {
      const newEmail: CreateEmailDto = {
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: 'new-principal@test.com',
        isPrincipal: true,
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.createEmail(newEmail);

      expect(store.emails.some((e) => e.email === 'new-principal@test.com' && e.isPrincipal)).toBe(true);
      expect(store.isLoading).toBe(false);
    });

    it('should set error when API creation fails', async () => {
      const newEmail: CreateEmailDto = {
        societe: 'SKI',
        compte: '100003',
        filiation: 0,
        email: 'fail@test.com',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockRejectedValue(new Error('Validation error'));

      const store = useEmailSearchStore.getState();
      await store.createEmail(newEmail);

      expect(store.error).toBe('Validation error');
      expect(store.isLoading).toBe(false);
    });

    it('should set createdAt timestamp when creating in mock mode', async () => {
      const beforeCreate = new Date();

      const newEmail: CreateEmailDto = {
        societe: 'SKI',
        compte: '100003',
        filiation: 0,
        email: 'timestamped@test.com',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.createEmail(newEmail);

      const created = store.emails.find((e) => e.email === 'timestamped@test.com');
      expect(created).toBeDefined();
      expect(created!.createdAt).toBeInstanceOf(Date);
      expect(created!.createdAt!.getTime()).toBeGreaterThanOrEqual(beforeCreate.getTime());
    });
  });

  describe('updateEmail', () => {
    it('should update email via API when isRealApi is true', async () => {
      const updateData: UpdateEmailDto = {
        email: 'updated@email.com',
      };

      const updatedEmail: EmailAddress = {
        ...MOCK_EMAIL_1,
        email: 'updated@email.com',
        updatedAt: new Date(),
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.put).mockResolvedValue({
        data: {
          success: true,
          data: { data: updatedEmail },
        },
      } as ApiResponse<UpdateEmailResponse>);

      const store = useEmailSearchStore.getState();
      store.emails = [MOCK_EMAIL_1];
      await store.updateEmail(1, updateData);

      expect(apiClient.put).toHaveBeenCalledWith('/api/email-search/emails/1', updateData);
      expect(store.emails[0].email).toBe('updated@email.com');
      expect(store.isLoading).toBe(false);
    });

    it('should update email in mock mode and set updatedAt timestamp', async () => {
      const updateData: UpdateEmailDto = {
        email: 'updated-mock@email.com',
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.updateEmail(1, updateData);

      const updated = store.emails.find((e) => e.id === 1);
      expect(updated?.email).toBe('updated-mock@email.com');
      expect(updated?.updatedAt).toBeInstanceOf(Date);
    });

    it('should unset other principals when updating isPrincipal to true in mock mode', async () => {
      const updateData: UpdateEmailDto = {
        isPrincipal: true,
      };

      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.updateEmail(2, updateData);

      const updated = store.emails.find((e) => e.id === 2);
      expect(updated?.isPrincipal).toBe(true);
    });

    it('should set error when email not found in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.updateEmail(999, { email: 'test@email.com' });

      expect(store.error).toBe('Email introuvable');
      expect(store.isLoading).toBe(false);
    });

    it('should set error when API update fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.put).mockRejectedValue(new Error('Update failed'));

      const store = useEmailSearchStore.getState();
      await store.updateEmail(1, { email: 'fail@email.com' });

      expect(store.error).toBe('Update failed');
      expect(store.isLoading).toBe(false);
    });
  });

  describe('deleteEmail', () => {
    it('should delete email via API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.delete).mockResolvedValue({
        data: {
          success: true,
          data: { success: true },
        },
      } as ApiResponse<DeleteEmailResponse>);

      const store = useEmailSearchStore.getState();
      store.emails = [MOCK_EMAIL_1, MOCK_EMAIL_2];
      await store.deleteEmail(1);

      expect(apiClient.delete).toHaveBeenCalledWith('/api/email-search/emails/1');
      expect(store.emails).toHaveLength(1);
      expect(store.emails[0].id).toBe(2);
      expect(store.isLoading).toBe(false);
    });

    it('should delete email in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      const initialCount = store.emails.length;
      await store.deleteEmail(1);

      expect(store.emails.length).toBeLessThan(initialCount);
      expect(store.emails.find((e) => e.id === 1)).toBeUndefined();
    });

    it('should set error when email not found in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.deleteEmail(999);

      expect(store.error).toBe('Email introuvable');
      expect(store.isLoading).toBe(false);
    });

    it('should set error when API deletion fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.delete).mockRejectedValue(new Error('Delete failed'));

      const store = useEmailSearchStore.getState();
      await store.deleteEmail(1);

      expect(store.error).toBe('Delete failed');
      expect(store.isLoading).toBe(false);
    });
  });

  describe('setAsPrincipal', () => {
    it('should set email as principal via API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockResolvedValue({
        data: {
          success: true,
          data: { success: true },
        },
      } as ApiResponse<SetPrincipalResponse>);

      const store = useEmailSearchStore.getState();
      store.emails = [MOCK_EMAIL_1, MOCK_EMAIL_2];
      await store.setAsPrincipal(2);

      expect(apiClient.post).toHaveBeenCalledWith('/api/email-search/emails/2/set-principal');
      expect(store.emails.find((e) => e.id === 2)?.isPrincipal).toBe(true);
      expect(store.emails.find((e) => e.id === 1)?.isPrincipal).toBe(false);
      expect(store.isLoading).toBe(false);
    });

    it('should unset previous principal when setting new principal in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.setAsPrincipal(2);

      const emailsWithSameGM = store.emails.filter(
        (e) => e.societe === 'SKI' && e.compte === '100001' && e.filiation === 0,
      );
      const principalCount = emailsWithSameGM.filter((e) => e.isPrincipal).length;
      expect(principalCount).toBe(1);
      expect(store.emails.find((e) => e.id === 2)?.isPrincipal).toBe(true);
    });

    it('should set error when email not found in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.setAsPrincipal(999);

      expect(store.error).toBe('Email introuvable');
      expect(store.isLoading).toBe(false);
    });

    it('should set error when API call fails', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockRejectedValue(new Error('Principal update failed'));

      const store = useEmailSearchStore.getState();
      await store.setAsPrincipal(1);

      expect(store.error).toBe('Principal update failed');
      expect(store.isLoading).toBe(false);
    });

    it('should only affect emails with same GM identifier (societe+compte+filiation)', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);

      const store = useEmailSearchStore.getState();
      await store.setAsPrincipal(2);

      const otherGMEmail = store.emails.find((e) => e.societe === 'EXCHANGE' && e.compte === '100002');
      expect(otherGMEmail?.isPrincipal).toBe(true);
    });
  });

  describe('selectEmail', () => {
    it('should set selected email', () => {
      const store = useEmailSearchStore.getState();
      store.selectEmail(MOCK_EMAIL_1);

      expect(store.selectedEmail).toEqual(MOCK_EMAIL_1);
    });

    it('should clear selected email when passed null', () => {
      const store = useEmailSearchStore.getState();
      store.selectEmail(MOCK_EMAIL_1);
      store.selectEmail(null);

      expect(store.selectedEmail).toBe(null);
    });
  });

  describe('setFilters', () => {
    it('should update filters', () => {
      const filters: SearchFilters = {
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: 'test',
      };

      const store = useEmailSearchStore.getState();
      store.setFilters(filters);

      expect(store.filters).toEqual(filters);
    });
  });

  describe('clearFilters', () => {
    it('should reset all filters to initial state', () => {
      const store = useEmailSearchStore.getState();
      store.setFilters({
        societe: 'SKI',
        compte: '100001',
        filiation: 0,
        email: 'test',
      });
      store.clearFilters();

      expect(store.filters).toEqual({
        societe: '',
        compte: '',
        filiation: null,
        email: '',
      });
    });
  });

  describe('resetState', () => {
    it('should reset entire store to initial state', () => {
      const store = useEmailSearchStore.getState();
      store.emails = MOCK_EMAILS;
      store.selectedEmail = MOCK_EMAIL_1;
      store.error = 'Some error';
      store.setFilters({ societe: 'SKI', compte: '100001', filiation: 0, email: 'test' });

      store.resetState();

      expect(store.emails).toEqual([]);
      expect(store.selectedEmail).toBe(null);
      expect(store.error).toBe(null);
      expect(store.filters).toEqual({
        societe: '',
        compte: '',
        filiation: null,
        email: '',
      });
      expect(store.isLoading).toBe(false);
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  EmailAddress,
  SearchFilters,
  CreateEmailDto,
  UpdateEmailDto,
  GetEmailsResponse,
  CreateEmailResponse,
  UpdateEmailResponse,
  DeleteEmailResponse,
  SetPrincipalResponse,
} from '@/types/emailSearch';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface EmailSearchState {
  emails: EmailAddress[];
  selectedEmail: EmailAddress | null;
  isLoading: boolean;
  error: string | null;
  filters: SearchFilters;
}

interface EmailSearchActions {
  searchEmails: (filters: SearchFilters) => Promise<void>;
  createEmail: (data: CreateEmailDto) => Promise<void>;
  updateEmail: (id: number, data: UpdateEmailDto) => Promise<void>;
  deleteEmail: (id: number) => Promise<void>;
  setAsPrincipal: (id: number) => Promise<void>;
  selectEmail: (email: EmailAddress | null) => void;
  setFilters: (filters: SearchFilters) => void;
  clearFilters: () => void;
  resetState: () => void;
}

type EmailSearchStore = EmailSearchState & EmailSearchActions;

const MOCK_EMAILS: EmailAddress[] = [
  {
    id: 1,
    societe: 'SKI',
    compte: '100001',
    filiation: 0,
    email: 'jean.dupont@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-15T10:30:00'),
    updatedAt: new Date('2026-02-10T14:20:00'),
  },
  {
    id: 2,
    societe: 'SKI',
    compte: '100001',
    filiation: 0,
    email: 'contact@dupont-family.fr',
    isPrincipal: false,
    createdAt: new Date('2026-01-20T09:15:00'),
    updatedAt: null,
  },
  {
    id: 3,
    societe: 'SKI',
    compte: '100001',
    filiation: 0,
    email: 'j.dupont@work.com',
    isPrincipal: false,
    createdAt: new Date('2026-02-01T16:45:00'),
    updatedAt: null,
  },
  {
    id: 4,
    societe: 'SKI',
    compte: '100002',
    filiation: 0,
    email: 'sophie.martin@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-10T11:00:00'),
    updatedAt: new Date('2026-02-15T08:30:00'),
  },
  {
    id: 5,
    societe: 'SKI',
    compte: '100002',
    filiation: 0,
    email: 's.martin@company.fr',
    isPrincipal: false,
    createdAt: new Date('2026-01-18T14:20:00'),
    updatedAt: null,
  },
  {
    id: 6,
    societe: 'SKI',
    compte: '100002',
    filiation: 0,
    email: 'contact@martin-group.com',
    isPrincipal: false,
    createdAt: new Date('2026-02-05T10:10:00'),
    updatedAt: null,
  },
  {
    id: 7,
    societe: 'EXCHANGE',
    compte: '100003',
    filiation: 1,
    email: 'pierre.durand@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-12T09:45:00'),
    updatedAt: new Date('2026-02-12T15:00:00'),
  },
  {
    id: 8,
    societe: 'EXCHANGE',
    compte: '100003',
    filiation: 1,
    email: 'p.durand@perso.fr',
    isPrincipal: false,
    createdAt: new Date('2026-01-25T13:30:00'),
    updatedAt: null,
  },
  {
    id: 9,
    societe: 'EXCHANGE',
    compte: '100003',
    filiation: 1,
    email: 'contact@durand.net',
    isPrincipal: false,
    createdAt: new Date('2026-02-08T11:20:00'),
    updatedAt: null,
  },
  {
    id: 10,
    societe: 'EXCHANGE',
    compte: '100004',
    filiation: 0,
    email: 'marie.bernard@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-08T10:00:00'),
    updatedAt: null,
  },
  {
    id: 11,
    societe: 'EXCHANGE',
    compte: '100004',
    filiation: 0,
    email: 'm.bernard@work.com',
    isPrincipal: false,
    createdAt: new Date('2026-01-22T15:45:00'),
    updatedAt: null,
  },
  {
    id: 12,
    societe: 'EXCHANGE',
    compte: '100004',
    filiation: 0,
    email: 'contact@bernard-services.fr',
    isPrincipal: false,
    createdAt: new Date('2026-02-03T09:30:00'),
    updatedAt: null,
  },
  {
    id: 13,
    societe: 'SKI',
    compte: '100005',
    filiation: 0,
    email: 'luc.petit@email.com',
    isPrincipal: true,
    createdAt: new Date('2026-01-05T14:15:00'),
    updatedAt: new Date('2026-02-18T10:45:00'),
  },
  {
    id: 14,
    societe: 'SKI',
    compte: '100005',
    filiation: 0,
    email: 'l.petit@company.fr',
    isPrincipal: false,
    createdAt: new Date('2026-01-28T11:30:00'),
    updatedAt: null,
  },
  {
    id: 15,
    societe: 'SKI',
    compte: '100005',
    filiation: 0,
    email: 'contact@petit-consulting.com',
    isPrincipal: false,
    createdAt: new Date('2026-02-11T16:00:00'),
    updatedAt: null,
  },
];

const initialState: EmailSearchState = {
  emails: [],
  selectedEmail: null,
  isLoading: false,
  error: null,
  filters: {
    societe: '',
    compte: '',
    filiation: null,
    email: '',
  },
};

export const useEmailSearchStore = create<EmailSearchStore>()((set, get) => ({
  ...initialState,

  searchEmails: async (filters: SearchFilters) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const filtered = MOCK_EMAILS.filter((email) => {
        if (filters.societe && email.societe !== filters.societe) return false;
        if (filters.compte && email.compte !== filters.compte) return false;
        if (filters.filiation !== null && email.filiation !== filters.filiation) return false;
        if (filters.email && !email.email.toLowerCase().includes(filters.email.toLowerCase())) return false;
        return true;
      });
      set({ emails: filtered, isLoading: false });
      return;
    }

    try {
      const params: Record<string, string> = {};
      if (filters.societe) params.societe = filters.societe;
      if (filters.compte) params.compte = filters.compte;
      if (filters.filiation !== null) params.filiation = String(filters.filiation);
      if (filters.email) params.email = filters.email;

      const response = await apiClient.get<ApiResponse<GetEmailsResponse>>('/api/email-search/emails', { params });
      set({ emails: response.data.data?.data ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur recherche emails';
      set({ emails: [], error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  createEmail: async (data: CreateEmailDto) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const newEmail: EmailAddress = {
        id: Math.max(...MOCK_EMAILS.map((e) => e.id), 0) + 1,
        societe: data.societe,
        compte: data.compte,
        filiation: data.filiation,
        email: data.email,
        isPrincipal: data.isPrincipal ?? false,
        createdAt: new Date(),
        updatedAt: null,
      };

      if (data.isPrincipal) {
        MOCK_EMAILS.forEach((email) => {
          if (
            email.societe === data.societe &&
            email.compte === data.compte &&
            email.filiation === data.filiation
          ) {
            email.isPrincipal = false;
          }
        });
      }

      MOCK_EMAILS.push(newEmail);
      const { filters } = get();
      await get().searchEmails(filters);
      set({ isLoading: false });
      return;
    }

    try {
      const response = await apiClient.post<ApiResponse<CreateEmailResponse>>('/api/email-search/emails', data);
      const created = response.data.data?.data;
      if (created) {
        const currentEmails = get().emails;
        set({ emails: [...currentEmails, created] });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur création email';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  updateEmail: async (id: number, data: UpdateEmailDto) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const emailIndex = MOCK_EMAILS.findIndex((e) => e.id === id);
      if (emailIndex === -1) {
        set({ error: 'Email introuvable', isLoading: false });
        return;
      }

      const email = MOCK_EMAILS[emailIndex];
      if (data.email !== undefined) email.email = data.email;
      if (data.isPrincipal !== undefined && data.isPrincipal) {
        MOCK_EMAILS.forEach((e) => {
          if (
            e.societe === email.societe &&
            e.compte === email.compte &&
            e.filiation === email.filiation &&
            e.id !== id
          ) {
            e.isPrincipal = false;
          }
        });
        email.isPrincipal = true;
      }
      email.updatedAt = new Date();

      const { filters } = get();
      await get().searchEmails(filters);
      set({ isLoading: false });
      return;
    }

    try {
      const response = await apiClient.put<ApiResponse<UpdateEmailResponse>>(`/api/email-search/emails/${id}`, data);
      const updated = response.data.data?.data;
      if (updated) {
        const currentEmails = get().emails;
        set({ emails: currentEmails.map((e) => (e.id === id ? updated : e)) });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur modification email';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  deleteEmail: async (id: number) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const index = MOCK_EMAILS.findIndex((e) => e.id === id);
      if (index === -1) {
        set({ error: 'Email introuvable', isLoading: false });
        return;
      }
      MOCK_EMAILS.splice(index, 1);
      const { filters } = get();
      await get().searchEmails(filters);
      set({ isLoading: false });
      return;
    }

    try {
      await apiClient.delete<ApiResponse<DeleteEmailResponse>>(`/api/email-search/emails/${id}`);
      const currentEmails = get().emails;
      set({ emails: currentEmails.filter((e) => e.id !== id) });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur suppression email';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  setAsPrincipal: async (id: number) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const email = MOCK_EMAILS.find((e) => e.id === id);
      if (!email) {
        set({ error: 'Email introuvable', isLoading: false });
        return;
      }

      MOCK_EMAILS.forEach((e) => {
        if (
          e.societe === email.societe &&
          e.compte === email.compte &&
          e.filiation === email.filiation
        ) {
          e.isPrincipal = e.id === id;
        }
      });

      const { filters } = get();
      await get().searchEmails(filters);
      set({ isLoading: false });
      return;
    }

    try {
      await apiClient.post<ApiResponse<SetPrincipalResponse>>(`/api/email-search/emails/${id}/set-principal`);
      const currentEmails = get().emails;
      const email = currentEmails.find((e) => e.id === id);
      if (email) {
        set({
          emails: currentEmails.map((e) =>
            e.societe === email.societe &&
            e.compte === email.compte &&
            e.filiation === email.filiation
              ? { ...e, isPrincipal: e.id === id }
              : e,
          ),
        });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur définition email principal';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  selectEmail: (email: EmailAddress | null) => {
    set({ selectedEmail: email });
  },

  setFilters: (filters: SearchFilters) => {
    set({ filters });
  },

  clearFilters: () => {
    set({
      filters: {
        societe: '',
        compte: '',
        filiation: null,
        email: '',
      },
    });
  },

  resetState: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.