Generate Vitest component tests for "IntegriteDatesPage".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { render, screen, fireEvent, waitFor } from "@testing-library/react"
- Mock the store with vi.mock()
- CRITICAL: import the page component using @/ alias: import { IntegriteDatesPage } from "@/pages/IntegriteDatesPage"
- Place vi.mock() calls BEFORE the page import (vitest hoisting)
- Test: renders without crashing
- Test: displays loading state
- Test: displays data when loaded
- Test: handles user interactions (clicks, form submits)
- Test: displays error state

PAGE COMPONENT:
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Button, Dialog, Input } from '@/components/ui';
import { useIntegriteDatesStore } from '@/stores/integriteDatesStore';
import { useAuthStore } from '@/stores';
import type { DateCheckType } from '@/types/integriteDates';
import { cn } from '@/lib/utils';

const CHECK_TYPE_LABELS = {
  O: 'Ouverture',
  T: 'Transaction',
  F: 'Fermeture',
} as const;

export function IntegriteDatesPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);

  const checkType = useIntegriteDatesStore((s) => s.checkType);
  const societe = useIntegriteDatesStore((s) => s.societe);
  const isLoading = useIntegriteDatesStore((s) => s.isLoading);
  const error = useIntegriteDatesStore((s) => s.error);
  const validationResult = useIntegriteDatesStore((s) => s.validationResult);
  const ouvertureValidation = useIntegriteDatesStore((s) => s.ouvertureValidation);
  const transactionValidation = useIntegriteDatesStore((s) => s.transactionValidation);
  const fermetureValidation = useIntegriteDatesStore((s) => s.fermetureValidation);
  const setCheckType = useIntegriteDatesStore((s) => s.setCheckType);
  const setSociete = useIntegriteDatesStore((s) => s.setSociete);
  const validateDateIntegrity = useIntegriteDatesStore((s) => s.validateDateIntegrity);
  const checkOuverture = useIntegriteDatesStore((s) => s.checkOuverture);
  const checkTransaction = useIntegriteDatesStore((s) => s.checkTransaction);
  const checkFermeture = useIntegriteDatesStore((s) => s.checkFermeture);
  const clearValidationResult = useIntegriteDatesStore((s) => s.clearValidationResult);
  const reset = useIntegriteDatesStore((s) => s.reset);

  const [dateSession, setDateSession] = useState('');
  const [heureSession, setHeureSession] = useState('');
  const [showResultDialog, setShowResultDialog] = useState(false);

  useEffect(() => {
    setSociete('ADH');
    return () => reset();
  }, [setSociete, reset]);

  const handleValidate = useCallback(async () => {
    if (!societe) return;

    clearValidationResult();

    if (checkType === 'T') {
      if (!dateSession || !heureSession) {
        return;
      }
      await checkTransaction(societe, dateSession, heureSession);
    } else if (checkType === 'O') {
      await checkOuverture(societe);
    } else if (checkType === 'F') {
      await checkFermeture(societe);
    }

    setShowResultDialog(true);
  }, [
    societe,
    checkType,
    dateSession,
    heureSession,
    clearValidationResult,
    checkTransaction,
    checkOuverture,
    checkFermeture,
  ]);

  const handleBack = useCallback(() => {
    navigate('/caisse/menu');
  }, [navigate]);

  const handleCloseDialog = useCallback(() => {
    setShowResultDialog(false);
  }, []);

  const renderValidationStatus = () => {
    if (!validationResult) return null;

    const isValid = validationResult.isValid;
    const hasAnomaly = validationResult.hasClosureAnomaly;

    return (
      <div
        className={cn(
          'px-4 py-3 rounded-md text-sm',
          isValid && !hasAnomaly && 'bg-green-50 border border-green-200 text-green-700',
          !isValid && 'bg-red-50 border border-red-200 text-red-700',
          hasAnomaly && 'bg-yellow-50 border border-yellow-200 text-yellow-700',
        )}
      >
        <div className="font-semibold mb-1">
          {isValid && !hasAnomaly && '✓ Validation réussie'}
          {!isValid && '✗ Validation échouée'}
          {hasAnomaly && '⚠ Anomalie détectée'}
        </div>
        {validationResult.errorMessage && <div>{validationResult.errorMessage}</div>}
        {ouvertureValidation && (
          <div className="mt-2 space-y-1">
            <div>Date comptable: {ouvertureValidation.dateComptable}</div>
            <div>Date actuelle: {ouvertureValidation.currentDate}</div>
            {ouvertureValidation.delaiExceeded && <div>Délai dépassé</div>}
          </div>
        )}
        {transactionValidation && (
          <div className="mt-2 space-y-1">
            <div>Date session: {transactionValidation.dateSession}</div>
            <div>Heure session: {transactionValidation.heureSession}</div>
            <div>Timestamp valide: {transactionValidation.isTimestampValid ? 'Oui' : 'Non'}</div>
          </div>
        )}
        {fermetureValidation && (
          <div className="mt-2 space-y-1">
            <div>Anomalie: {fermetureValidation.hasAnomaly ? 'Oui' : 'Non'}</div>
            {fermetureValidation.blockedReason && <div>Raison: {fermetureValidation.blockedReason}</div>}
          </div>
        )}
      </div>
    );
  };

  return (
    <ScreenLayout>
      <div className="space-y-6 max-w-2xl mx-auto">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold">Intégrité des dates</h2>
            <p className="text-on-surface-muted text-sm mt-1">
              Validation des dates comptables et de session
            </p>
          </div>
          {user && (
            <span className="text-xs text-on-surface-muted">
              {user.prenom} {user.nom}
            </span>
          )}
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md text-sm">
            {error}
          </div>
        )}

        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Type de contrôle</label>
            <div className="flex gap-3">
              {(['O', 'T', 'F'] as const).map((type) => (
                <button
                  key={type}
                  onClick={() => setCheckType(type)}
                  className={cn(
                    'px-4 py-2 rounded-md border text-sm font-medium transition-colors',
                    checkType === type
                      ? 'bg-primary text-white border-primary'
                      : 'bg-surface border-border text-on-surface hover:bg-surface-hover',
                  )}
                >
                  {CHECK_TYPE_LABELS[type]}
                </button>
              ))}
            </div>
          </div>

          {checkType === 'T' && (
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium mb-2">Date session</label>
                <Input
                  type="date"
                  value={dateSession}
                  onChange={(e) => setDateSession(e.target.value)}
                  className="w-full"
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-2">Heure session</label>
                <Input
                  type="time"
                  value={heureSession}
                  onChange={(e) => setHeureSession(e.target.value)}
                  className="w-full"
                />
              </div>
            </div>
          )}

          {validationResult && renderValidationStatus()}

          <div className="flex gap-3 justify-between">
            <Button variant="secondary" onClick={handleBack}>
              Retour au menu
            </Button>
            <Button
              onClick={handleValidate}
              disabled={isLoading || (checkType === 'T' && (!dateSession || !heureSession))}
            >
              {isLoading ? 'Validation...' : 'Valider'}
            </Button>
          </div>
        </div>

        <Dialog open={showResultDialog} onClose={handleCloseDialog}>
          <div className="space-y-4">
            <h3 className="text-lg font-semibold">Résultat de la validation</h3>
            {renderValidationStatus()}
            <div className="flex justify-end">
              <Button onClick={handleCloseDialog}>Fermer</Button>
            </div>
          </div>
        </Dialog>
      </div>
    </ScreenLayout>
  );
}

TYPES:
// Integrite Dates types (IDE 286)

export type DateCheckType = 'O' | 'T' | 'F';

export interface DateIntegrityCheck {
  checkType: DateCheckType;
  societe: string;
  isValid: boolean;
  hasClosureAnomaly: boolean;
  errorMessage?: string;
  timestamp: string;
}

export interface DateComptable {
  checkType: DateCheckType;
  societe: string;
  controleOk: boolean;
  anomalieFermeture: boolean;
  dateComptable: string;
  delaiJours: number;
}

export interface OuvertureValidation {
  isValid: boolean;
  dateComptable: string;
  currentDate: string;
  delaiExceeded: boolean;
}

export interface TransactionValidation {
  isValid: boolean;
  dateSession: string;
  heureSession: string;
  currentTimestamp: number;
  sessionTimestamp: number;
  isTimestampValid: boolean;
}

export interface FermetureValidation {
  isValid: boolean;
  hasAnomaly: boolean;
  blockedReason?: string;
}

export interface DateCheckRequest {
  checkType: DateCheckType;
  societe: string;
  dateSession?: string;
  heureSession?: string;
}

export interface DateCheckResponse {
  success: boolean;
  data?: DateIntegrityCheck;
  error?: string;
}

export interface DateComptableResponse {
  success: boolean;
  data?: DateComptable;
  error?: string;
}

export interface IntegriteDatesState {
  checkType: DateCheckType;
  societe: string;
  isLoading: boolean;
  error: string | null;
  validationResult: DateIntegrityCheck | null;
  ouvertureValidation: OuvertureValidation | null;
  transactionValidation: TransactionValidation | null;
  fermetureValidation: FermetureValidation | null;
  
  setCheckType: (checkType: DateCheckType) => void;
  setSociete: (societe: string) => void;
  setError: (error: string | null) => void;
  clearValidationResult: () => void;
  
  validateDateIntegrity: (checkType: DateCheckType, societe: string) => Promise<DateIntegrityCheck>;
  checkOuverture: (societe: string) => Promise<boolean>;
  checkTransaction: (societe: string, dateSession: string, heureSession: string) => Promise<boolean>;
  checkFermeture: (societe: string) => Promise<{ isValid: boolean; hasAnomaly: boolean }>;
  reset: () => void;
}

export type ValidateOuvertureRequest = {
  checkType: 'O';
  societe: string;
};

export type ValidateTransactionRequest = {
  checkType: 'T';
  societe: string;
  dateSession: string;
  heureSession: string;
};

export type ValidateFermetureRequest = {
  checkType: 'F';
  societe: string;
};

export type DateCheckActionRequest =
  | ValidateOuvertureRequest
  | ValidateTransactionRequest
  | ValidateFermetureRequest;

export const DATE_CHECK_TYPES = {
  OUVERTURE: 'O' as const,
  TRANSACTION: 'T' as const,
  FERMETURE: 'F' as const,
} as const;

export const DATE_CHECK_LABELS = {
  O: 'Ouverture',
  T: 'Transaction',
  F: 'Fermeture',
} as const;

UI SECTIONS:
[
  {
    "name": "dateIntegrityValidation",
    "controls": [
      "checkType (hidden)",
      "societe (hidden)",
      "validationStatus (indicator)",
      "errorMessage (alert)"
    ]
  }
]