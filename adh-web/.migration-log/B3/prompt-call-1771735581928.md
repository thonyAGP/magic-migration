Generate a complete Zustand store for the "facturationAppel" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

STORE REQUIREMENTS:
- Use `create` from zustand (import { create } from "zustand")
- Import types from @/types/facturationAppel
- Import useDataSourceStore from @/stores/dataSourceStore
- Mock/API branching via useDataSourceStore.getState().isRealApi
- try/catch with `e instanceof Error` for error handling
- Realistic mock data (not lorem ipsum)
- EVERY business rule from the analysis MUST be implemented
- Include reset() action to clear state

TYPES FILE (already generated):
import type { ApiResponse } from "@/services/api/apiClient";

export type QualiteAppel = 'OK' | 'Mauvaise' | 'Interruption';
export type TypeCompte = 'GO' | 'GM';

export interface HistoriqueAppel {
  id?: number;
  societe: string;
  prefixe: string;
  dateAppel: Date;
  heureAppel: string;
  numeroTel: string;
  duree: string;
  montant: number;
  qualite: QualiteAppel | null;
  gratuite: boolean;
  raisonGratuite: string | null;
  facture?: boolean;
  operationId?: number;
}

export interface CoefTelephone {
  coefficient: number;
}

export interface ReseauCloture {
  cloture_enCours: boolean;
  testReseau: string | null;
}

export interface FacturationRequest {
  appel: HistoriqueAppel;
  numeroCompte: number;
  filiation: number;
  typeCompte: TypeCompte;
}

export interface FacturationResponse {
  success: boolean;
  operationId?: number;
  message?: string;
}

export interface MarquerGratuitRequest {
  appelId: number;
  raison: string;
}

export interface AnnulerFacturationRequest {
  appelId: number;
}

export interface FacturationAppelState {
  historiqueAppels: HistoriqueAppel[];
  coefficientTelephone: number | null;
  cloture: ReseauCloture | null;
  isLoading: boolean;
  error: string | null;
  filterSociete: string;
  filterDateDebut: Date | null;
  filterDateFin: Date | null;
}

export interface FacturationAppelActions {
  chargerHistoriqueAppels: (
    societe: string,
    prefixe: string,
    dateDebut?: Date,
    dateFin?: Date
  ) => Promise<void>;
  recupererCoefficient: () => Promise<void>;
  facturationAppel: (request: FacturationRequest) => Promise<void>;
  verifierCloture: () => Promise<boolean>;
  debloquerCloture: () => Promise<void>;
  marquerGratuit: (appelId: number, raison: string) => Promise<void>;
  annulerFacturation: (appelId: number) => Promise<void>;
  setFilterSociete: (societe: string) => void;
  setFilterDateDebut: (date: Date | null) => void;
  setFilterDateFin: (date: Date | null) => void;
  resetFilters: () => void;
  setError: (error: string | null) => void;
}

export type FacturationAppelStore = FacturationAppelState & FacturationAppelActions;

export interface GetHistoriqueAppelsRequest {
  societe: string;
  prefixe: string;
  dateDebut?: Date;
  dateFin?: Date;
}

export interface GetHistoriqueAppelsResponse extends ApiResponse {
  data: HistoriqueAppel[];
}

export interface GetCoefficientResponse extends ApiResponse {
  data: CoefTelephone;
}

export interface FacturerAppelResponse extends ApiResponse {
  data: FacturationResponse;
}

export interface GetClotureStatusResponse extends ApiResponse {
  data: ReseauCloture;
}

export interface DebloquerClotureResponse extends ApiResponse {
  data: { success: boolean };
}

export interface MarquerGratuitResponse extends ApiResponse {
  data: { success: boolean };
}

export interface AnnulerFacturationResponse extends ApiResponse {
  data: { success: boolean };
}

export const DEFAULT_FACTURATION_APPEL_STATE: FacturationAppelState = {
  historiqueAppels: [],
  coefficientTelephone: null,
  cloture: null,
  isLoading: false,
  error: null,
  filterSociete: '',
  filterDateDebut: null,
  filterDateFin: null,
};

export const QUALITE_APPEL_OPTIONS = ['OK', 'Mauvaise', 'Interruption'] as const;

export const TYPE_COMPTE_OPTIONS = ['GO', 'GM'] as const;

ANALYSIS DOCUMENT:
{
  "domain": "facturationAppel",
  "domainPascal": "FacturationAppel",
  "complexity": "MEDIUM",
  "entities": [
    {
      "name": "HistoriqueAppel",
      "fields": [
        {
          "name": "societe",
          "type": "string",
          "source": "historique_pabx.societe",
          "nullable": false
        },
        {
          "name": "prefixe",
          "type": "string",
          "source": "historique_pabx.prefixe",
          "nullable": false
        },
        {
          "name": "dateAppel",
          "type": "Date",
          "source": "historique_pabx.date_appel",
          "nullable": false
        },
        {
          "name": "heureAppel",
          "type": "string",
          "source": "historique_pabx.heure_appel",
          "nullable": false
        },
        {
          "name": "numeroTel",
          "type": "string",
          "source": "historique_pabx.numero_tel",
          "nullable": false
        },
        {
          "name": "duree",
          "type": "string",
          "source": "historique_pabx.duree",
          "nullable": false
        },
        {
          "name": "montant",
          "type": "number",
          "source": "historique_pabx.montant",
          "nullable": false
        },
        {
          "name": "qualite",
          "type": "string",
          "source": "historique_pabx.qualite",
          "nullable": true
        },
        {
          "name": "gratuite",
          "type": "boolean",
          "source": "historique_pabx.gratuite",
          "nullable": false
        },
        {
          "name": "raisonGratuite",
          "type": "string",
          "source": "historique_pabx.raison_gratuite",
          "nullable": true
        }
      ]
    },
    {
      "name": "CoefTelephone",
      "fields": [
        {
          "name": "coefficient",
          "type": "number",
          "source": "coef__telephone__coe.coeff_tel",
          "nullable": false
        }
      ]
    },
    {
      "name": "ReseauCloture",
      "fields": [
        {
          "name": "cloture enCours",
          "type": "boolean",
          "source": "reseau_cloture___rec.cloture_en_cours",
          "nullable": false
        },
        {
          "name": "testReseau",
          "type": "string",
          "source": "reseau_cloture___rec.test_reseau",
          "nullable": true
        }
      ]
    }
  ],
  "stateFields": [
    {
      "name": "historiqueAppels",
      "type": "HistoriqueAppel[]",
      "default": "[]"
    },
    {
      "name": "coefficientTelephone",
      "type": "number | null",
      "default": "null"
    },
    {
      "name": "cloture",
      "type": "ReseauCloture | null",
      "default": "null"
    },
    {
      "name": "isLoading",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "error",
      "type": "string | null",
      "default": "null"
    },
    {
      "name": "filterSociete",
      "type": "string",
      "default": "''"
    },
    {
      "name": "filterDateDebut",
      "type": "Date | null",
      "default": "null"
    },
    {
      "name": "filterDateFin",
      "type": "Date | null",
      "default": "null"
    }
  ],
  "actions": [
    {
      "name": "chargerHistoriqueAppels",
      "params": [
        "societe: string",
        "prefixe: string",
        "dateDebut?: Date",
        "dateFin?: Date"
      ],
      "businessRules": [
        "Charger l'historique des appels filtré par société, préfixe et dates",
        "Trier par date et heure d'appel décroissant"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "recupererCoefficient",
      "params": [],
      "businessRules": [
        "Récupérer le coefficient de facturation téléphonique actif",
        "Stocker dans le state pour calcul ultérieur"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "facturer Appel",
      "params": [
        "appel: HistoriqueAppel",
        "numeroCompte: number",
        "filiation: number",
        "typeCompte: 'GO' | 'GM'"
      ],
      "businessRules": [
        "[RM-001] Si > GO [G] alors 'GO' sinon 'GM')",
        "Calculer le montant basé sur durée × coefficient",
        "Créer une opération de débit (O.D)",
        "Marquer l'appel comme facturé",
        "Vérifier si compte fictif avant facturation",
        "Gérer les appels gratuits (pas de facturation)"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "verifierCloture",
      "params": [],
      "businessRules": [
        "Vérifier si une clôture est en cours",
        "Bloquer les opérations si clôture active"
      ],
      "returns": "Promise<boolean>"
    },
    {
      "name": "debloquerCloture",
      "params": [],
      "businessRules": [
        "Débloquer le compte GM après traitement",
        "Mettre à jour le statut de clôture"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "marquerGratuit",
      "params": [
        "appelId: number",
        "raison: string"
      ],
      "businessRules": [
        "Marquer un appel comme gratuit avec raison",
        "Ne pas facturer si gratuit = true"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "annulerFacturation",
      "params": [
        "appelId: number"
      ],
      "businessRules": [
        "Annuler une facturation existante",
        "Créer une opération de crédit inverse",
        "Restaurer l'état non facturé"
      ],
      "returns": "Promise<void>"
    }
  ],
  "apiEndpoints": [
    {
      "method": "GET",
      "path": "/api/facturation-appel/historique",
      "queryParams": [
        "societe",
        "prefixe",
        "dateDebut?",
        "dateFin?"
      ],
      "response": "HistoriqueAppel[]"
    },
    {
      "method": "GET",
      "path": "/api/facturation-appel/coefficient",
      "queryParams": [],
      "response": "CoefTelephone"
    },
    {
      "method": "POST",
      "path": "/api/facturation-appel/facturer",
      "queryParams": [],
      "response": "{ success: boolean, operationId?: number }"
    },
    {
      "method": "GET",
      "path": "/api/facturation-appel/cloture-status",
      "queryParams": [],
      "response": "ReseauCloture"
    },
    {
      "method": "POST",
      "path": "/api/facturation-appel/debloquer-cloture",
      "queryParams": [],
      "response": "{ success: boolean }"
    },
    {
      "method": "PUT",
      "path": "/api/facturation-appel/marquer-gratuit/:id",
      "queryParams": [],
      "response": "{ success: boolean }"
    },
    {
      "method": "DELETE",
      "path": "/api/facturation-appel/annuler/:id",
      "queryParams": [],
      "response": "{ success: boolean }"
    }
  ],
  "uiLayout": {
    "type": "data-grid-page",
    "sections": [
      {
        "name": "filters",
        "controls": [
          "societe (select)",
          "prefixe (input)",
          "dateDebut (datepicker)",
          "dateFin (datepicker)",
          "btnSearch"
        ]
      },
      {
        "name": "grid",
        "controls": [
          "dateAppel (col)",
          "heureAppel (col)",
          "numeroTel (col)",
          "duree (col)",
          "montant (col)",
          "qualite (col)",
          "gratuite (col badge)",
          "actions (col buttons)"
        ]
      },
      {
        "name": "actions",
        "controls": [
          "btnFacturer",
          "btnMarquerGratuit",
          "btnAnnuler"
        ]
      },
      {
        "name": "summary",
        "controls": [
          "totalAppels (stat)",
          "totalMontant (stat)",
          "coefficientActuel (stat)",
          "cloture Status (badge)"
        ]
      }
    ]
  },
  "mockData": {
    "count": 8,
    "description": "8 appels téléphoniques avec variété: appels locaux/internationaux, durées 2-45min, montants 1.50-35.80 EUR, 2 appels gratuits (urgence, erreur), qualités OK/Mauvaise, dates derniers 7 jours, coefficient 0.15 EUR/min"
  },
  "dependencies": {
    "stores": [
      "useSessionStore (societe, prefixe actifs)",
      "useParametresStore (test reseau)",
      "useTransactionStore (création O.D)"
    ],
    "sharedTypes": [
      "HistoriqueAppel",
      "CoefTelephone",
      "ReseauCloture"
    ],
    "externalApis": [
      "GET /api/facturation-appel/historique",
      "GET /api/facturation-appel/coefficient",
      "POST /api/facturation-appel/facturer",
      "GET /api/facturation-appel/cloture-status"
    ]
  }
}

SPEC EXCERPT (business rules):
﻿# ADH IDE 175 - Facturation appel

> **Analyse**: Phases 1-4 2026-02-03 10:54 -> 10:54 (16s) | Assemblage 07:24
> **Pipeline**: V7.2 Enrichi
> **Structure**: 4 onglets (Resume | Ecrans | Donnees | Connexions)

<!-- TAB:Resume -->

## 1. FICHE D'IDENTITE

| Attribut | Valeur |
|----------|--------|
| Projet | ADH |
| IDE Position | 175 |
| Nom Programme | Facturation appel |
| Fichier source | `Prg_175.xml` |
| Dossier IDE | Operations |
| Taches | 6 (0 ecrans visibles) |
| Tables modifiees | 3 |
| Programmes appeles | 5 |

## 2. DESCRIPTION FONCTIONNELLE

**Facturation appel** assure la gestion complete de ce processus, accessible depuis [Menu caisse GM - scroll @ (IDE 22)](ADH-IDE-22.md).

Le flux de traitement s'organise en **1 blocs fonctionnels** :

- **Traitement** (6 taches) : traitements metier divers

**Donnees modifiees** : 3 tables en ecriture (reseau_cloture___rec, historique_pabx, coef__telephone__coe).

**Logique metier** : 1 regles identifiees couvrant conditions metier.

<details>
<summary>Detail : phases du traitement</summary>

#### Phase 1 : Traitement (6 taches)

- **T1** - Facturation appel
- **T2** - Historique appel
- **T3** - Historique appel
- **T4** - Recuperation coef
- **T5** - Deblocage cloture
- **T8** - Deblocage cloture

Delegue a : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

#### Tables impactees

| Table | Operations | Role metier |
|-------|-----------|-------------|
| reseau_cloture___rec | **W** (2 usages) | Donnees reseau/cloture |
| historique_pabx | **W** (2 usages) | Historique / journal |
| coef__telephone__coe | **W** (1 usages) |  |

</details>

## 3. BLOCS FONCTIONNELS

### 3.1 Traitement (6 taches)

Traitements internes.

---

#### <a id="t1"></a>T1 - Facturation appel

**Role** : Tache d'orchestration : point d'entree du programme (6 sous-taches). Coordonne l'enchainement des traitements.

<details>
<summary>5 sous-taches directes</summary>

| Tache | Nom | Bloc |
|-------|-----|------|
| [T2](#t2) | Historique appel | Traitement |
| [T3](#t3) | Historique appel | Traitement |
| [T4](#t4) | Recuperation coef | Traitement |
| [T5](#t5) | Deblocage cloture | Traitement |
| [T8](#t8) | Deblocage cloture | Traitement |

</details>
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t2"></a>T2 - Historique appel

**Role** : Consultation/chargement : Historique appel.
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t3"></a>T3 - Historique appel

**Role** : Consultation/chargement : Historique appel.
**Variables liees** : C (> date appel), D (> heure appel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t4"></a>T4 - Recuperation coef

**Role** : Consultation/chargement : Recuperation coef.
**Variables liees** : V (w0 coeff tel)
**Delegue a** : [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t5"></a>T5 - Deblocage cloture

**Role** : Traitement : Deblocage cloture.
**Variables liees** : W (w0 cloture en cours)
**Delegue a** : [  Deblocage compte GM (IDE 17)](ADH-IDE-17.md), [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)

---

#### <a id="t8"></a>T8 - Deblocage cloture

**Role** : Traitement : Deblocage cloture.
**Variables liees** : W (w0 cloture en cours)
**Delegue a** : [  Deblocage compte GM (IDE 17)](ADH-IDE-17.md), [  Test reseau (IDE 18)](ADH-IDE-18.md), [  Test si cloture en cours (IDE 19)](ADH-IDE-19.md)


## 5. REGLES METIER

1 regles identifiees:

### Autres (1 regles)

#### <a id="rm-RM-001"></a>[RM-001] Si > GO [G] alors 'GO' sinon 'GM')

| Element | Detail |
|---------|--------|
| **Condition** | `> GO [G]` |
| **Si vrai** | 'GO' |
| **Si faux** | 'GM') |
| **Variables** | G (> GO) |
| **Expression source** | Expression 4 : `IF (> GO [G],'GO','GM')` |
| **Exemple** | Si > GO [G] â†’ 'GO'. Sinon â†’ 'GM') |

## 6. CONTEXTE

- **Appele par**: [Menu caisse GM - scroll @ (IDE 22)](ADH-IDE-22.md)
- **Appelle**: 5 programmes | **Tables**: 3 (W:3 R:0 L:0) | **Taches**: 6 | **Expressions**: 15

<!-- TAB:Ecrans -->

## 8. ECRANS

*(Programme sans ecran visible)*

## 9. NAVIGATION

### 9.3 Structure hierarchique (6 taches)

| Position | Tache | Type | Dimensions | Bloc |
|----------|-------|------|------------|------|
| **175.1** | [**Facturation appel** (T1)](#t1) | MDI | - | Traitement |
| 175.1.1 | [Historique appel (T2)](#t2) | MDI | - | |
| 175.1.2 | [Historique appel (T3)](#t3) | MDI | - | |
| 175.1.3 | [Recuperation coef (T4)](#t4) | MDI | - | |
| 175.1.4 | [Deblocage cloture (T5)](#t5) | MDI | - | |
| 175.1.5 | [Deblocage cloture (T8)](#t8) | MDI | - | |

### 9.4 Algorigramme

```mermaid
flowchart TD
    START([START])
    PROCESS[Traitement 6 taches]
    ENDOK([END])
    START --> PROCESS --> ENDOK
    style START fill:#3fb950,color:#000
    style ENDOK fill:#3fb950,color:#000
```

> *algo-data indisponible. Utiliser `/algorigramme` pour generer.*

<!-- TAB:Donnees -->

## 10. TABLES

### Tables utilisees (3)

| ID | Nom | Description | Type | R | W | L | Usages |
|----|-----|-------------|------|---|---|---|--------|
| 23 | reseau_cloture___rec | Donnees reseau/cloture | DB |   | **W** |   | 2 |
| 155 | historique_pabx | Historique / journal | DB |   | **W** |   | 2 |
| 157 | coef__telephone__coe |  | DB |   | **W** |   | 1 |

### Colonnes par table (2 / 3 tables avec colonnes identifiees)

<details>
<summary>Table 23 - reseau_cloture___rec (**W**) - 2 usages</summary>

| Lettre | Variable | Acces | Type |
|--------|----------|-------|------|
| W | w0 cloture en cours | W | Logical |
| X | w0 test reseau | W | Alpha |

</details>



REFERENCE PATTERN (follow this exact structure):
```typescript
import { create } from 'zustand';
import type {
  ExtraitAccountInfo,
  ExtraitTransaction,
  ExtraitSummary,
  ExtraitPrintFormat,
} from '@/types/extrait';
import { extraitApi } from '@/services/api/endpoints-lot3';
import { useDataSourceStore } from './dataSourceStore';

interface ExtraitState {
  selectedAccount: ExtraitAccountInfo | null;
  transactions: ExtraitTransaction[];
  summary: ExtraitSummary | null;
  searchResults: ExtraitAccountInfo[];
  isSearching: boolean;
  isLoadingExtrait: boolean;
  isPrinting: boolean;
  error: string | null;
}

interface ExtraitActions {
  searchAccount: (societe: string, query: string) => Promise<void>;
  selectAccount: (account: ExtraitAccountInfo) => void;
  loadExtrait: (
    societe: string,
    codeAdherent: number,
    filiation: number,
    dateDebut?: string,
    dateFin?: string,
  ) => Promise<void>;
  printExtrait: (
    societe: string,
    codeAdherent: number,
    filiation: number,
    format: ExtraitPrintFormat,
  ) => Promise<void>;
  reset: () => void;
}

type ExtraitStore = ExtraitState & ExtraitActions;

const MOCK_ACCOUNTS: ExtraitAccountInfo[] = [
  { societe: 'SOC1', codeAdherent: 1001, filiation: 0, nom: 'DUPONT', prenom: 'Jean', statut: 'normal', hasGiftPass: false },
  { societe: 'SOC1', codeAdherent: 1002, filiation: 0, nom: 'MARTIN', prenom: 'Sophie', statut: 'normal', hasGiftPass: true },
  { societe: 'SOC1', codeAdherent: 1003, filiation: 1, nom: 'DURAND', prenom: 'Pierre', statut: 'bloque', hasGiftPass: false },
];

const MOCK_TRANSACTIONS: ExtraitTransaction[] = [
  { id: 1, date: '2026-02-10', heure: '09:15', libelle: 'Achat boutique', debit: 45.50, credit: 0, solde: -45.50, codeService: 'BTQ', codeImputation: 'IMP01', giftPassFlag: false, nbArticles: 3, status: 'debit', numeroPiece: 'VTE-001', modePaiement: 'CB', caissier: 'MARTIN S.' },
  { id: 2, date: '2026-02-10', heure: '14:30', libelle: 'Credit compte', debit: 0, credit: 200, solde: 154.50, codeService: 'CAI', codeImputation: 'IMP02', giftPassFlag: false, status: 'credit', numeroPiece: 'CRD-042', modePaiement: 'Especes', caissier: 'DUPONT J.' },
  { id: 3, date: '2026-02-09', heure: '12:45', libelle: 'Repas restaurant', libelleSupplementaire: 'Menu du jour', debit: 32.00, credit: 0, solde: 122.50, codeService: 'RST', codeImputation: 'IMP03', giftPassFlag: true, nbArticles: 1, status: 'debit', numeroPiece: 'RST-117', modePaiement: 'GiftPass', caissier: 'MARTIN S.' },
  { id: 4, date: '2026-02-08', heure: '16:00', libelle: 'Annulation vente', debit: 0, credit: 15.00, solde: 154.50, codeService: 'BTQ', codeImputation: 'IMP01', giftPassFlag: false, status: 'annule', numeroPiece: 'ANN-003', modePaiement: 'CB', caissier: 'DUPONT J.', commentaire: 'Erreur de saisie' },
  { id: 5, date: '2026-02-08', heure: '10:20', libelle: 'Regularisation solde', debit: 0, credit: 5.00, solde: 139.50, codeService: 'CAI', codeImputation: 'IMP02', giftPassFlag: false, status: 'regularise', numeroPiece: 'REG-007', modePaiement: 'Interne', caissier: 'ADMIN' },
];

const MOCK_SUMMARY: ExtraitSummary = {
  totalDebit: 77.50,
  totalCredit: 220,
  soldeActuel: 142.50,
  nbTransactions: 5,
};

const initialState: ExtraitState = {
  selectedAccount: null,
  transactions: [],
  summary: null,
  searchResults: [],
  isSearching: false,
  isLoadingExtrait: false,
  isPrinting: false,
  error: null,
};

export const useExtraitStore = create<ExtraitStore>()((set) => ({
  ...initialState,

  searchAccount: async (societe, query) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isSearching: true, error: null });

    if (!isRealApi) {
      const filtered = MOCK_ACCOUNTS.filter(
        (a) =>
          a.nom.toLowerCase().includes(query.toLowerCase()) ||
          a.prenom.toLowerCase().includes(query.toLowerCase()) ||
          String(a.codeAdherent).includes(query),
      );
      set({ searchResults: filtered, isSearching: false });
      return;
    }

    try {
      const response = await extraitApi.searchAccount(societe, query);
      set({ searchResults: response.data.data ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur recherche compte';
      set({ searchResults: [], error: message });
    } finally {
      set({ isSearching: false });
    }
  },

  selectAccount: (account) => {
    set({ selectedAccount: account, transactions: [], summary: null, error: null });
  },

  loadExtrait: async (societe, codeAdherent, filiation, dateDebut, dateFin) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoadingExtrait: true, error: null });

    if (!isRealApi) {
      set({
        transactions: MOCK_TRANSACTIONS,
        summary: MOCK_SUMMARY,
        isLoadingExtrait: false,
      });
      return;
    }

    try {
      const response = await extraitApi.getExtrait(
        societe,
        codeAdherent,
        filiation,
        dateDebut,
        dateFin,
      );
      const data = response.data.data;
      set({
        transactions: data?.transactions ?? [],
        summary: data?.summary ?? null,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement extrait';
      set({ transactions: [], summary: null, error: message });
    } finally {
      set({ isLoadingExtrait: false });
    }
  },

  printExtrait: async (societe, codeAdherent, filiation, format) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isPrinting: true, error: null });

    if (!isRealApi) {
      set({ isPrinting: false });
      return;
    }

    try {
      await extraitApi.printExtrait({
        societe,
        codeAdherent,
        filiation,
        format,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur impression';
      set({ error: message });
    } finally {
      set({ isPrinting: false });
    }
  },

  reset: () => set({ ...initialState }),
}));

```