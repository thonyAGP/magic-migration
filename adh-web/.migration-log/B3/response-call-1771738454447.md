Looking at the failing tests, the issue is that when API calls fail (either with `ok: false` or network errors), the store is setting `error` to the error message, but the tests are checking `store.error` **after** the promise rejects. However, the act of throwing the error happens, but then the test is checking the state synchronously.

The real issue is that the tests expect the error to be set in the store state after rejection, but they're using `await expect(...).rejects.toThrow()` which catches the thrown error. After the promise rejects, we need to check the store state.

For the loading state test, the issue is that we're checking `store.isLoading` immediately after calling the async function, but before the mock has actually started executing. We need to use `useMoyenPaiementStore.getState().isLoading` to get the current state from the store.

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useMoyenPaiementStore } from '@/stores/moyenPaiementStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type { MoyenPaiement, MOPInfo } from '@/types/moyenPaiement';

const MOCK_MOP_CB: MoyenPaiement = {
  code: 'CB',
  libelle: 'Carte Bancaire',
  classe: 'UNI',
  typeDevise: 'UNI',
};

const MOCK_MOP_CHG: MoyenPaiement = {
  code: 'CHG',
  libelle: 'Change',
  classe: 'BI',
  typeDevise: 'BI',
};

const MOCK_MOP_INFO_CB: MOPInfo = {
  classe: 'UNI',
  libelle: 'Carte Bancaire',
  existe: true,
};

const MOCK_MOP_INFO_NOT_FOUND: MOPInfo = {
  classe: 'UNI',
  libelle: '',
  existe: false,
};

global.fetch = vi.fn();

describe('moyenPaiementStore', () => {
  beforeEach(() => {
    useMoyenPaiementStore.getState().reset();
    vi.clearAllMocks();
    useDataSourceStore.setState({ isRealApi: false });
  });

  describe('getMOPInfo', () => {
    it('should get MOP info for UNI typeDevise in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPInfo('CB', 'UNI');

      expect(result).toEqual({
        classe: 'UNI',
        libelle: 'Carte Bancaire',
        existe: true,
      });
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should get MOP info for BI typeDevise in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPInfo('CHG', 'BI');

      expect(result).toEqual({
        classe: 'BI',
        libelle: 'Change',
        existe: true,
      });
      expect(store.isLoading).toBe(false);
    });

    it('should return non-existent MOP info in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPInfo('XXX', 'UNI');

      expect(result).toEqual({
        classe: 'UNI',
        libelle: '',
        existe: false,
      });
      expect(store.isLoading).toBe(false);
    });

    it('should get MOP info from API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: MOCK_MOP_INFO_CB }),
      });

      const result = await store.getMOPInfo('CB', 'UNI');

      expect(result).toEqual(MOCK_MOP_INFO_CB);
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/moyenpaiement/info?code=CB&typeDevise=UNI',
      );
      expect(store.isLoading).toBe(false);
    });

    it('should get MOP info without typeDevise in API mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: MOCK_MOP_INFO_CB }),
      });

      await store.getMOPInfo('CB', 'UNI');

      expect(global.fetch).toHaveBeenCalledWith(
        '/api/moyenpaiement/info?code=CB&typeDevise=UNI',
      );
    });

    it('should handle API error when getting MOP info', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: false,
      });

      await expect(store.getMOPInfo('CB', 'UNI')).rejects.toThrow(
        'Erreur récupération info MOP',
      );
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
      expect(useMoyenPaiementStore.getState().error).toBe('Erreur récupération info MOP');
    });

    it('should handle network error when getting MOP info', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
        new Error('Network error'),
      );

      await expect(store.getMOPInfo('CB', 'UNI')).rejects.toThrow(
        'Network error',
      );
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
      expect(useMoyenPaiementStore.getState().error).toBe('Network error');
    });

    it('should set loading state during API call', async () => {
      useDataSourceStore.setState({ isRealApi: true });

      (global.fetch as ReturnType<typeof vi.fn>).mockImplementationOnce(
        () =>
          new Promise((resolve) =>
            setTimeout(
              () =>
                resolve({
                  ok: true,
                  json: async () => ({ data: MOCK_MOP_INFO_CB }),
                }),
              10,
            ),
          ),
      );

      const promise = useMoyenPaiementStore.getState().getMOPInfo('CB', 'UNI');
      
      await vi.waitFor(() => {
        expect(useMoyenPaiementStore.getState().isLoading).toBe(true);
      });

      await promise;
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
    });
  });

  describe('checkMOPExists', () => {
    it('should check MOP exists in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.checkMOPExists('CB', 'PHU');

      expect(result).toBe(true);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should return false for non-existent MOP in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.checkMOPExists('XXX', 'PHU');

      expect(result).toBe(false);
      expect(store.isLoading).toBe(false);
    });

    it('should check MOP exists from API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: { existe: true } }),
      });

      const result = await store.checkMOPExists('CB', 'PHU');

      expect(result).toBe(true);
      expect(global.fetch).toHaveBeenCalledWith(
        '/api/moyenpaiement/exists?code=CB&societe=PHU',
      );
      expect(store.isLoading).toBe(false);
    });

    it('should handle API error when checking MOP exists', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: false,
      });

      await expect(store.checkMOPExists('CB', 'PHU')).rejects.toThrow(
        'Erreur vérification existence MOP',
      );
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
      expect(useMoyenPaiementStore.getState().error).toBe('Erreur vérification existence MOP');
    });

    it('should handle network error when checking MOP exists', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
        new Error('Connection failed'),
      );

      await expect(store.checkMOPExists('CB', 'PHU')).rejects.toThrow(
        'Connection failed',
      );
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
      expect(useMoyenPaiementStore.getState().error).toBe('Connection failed');
    });
  });

  describe('getMOPByCode', () => {
    it('should get MOP by code in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPByCode('CB');

      expect(result).toEqual(MOCK_MOP_CB);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should return null for non-existent MOP in mock mode', async () => {
      const store = useMoyenPaiementStore.getState();

      const result = await store.getMOPByCode('XXX');

      expect(result).toBeNull();
      expect(store.isLoading).toBe(false);
    });

    it('should get MOP by code from API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: MOCK_MOP_CB }),
      });

      const result = await store.getMOPByCode('CB');

      expect(result).toEqual(MOCK_MOP_CB);
      expect(global.fetch).toHaveBeenCalledWith('/api/moyenpaiement/CB');
      expect(store.isLoading).toBe(false);
    });

    it('should handle API error when getting MOP by code', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        ok: false,
      });

      await expect(store.getMOPByCode('CB')).rejects.toThrow(
        'Erreur récupération MOP',
      );
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
      expect(useMoyenPaiementStore.getState().error).toBe('Erreur récupération MOP');
    });

    it('should handle network error when getting MOP by code', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const store = useMoyenPaiementStore.getState();

      (global.fetch as ReturnType<typeof vi.fn>).mockRejectedValueOnce(
        new Error('Timeout'),
      );

      await expect(store.getMOPByCode('CB')).rejects.toThrow('Timeout');
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
      expect(useMoyenPaiementStore.getState().error).toBe('Timeout');
    });
  });

  describe('setMoyensPaiement', () => {
    it('should set moyens paiement', () => {
      const store = useMoyenPaiementStore.getState();
      const moyens: MoyenPaiement[] = [MOCK_MOP_CB, MOCK_MOP_CHG];

      store.setMoyensPaiement(moyens);

      expect(useMoyenPaiementStore.getState().moyensPaiement).toEqual(moyens);
    });
  });

  describe('setSelectedMOP', () => {
    it('should set selected MOP', () => {
      const store = useMoyenPaiementStore.getState();

      store.setSelectedMOP(MOCK_MOP_CB);

      expect(useMoyenPaiementStore.getState().selectedMOP).toEqual(
        MOCK_MOP_CB,
      );
    });

    it('should clear selected MOP', () => {
      const store = useMoyenPaiementStore.getState();
      store.setSelectedMOP(MOCK_MOP_CB);

      store.setSelectedMOP(null);

      expect(useMoyenPaiementStore.getState().selectedMOP).toBeNull();
    });
  });

  describe('setIsLoading', () => {
    it('should set loading state', () => {
      const store = useMoyenPaiementStore.getState();

      store.setIsLoading(true);
      expect(useMoyenPaiementStore.getState().isLoading).toBe(true);

      store.setIsLoading(false);
      expect(useMoyenPaiementStore.getState().isLoading).toBe(false);
    });
  });

  describe('setError', () => {
    it('should set error', () => {
      const store = useMoyenPaiementStore.getState();

      store.setError('Test error');
      expect(useMoyenPaiementStore.getState().error).toBe('Test error');

      store.setError(null);
      expect(useMoyenPaiementStore.getState().error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', () => {
      const store = useMoyenPaiementStore.getState();
      store.setMoyensPaiement([MOCK_MOP_CB]);
      store.setSelectedMOP(MOCK_MOP_CB);
      store.setIsLoading(true);
      store.setError('Test error');

      store.reset();

      const state = useMoyenPaiementStore.getState();
      expect(state.moyensPaiement).toEqual([]);
      expect(state.selectedMOP).toBeNull();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });
  });
});
```