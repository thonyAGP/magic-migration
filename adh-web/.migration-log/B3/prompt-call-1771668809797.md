Generate Vitest unit tests for the "integriteDatesStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  DateIntegrityCheck,
  DateComptable,
  OuvertureValidation,
  TransactionValidation,
  FermetureValidation,
  DateCheckType,
} from '@/types/integriteDates';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface IntegriteDatesState {
  checkType: DateCheckType;
  societe: string;
  isLoading: boolean;
  error: string | null;
  validationResult: DateIntegrityCheck | null;
  ouvertureValidation: OuvertureValidation | null;
  transactionValidation: TransactionValidation | null;
  fermetureValidation: FermetureValidation | null;
}

interface IntegriteDatesActions {
  setCheckType: (checkType: DateCheckType) => void;
  setSociete: (societe: string) => void;
  setError: (error: string | null) => void;
  clearValidationResult: () => void;
  validateDateIntegrity: (checkType: DateCheckType, societe: string) => Promise<DateIntegrityCheck>;
  checkOuverture: (societe: string) => Promise<boolean>;
  checkTransaction: (societe: string, dateSession: string, heureSession: string) => Promise<boolean>;
  checkFermeture: (societe: string) => Promise<{ isValid: boolean; hasAnomaly: boolean }>;
  reset: () => void;
}

type IntegriteDatesStore = IntegriteDatesState & IntegriteDatesActions;

const MOCK_DATE_COMPTABLE: DateComptable = {
  checkType: 'O',
  societe: 'SOC1',
  controleOk: true,
  anomalieFermeture: false,
  dateComptable: '2026-02-20',
  delaiJours: 3,
};

const MOCK_VALIDATIONS: Record<DateCheckType, DateIntegrityCheck> = {
  O: {
    checkType: 'O',
    societe: 'SOC1',
    isValid: true,
    hasClosureAnomaly: false,
    timestamp: new Date().toISOString(),
  },
  T: {
    checkType: 'T',
    societe: 'SOC1',
    isValid: false,
    hasClosureAnomaly: false,
    errorMessage: 'Transaction timestamp invalide: session date/heure antérieure à maintenant',
    timestamp: new Date().toISOString(),
  },
  F: {
    checkType: 'F',
    societe: 'SOC1',
    isValid: false,
    hasClosureAnomaly: true,
    errorMessage: 'Anomalie détectée: fermeture bloquée',
    timestamp: new Date().toISOString(),
  },
};

const initialState: IntegriteDatesState = {
  checkType: 'O',
  societe: '',
  isLoading: false,
  error: null,
  validationResult: null,
  ouvertureValidation: null,
  transactionValidation: null,
  fermetureValidation: null,
};

export const useIntegriteDatesStore = create<IntegriteDatesStore>()((set, get) => ({
  ...initialState,

  setCheckType: (checkType) => {
    set({ checkType, error: null });
  },

  setSociete: (societe) => {
    set({ societe, error: null });
  },

  setError: (error) => {
    set({ error });
  },

  clearValidationResult: () => {
    set({
      validationResult: null,
      ouvertureValidation: null,
      transactionValidation: null,
      fermetureValidation: null,
      error: null,
    });
  },

  validateDateIntegrity: async (checkType, societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const mockResult = MOCK_VALIDATIONS[checkType];
      set({
        validationResult: mockResult,
        isLoading: false,
      });
      return mockResult;
    }

    try {
      const response = await apiClient.post<ApiResponse<DateIntegrityCheck>>(
        '/api/controles/integrite-dates',
        { checkType, societe },
      );

      const result = response.data.data;
      if (!result) {
        throw new Error('Réponse invalide du serveur');
      }

      set({ validationResult: result });
      return result;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation intégrité dates';
      set({ validationResult: null, error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  checkOuverture: async (societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const currentDate = new Date();
      const dateComptable = new Date(MOCK_DATE_COMPTABLE.dateComptable);
      const delai = MOCK_DATE_COMPTABLE.delaiJours;
      const dateLimit = new Date(dateComptable);
      dateLimit.setDate(dateLimit.getDate() + delai);

      const isValid = currentDate <= dateLimit;
      const validation: OuvertureValidation = {
        isValid,
        dateComptable: MOCK_DATE_COMPTABLE.dateComptable,
        currentDate: currentDate.toISOString().split('T')[0],
        delaiExceeded: currentDate > dateLimit,
      };

      set({
        ouvertureValidation: validation,
        isLoading: false,
      });
      return isValid;
    }

    try {
      const response = await apiClient.get<ApiResponse<DateComptable>>(
        '/api/controles/date-comptable',
        { params: { societe, checkType: 'O' } },
      );

      const data = response.data.data;
      if (!data) {
        throw new Error('Réponse invalide du serveur');
      }

      const currentDate = new Date();
      const dateComptable = new Date(data.dateComptable);
      const dateLimit = new Date(dateComptable);
      dateLimit.setDate(dateLimit.getDate() + data.delaiJours);

      const isValid = currentDate <= dateLimit && data.controleOk;
      const validation: OuvertureValidation = {
        isValid,
        dateComptable: data.dateComptable,
        currentDate: currentDate.toISOString().split('T')[0],
        delaiExceeded: currentDate > dateLimit,
      };

      set({ ouvertureValidation: validation });
      return isValid;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur contrôle ouverture';
      set({ ouvertureValidation: null, error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  checkTransaction: async (societe, dateSession, heureSession) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const currentTimestamp = Date.now();
      const sessionDate = new Date(dateSession);
      const [hours, minutes] = heureSession.split(':').map(Number);
      sessionDate.setHours(hours, minutes, 0, 0);
      const sessionTimestamp = sessionDate.getTime();

      const isValid = currentTimestamp >= sessionTimestamp;
      const validation: TransactionValidation = {
        isValid,
        dateSession,
        heureSession,
        currentTimestamp,
        sessionTimestamp,
        isTimestampValid: isValid,
      };

      set({
        transactionValidation: validation,
        isLoading: false,
      });
      return isValid;
    }

    try {
      const response = await apiClient.post<ApiResponse<DateIntegrityCheck>>(
        '/api/controles/integrite-dates',
        { checkType: 'T', societe, dateSession, heureSession },
      );

      const result = response.data.data;
      if (!result) {
        throw new Error('Réponse invalide du serveur');
      }

      const currentTimestamp = Date.now();
      const sessionDate = new Date(dateSession);
      const [hours, minutes] = heureSession.split(':').map(Number);
      sessionDate.setHours(hours, minutes, 0, 0);
      const sessionTimestamp = sessionDate.getTime();

      const validation: TransactionValidation = {
        isValid: result.isValid,
        dateSession,
        heureSession,
        currentTimestamp,
        sessionTimestamp,
        isTimestampValid: result.isValid,
      };

      set({ transactionValidation: validation });
      return result.isValid;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur contrôle transaction';
      set({ transactionValidation: null, error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  checkFermeture: async (societe) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const hasAnomaly = MOCK_VALIDATIONS.F.hasClosureAnomaly;
      const validation: FermetureValidation = {
        isValid: !hasAnomaly,
        hasAnomaly,
        blockedReason: hasAnomaly ? 'Anomalie de fermeture détectée' : undefined,
      };

      set({
        fermetureValidation: validation,
        isLoading: false,
      });
      return { isValid: !hasAnomaly, hasAnomaly };
    }

    try {
      const response = await apiClient.post<ApiResponse<DateIntegrityCheck>>(
        '/api/controles/integrite-dates',
        { checkType: 'F', societe },
      );

      const result = response.data.data;
      if (!result) {
        throw new Error('Réponse invalide du serveur');
      }

      const validation: FermetureValidation = {
        isValid: result.isValid && !result.hasClosureAnomaly,
        hasAnomaly: result.hasClosureAnomaly,
        blockedReason: result.hasClosureAnomaly ? result.errorMessage : undefined,
      };

      set({ fermetureValidation: validation });
      return { isValid: validation.isValid, hasAnomaly: result.hasClosureAnomaly };
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur contrôle fermeture';
      set({ fermetureValidation: null, error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  reset: () => set({ ...initialState }),
}));

TYPES:
// Integrite Dates types (IDE 286)

export type DateCheckType = 'O' | 'T' | 'F';

export interface DateIntegrityCheck {
  checkType: DateCheckType;
  societe: string;
  isValid: boolean;
  hasClosureAnomaly: boolean;
  errorMessage?: string;
  timestamp: string;
}

export interface DateComptable {
  checkType: DateCheckType;
  societe: string;
  controleOk: boolean;
  anomalieFermeture: boolean;
  dateComptable: string;
  delaiJours: number;
}

export interface OuvertureValidation {
  isValid: boolean;
  dateComptable: string;
  currentDate: string;
  delaiExceeded: boolean;
}

export interface TransactionValidation {
  isValid: boolean;
  dateSession: string;
  heureSession: string;
  currentTimestamp: number;
  sessionTimestamp: number;
  isTimestampValid: boolean;
}

export interface FermetureValidation {
  isValid: boolean;
  hasAnomaly: boolean;
  blockedReason?: string;
}

export interface DateCheckRequest {
  checkType: DateCheckType;
  societe: string;
  dateSession?: string;
  heureSession?: string;
}

export interface DateCheckResponse {
  success: boolean;
  data?: DateIntegrityCheck;
  error?: string;
}

export interface DateComptableResponse {
  success: boolean;
  data?: DateComptable;
  error?: string;
}

export interface IntegriteDatesState {
  checkType: DateCheckType;
  societe: string;
  isLoading: boolean;
  error: string | null;
  validationResult: DateIntegrityCheck | null;
  ouvertureValidation: OuvertureValidation | null;
  transactionValidation: TransactionValidation | null;
  fermetureValidation: FermetureValidation | null;
  
  setCheckType: (checkType: DateCheckType) => void;
  setSociete: (societe: string) => void;
  setError: (error: string | null) => void;
  clearValidationResult: () => void;
  
  validateDateIntegrity: (checkType: DateCheckType, societe: string) => Promise<DateIntegrityCheck>;
  checkOuverture: (societe: string) => Promise<boolean>;
  checkTransaction: (societe: string, dateSession: string, heureSession: string) => Promise<boolean>;
  checkFermeture: (societe: string) => Promise<{ isValid: boolean; hasAnomaly: boolean }>;
  reset: () => void;
}

export type ValidateOuvertureRequest = {
  checkType: 'O';
  societe: string;
};

export type ValidateTransactionRequest = {
  checkType: 'T';
  societe: string;
  dateSession: string;
  heureSession: string;
};

export type ValidateFermetureRequest = {
  checkType: 'F';
  societe: string;
};

export type DateCheckActionRequest =
  | ValidateOuvertureRequest
  | ValidateTransactionRequest
  | ValidateFermetureRequest;

export const DATE_CHECK_TYPES = {
  OUVERTURE: 'O' as const,
  TRANSACTION: 'T' as const,
  FERMETURE: 'F' as const,
} as const;

export const DATE_CHECK_LABELS = {
  O: 'Ouverture',
  T: 'Transaction',
  F: 'Fermeture',
} as const;

ACTIONS TO COVER:
[
  {
    "name": "validateDateIntegrity",
    "params": [
      "checkType: string",
      "societe: string"
    ],
    "businessRules": [
      "RM-001: Si checkType === 'O' (Ouverture), appliquer contrôles spécifiques ouverture",
      "RM-002: Vérifier que Date() > dateComptable + delai avec gestion VG3",
      "RM-003: Si Date() > dateComptable + delai ET NOT VG3, déclencher anomalie",
      "RM-004: Si checkType === 'T' (Transaction), appliquer contrôles transaction",
      "RM-005: Vérifier que Date()*10^5+Time() >= dateSession*10^5+heureSession",
      "RM-006: Si checkType === 'F' (Fermeture), appliquer contrôles fermeture",
      "RM-007: Si anomalie détectée (NOT L), bloquer l'opération"
    ],
    "returns": "Promise<DateIntegrityCheck>"
  },
  {
    "name": "checkOuverture",
    "params": [
      "societe: string"
    ],
    "businessRules": [
      "RM-001: Vérifier paramètre checkType === 'O'",
      "RM-002: Valider cohérence date ouverture avec date comptable",
      "RM-003: Appliquer règle Date() > dateComptable + delai"
    ],
    "returns": "Promise<boolean>"
  },
  {
    "name": "checkTransaction",
    "params": [
      "societe: string",
      "dateSession: Date",
      "heureSession: string"
    ],
    "businessRules": [
      "RM-004: Vérifier paramètre checkType === 'T'",
      "RM-005: Valider que timestamp actuel >= timestamp session"
    ],
    "returns": "Promise<boolean>"
  },
  {
    "name": "checkFermeture",
    "params": [
      "societe: string"
    ],
    "businessRules": [
      "RM-006: Vérifier paramètre checkType === 'F'",
      "RM-007: Détecter anomalies bloquantes pour fermeture"
    ],
    "returns": "Promise<{ isValid: boolean; hasAnomaly: boolean }>"
  }
]