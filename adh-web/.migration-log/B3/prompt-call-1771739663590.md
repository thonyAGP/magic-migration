Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
authenticationStore getMatricule should retrieve matricule from mock data when login exists: AssertionError: expected null to be 'MAT001' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:43:31
    at processTicksAndRejections (node:inter
authenticationStore getMatricule should return empty string when login not found in mock data: AssertionError: expected null to be '' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:53:31
    at processTicksAndRejections (node:internal/pr
authenticationStore getMatricule should set loading state during mock data retrieval: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:62:59
    at file:///D:/Projects/Lecteur_Magic/adh-we
authenticationStore getMatricule should retrieve matricule from API when real API is enabled: AssertionError: expected null to be 'MAT001' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:85:31
    at processTicksAndRejections (node:inter
authenticationStore getMatricule should handle API error and set error message: AssertionError: expected null to be '' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:101:31
    at processTicksAndRejections (node:internal/p
authenticationStore getMatricule should handle non-Error API failures with generic message: AssertionError: expected null to be '' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:116:31
    at processTicksAndRejections (node:internal/p
authenticationStore getMatricule should handle API response with missing matricule data: AssertionError: expected null to be '' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:135:31
    at processTicksAndRejections (node:internal/p
authenticationStore setMatricule should update matricule and clear error: AssertionError: expected null to be 'MAT001' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:156:31
    at file:///D:/Projects/Lecteur_Magic/ad
authenticationStore setError should update error state: AssertionError: expected null to be 'Test error' // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/authenticationStore.test.ts:177:27
    at file:///D:/Projects/Lecteur_Magi

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useAuthenticationStore } from '@/stores/authenticationStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import type { GetMatriculeResponse } from '@/types/authentication';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(() => ({
      isRealApi: false,
      setDataSource: vi.fn(),
    })),
  },
}));

const MOCK_LOGIN = 'jdupont';
const MOCK_MATRICULE = 'MAT001';
const UNKNOWN_LOGIN = 'unknown';

describe('authenticationStore', () => {
  beforeEach(() => {
    useAuthenticationStore.getState().reset();
    vi.clearAllMocks();
    vi.mocked(useDataSourceStore.getState).mockReturnValue({
      isRealApi: false,
      setDataSource: vi.fn(),
    });
  });

  describe('getMatricule', () => {
    it('should retrieve matricule from mock data when login exists', async () => {
      const store = useAuthenticationStore.getState();

      await store.getMatricule(MOCK_LOGIN);

      expect(store.matricule).toBe(MOCK_MATRICULE);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should return empty string when login not found in mock data', async () => {
      const store = useAuthenticationStore.getState();

      await store.getMatricule(UNKNOWN_LOGIN);

      expect(store.matricule).toBe('');
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should set loading state during mock data retrieval', async () => {
      const store = useAuthenticationStore.getState();

      const promise = store.getMatricule(MOCK_LOGIN);
      expect(useAuthenticationStore.getState().isLoading).toBe(true);

      await promise;
      expect(useAuthenticationStore.getState().isLoading).toBe(false);
    });

    it('should retrieve matricule from API when real API is enabled', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setDataSource: vi.fn(),
      });
      const mockResponse: ApiResponse<GetMatriculeResponse> = {
        data: { matricule: MOCK_MATRICULE },
        success: true,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const store = useAuthenticationStore.getState();
      await store.getMatricule(MOCK_LOGIN);

      expect(apiClient.get).toHaveBeenCalledWith('/api/authentication/matricule', {
        params: { login: MOCK_LOGIN },
      });
      expect(store.matricule).toBe(MOCK_MATRICULE);
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });

    it('should handle API error and set error message', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setDataSource: vi.fn(),
      });
      const errorMessage = 'Network error';
      vi.mocked(apiClient.get).mockRejectedValue(new Error(errorMessage));

      const store = useAuthenticationStore.getState();
      await store.getMatricule(MOCK_LOGIN);

      expect(store.matricule).toBe('');
      expect(store.error).toBe(errorMessage);
      expect(store.isLoading).toBe(false);
    });

    it('should handle non-Error API failures with generic message', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setDataSource: vi.fn(),
      });
      vi.mocked(apiClient.get).mockRejectedValue('Unknown failure');

      const store = useAuthenticationStore.getState();
      await store.getMatricule(MOCK_LOGIN);

      expect(store.matricule).toBe('');
      expect(store.error).toBe('Erreur récupération matricule');
      expect(store.isLoading).toBe(false);
    });

    it('should handle API response with missing matricule data', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({
        isRealApi: true,
        setDataSource: vi.fn(),
      });
      const mockResponse: ApiResponse<GetMatriculeResponse> = {
        data: undefined,
        success: false,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const store = useAuthenticationStore.getState();
      await store.getMatricule(MOCK_LOGIN);

      expect(store.matricule).toBe('');
      expect(store.isLoading).toBe(false);
    });

    it('should clear previous error on successful retrieval', async () => {
      const store = useAuthenticationStore.getState();
      store.setError('Previous error');

      await store.getMatricule(MOCK_LOGIN);

      expect(store.error).toBeNull();
    });
  });

  describe('setMatricule', () => {
    it('should update matricule and clear error', () => {
      const store = useAuthenticationStore.getState();
      store.setError('Previous error');

      store.setMatricule(MOCK_MATRICULE);

      expect(store.matricule).toBe(MOCK_MATRICULE);
      expect(store.error).toBeNull();
    });

    it('should allow setting null matricule', () => {
      const store = useAuthenticationStore.getState();
      store.setMatricule(MOCK_MATRICULE);

      store.setMatricule(null);

      expect(store.matricule).toBeNull();
    });
  });

  describe('setError', () => {
    it('should update error state', () => {
      const store = useAuthenticationStore.getState();
      const errorMessage = 'Test error';

      store.setError(errorMessage);

      expect(store.error).toBe(errorMessage);
    });

    it('should allow clearing error by setting null', () => {
      const store = useAuthenticationStore.getState();
      store.setError('Test error');

      store.setError(null);

      expect(store.error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      const store = useAuthenticationStore.getState();
      store.setMatricule(MOCK_MATRICULE);
      store.setError('Test error');

      store.reset();

      expect(store.matricule).toBeNull();
      expect(store.isLoading).toBe(false);
      expect(store.error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  GetMatriculeRequest,
  GetMatriculeResponse,
  AuthenticationStore,
} from '@/types/authentication';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

const MOCK_CREDENTIALS = [
  { login: 'jdupont', matricule: 'MAT001' },
  { login: 'smartin', matricule: 'MAT002' },
  { login: 'pdurand', matricule: 'MAT003' },
  { login: 'mleblanc', matricule: 'MAT004' },
  { login: 'arobert', matricule: 'MAT005' },
];

const initialState = {
  matricule: null,
  isLoading: false,
  error: null,
};

export const useAuthenticationStore = create<AuthenticationStore>()((set) => ({
  ...initialState,

  getMatricule: async (login: string) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const found = MOCK_CREDENTIALS.find((c) => c.login === login);
      set({
        matricule: found?.matricule ?? '',
        isLoading: false,
      });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<GetMatriculeResponse>>(
        '/api/authentication/matricule',
        { params: { login } },
      );
      set({ matricule: response.data.data?.matricule ?? '' });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur récupération matricule';
      set({ matricule: '', error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  setMatricule: (matricule) => {
    set({ matricule, error: null });
  },

  setError: (error) => {
    set({ error });
  },

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.