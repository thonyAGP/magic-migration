Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/sessionConcurrencyStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
sessionConcurrencyStore checkConcurrency should detect conflict in mock mode: AssertionError: expected true to be false // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/sessionConcurrencyStore.test.ts:65:30
    at processTicksAndRejections (node:inte
sessionConcurrencyStore checkConcurrency should set loading state during check: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/sessionConcurrencyStore.test.ts:135:65
    at Timeout.checkCallback (file:///D:/P

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useSessionConcurrencyStore } from '@/stores/sessionConcurrencyStore';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type {
  SessionConcurrency,
  SessionConflictResult,
} from '@/types/sessionConcurrency';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(),
  },
}));

const MOCK_SESSION: SessionConcurrency = {
  societe: 'SOC1',
  compte: 1001,
  filiation: 0,
  terminalId: 'TERM01',
  timestamp: new Date('2026-02-21T08:30:00'),
  codeCalcul: 'C',
  coffreEnCoursComptage: false,
};

const MOCK_CONFLICT_RESULT: SessionConflictResult = {
  allowed: false,
  conflictingSession: MOCK_SESSION,
  reason: 'Session déjà ouverte sur terminal TERM01 depuis 08:30:00',
};

const _MOCK_NO_CONFLICT_RESULT: SessionConflictResult = {
  allowed: true,
};

describe('sessionConcurrencyStore', () => {
  beforeEach(() => {
    useSessionConcurrencyStore.setState({
      activeSessions: [],
      isLoading: false,
      error: null,
      conflictDetected: false,
      conflictingSession: null,
    });
    vi.clearAllMocks();
  });

  describe('checkConcurrency', () => {
    it('should detect conflict in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false });

      const result = await useSessionConcurrencyStore
        .getState()
        .checkConcurrency('SOC1', 1001, 0);

      const state = useSessionConcurrencyStore.getState();

      expect(result.allowed).toBe(false);
      expect(result.conflictingSession).toBeDefined();
      expect(result.reason).toContain('TERM01');
      expect(state.conflictDetected).toBe(true);
      expect(state.conflictingSession).toBeDefined();
      expect(state.isLoading).toBe(false);
    });

    it('should allow session when no conflict in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false });

      const result = await useSessionConcurrencyStore
        .getState()
        .checkConcurrency('SOC1', 9999, 0);

      const state = useSessionConcurrencyStore.getState();

      expect(result.allowed).toBe(true);
      expect(result.conflictingSession).toBeUndefined();
      expect(state.conflictDetected).toBe(false);
      expect(state.conflictingSession).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should call API in real mode with success', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValue({
        data: { data: MOCK_CONFLICT_RESULT },
      });

      const result = await useSessionConcurrencyStore
        .getState()
        .checkConcurrency('SOC1', 1001, 0);

      const state = useSessionConcurrencyStore.getState();

      expect(apiClient.get).toHaveBeenCalledWith(
        '/api/caisse/sessions/concurrent',
        {
          params: { societe: 'SOC1', compte: 1001, filiation: 0 },
        },
      );
      expect(result.allowed).toBe(false);
      expect(state.conflictDetected).toBe(true);
      expect(state.isLoading).toBe(false);
    });

    it('should handle API error in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true });
      const error = new Error('Network error');
      vi.mocked(apiClient.get).mockRejectedValue(error);

      await expect(
        useSessionConcurrencyStore.getState().checkConcurrency('SOC1', 1001, 0),
      ).rejects.toThrow('Network error');

      const state = useSessionConcurrencyStore.getState();
      expect(state.error).toBe('Network error');
      expect(state.conflictDetected).toBe(false);
      expect(state.isLoading).toBe(false);
    });

    it('should set loading state during check', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false });

      const promise = useSessionConcurrencyStore
        .getState()
        .checkConcurrency('SOC1', 1001, 0);

      await vi.waitFor(() => {
        expect(useSessionConcurrencyStore.getState().isLoading).toBe(true);
      });

      await promise;

      expect(useSessionConcurrencyStore.getState().isLoading).toBe(false);
    });
  });

  describe('registerSession', () => {
    it('should register session in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false });

      await useSessionConcurrencyStore
        .getState()
        .registerSession('SOC1', 1001, 0, 'TERM01', 'C');

      const state = useSessionConcurrencyStore.getState();

      expect(state.activeSessions).toHaveLength(1);
      expect(state.activeSessions[0].societe).toBe('SOC1');
      expect(state.activeSessions[0].compte).toBe(1001);
      expect(state.activeSessions[0].terminalId).toBe('TERM01');
      expect(state.activeSessions[0].codeCalcul).toBe('C');
      expect(state.activeSessions[0].coffreEnCoursComptage).toBe(true);
      expect(state.isLoading).toBe(false);
    });

    it('should set coffreEnCoursComptage to false when codeCalcul is not C', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false });

      await useSessionConcurrencyStore
        .getState()
        .registerSession('SOC1', 1001, 0, 'TERM01', 'D');

      const state = useSessionConcurrencyStore.getState();

      expect(state.activeSessions[0].coffreEnCoursComptage).toBe(false);
    });

    it('should call API in real mode with success', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValue({
        data: { data: { success: true } },
      });

      await useSessionConcurrencyStore
        .getState()
        .registerSession('SOC1', 1001, 0, 'TERM01', 'C');

      expect(apiClient.post).toHaveBeenCalledWith('/api/caisse/sessions/register', {
        societe: 'SOC1',
        compte: 1001,
        filiation: 0,
        terminalId: 'TERM01',
        codeCalcul: 'C',
      });

      const state = useSessionConcurrencyStore.getState();
      expect(state.activeSessions).toHaveLength(1);
      expect(state.isLoading).toBe(false);
    });

    it('should handle API error in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true });
      const error = new Error('Registration failed');
      vi.mocked(apiClient.post).mockRejectedValue(error);

      await expect(
        useSessionConcurrencyStore
          .getState()
          .registerSession('SOC1', 1001, 0, 'TERM01', 'C'),
      ).rejects.toThrow('Registration failed');

      const state = useSessionConcurrencyStore.getState();
      expect(state.error).toBe('Registration failed');
      expect(state.isLoading).toBe(false);
    });
  });

  describe('releaseSession', () => {
    beforeEach(() => {
      useSessionConcurrencyStore.setState({
        activeSessions: [MOCK_SESSION],
      });
    });

    it('should release session in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false });

      await useSessionConcurrencyStore
        .getState()
        .releaseSession('SOC1', 1001, 0, 'TERM01');

      const state = useSessionConcurrencyStore.getState();

      expect(state.activeSessions).toHaveLength(0);
      expect(state.isLoading).toBe(false);
    });

    it('should not remove other sessions in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false });

      const otherSession: SessionConcurrency = {
        ...MOCK_SESSION,
        compte: 1002,
        terminalId: 'TERM02',
      };

      useSessionConcurrencyStore.setState({
        activeSessions: [MOCK_SESSION, otherSession],
      });

      await useSessionConcurrencyStore
        .getState()
        .releaseSession('SOC1', 1001, 0, 'TERM01');

      const state = useSessionConcurrencyStore.getState();

      expect(state.activeSessions).toHaveLength(1);
      expect(state.activeSessions[0].compte).toBe(1002);
    });

    it('should call API in real mode with success', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValue({
        data: { data: { success: true } },
      });

      await useSessionConcurrencyStore
        .getState()
        .releaseSession('SOC1', 1001, 0, 'TERM01');

      expect(apiClient.post).toHaveBeenCalledWith('/api/caisse/sessions/release', {
        societe: 'SOC1',
        compte: 1001,
        filiation: 0,
        terminalId: 'TERM01',
      });

      const state = useSessionConcurrencyStore.getState();
      expect(state.activeSessions).toHaveLength(0);
      expect(state.isLoading).toBe(false);
    });

    it('should handle API error in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true });
      const error = new Error('Release failed');
      vi.mocked(apiClient.post).mockRejectedValue(error);

      await expect(
        useSessionConcurrencyStore
          .getState()
          .releaseSession('SOC1', 1001, 0, 'TERM01'),
      ).rejects.toThrow('Release failed');

      const state = useSessionConcurrencyStore.getState();
      expect(state.error).toBe('Release failed');
      expect(state.isLoading).toBe(false);
    });
  });

  describe('forceOpenSession', () => {
    beforeEach(() => {
      useSessionConcurrencyStore.setState({
        conflictDetected: true,
        conflictingSession: MOCK_SESSION,
      });
    });

    it('should clear conflict and remove conflicting session in mock mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false });

      useSessionConcurrencyStore.setState({
        activeSessions: [MOCK_SESSION],
      });

      await useSessionConcurrencyStore
        .getState()
        .forceOpenSession('SOC1', 1001, 0, 'TERM02', 'Override needed');

      const state = useSessionConcurrencyStore.getState();

      expect(state.activeSessions).toHaveLength(0);
      expect(state.conflictDetected).toBe(false);
      expect(state.conflictingSession).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should call API in real mode with success', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true });
      vi.mocked(apiClient.post).mockResolvedValue({
        data: { data: { success: true } },
      });

      await useSessionConcurrencyStore
        .getState()
        .forceOpenSession('SOC1', 1001, 0, 'TERM02', 'Override needed');

      expect(apiClient.post).toHaveBeenCalledWith(
        '/api/caisse/sessions/force-open',
        {
          societe: 'SOC1',
          compte: 1001,
          filiation: 0,
          terminalId: 'TERM02',
          reason: 'Override needed',
        },
      );

      const state = useSessionConcurrencyStore.getState();
      expect(state.conflictDetected).toBe(false);
      expect(state.conflictingSession).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should handle API error in real mode', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true });
      const error = new Error('Force open failed');
      vi.mocked(apiClient.post).mockRejectedValue(error);

      await expect(
        useSessionConcurrencyStore
          .getState()
          .forceOpenSession('SOC1', 1001, 0, 'TERM02', 'Override needed'),
      ).rejects.toThrow('Force open failed');

      const state = useSessionConcurrencyStore.getState();
      expect(state.error).toBe('Force open failed');
      expect(state.isLoading).toBe(false);
    });
  });

  describe('setError', () => {
    it('should set error message', () => {
      useSessionConcurrencyStore.getState().setError('Test error');

      expect(useSessionConcurrencyStore.getState().error).toBe('Test error');
    });

    it('should clear error when null', () => {
      useSessionConcurrencyStore.setState({ error: 'Previous error' });

      useSessionConcurrencyStore.getState().setError(null);

      expect(useSessionConcurrencyStore.getState().error).toBeNull();
    });
  });

  describe('clearConflict', () => {
    it('should clear conflict state and error', () => {
      useSessionConcurrencyStore.setState({
        conflictDetected: true,
        conflictingSession: MOCK_SESSION,
        error: 'Some error',
      });

      useSessionConcurrencyStore.getState().clearConflict();

      const state = useSessionConcurrencyStore.getState();
      expect(state.conflictDetected).toBe(false);
      expect(state.conflictingSession).toBeNull();
      expect(state.error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset store to initial state', () => {
      useSessionConcurrencyStore.setState({
        activeSessions: [MOCK_SESSION],
        isLoading: true,
        error: 'Some error',
        conflictDetected: true,
        conflictingSession: MOCK_SESSION,
      });

      useSessionConcurrencyStore.getState().reset();

      const state = useSessionConcurrencyStore.getState();
      expect(state.activeSessions).toEqual([]);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.conflictDetected).toBe(false);
      expect(state.conflictingSession).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  SessionConcurrency,
  SessionConflictResult,
  SessionConcurrencyCodeCalcul,
} from '@/types/sessionConcurrency';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface SessionConcurrencyState {
  activeSessions: SessionConcurrency[];
  isLoading: boolean;
  error: string | null;
  conflictDetected: boolean;
  conflictingSession: SessionConcurrency | null;
}

interface SessionConcurrencyActions {
  checkConcurrency: (
    societe: string,
    compte: number,
    filiation: number,
  ) => Promise<SessionConflictResult>;
  registerSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
    codeCalcul: SessionConcurrencyCodeCalcul,
  ) => Promise<void>;
  releaseSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
  ) => Promise<void>;
  forceOpenSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
    reason: string,
  ) => Promise<void>;
  setError: (error: string | null) => void;
  clearConflict: () => void;
  reset: () => void;
}

type SessionConcurrencyStore = SessionConcurrencyState & SessionConcurrencyActions;

const MOCK_SESSIONS: SessionConcurrency[] = [
  {
    societe: 'SOC1',
    compte: 1001,
    filiation: 0,
    terminalId: 'TERM01',
    timestamp: new Date('2026-02-21T08:30:00'),
    codeCalcul: 'C',
    coffreEnCoursComptage: false,
  },
  {
    societe: 'SOC1',
    compte: 1002,
    filiation: 0,
    terminalId: 'TERM02',
    timestamp: new Date('2026-02-21T09:15:00'),
    codeCalcul: 'D',
    coffreEnCoursComptage: true,
  },
];

const initialState: SessionConcurrencyState = {
  activeSessions: [],
  isLoading: false,
  error: null,
  conflictDetected: false,
  conflictingSession: null,
};

export const useSessionConcurrencyStore = create<SessionConcurrencyStore>()((set) => ({
  ...initialState,

  checkConcurrency: async (societe, compte, filiation) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const conflictingSession = MOCK_SESSIONS.find(
        (s) =>
          s.societe === societe &&
          s.compte === compte &&
          s.filiation === filiation &&
          s.timestamp >= today,
      );

      const result: SessionConflictResult = {
        allowed: !conflictingSession,
        conflictingSession,
        reason: conflictingSession
          ? `Session déjà ouverte sur terminal ${conflictingSession.terminalId} depuis ${conflictingSession.timestamp.toLocaleTimeString()}`
          : undefined,
      };

      set({
        conflictDetected: !result.allowed,
        conflictingSession: conflictingSession ?? null,
        isLoading: false,
      });

      return result;
    }

    try {
      const response = await apiClient.get<ApiResponse<SessionConflictResult>>(
        '/api/caisse/sessions/concurrent',
        {
          params: { societe, compte, filiation },
        },
      );

      const result = response.data.data;
      set({
        conflictDetected: !result.allowed,
        conflictingSession: result.conflictingSession ?? null,
      });

      return result;
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur vérification concurrence';
      set({ error: message, conflictDetected: false, conflictingSession: null });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  registerSession: async (societe, compte, filiation, terminalId, codeCalcul) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const newSession: SessionConcurrency = {
        societe,
        compte,
        filiation,
        terminalId,
        timestamp: new Date(),
        codeCalcul,
        coffreEnCoursComptage: codeCalcul === 'C',
      };

      set((state) => ({
        activeSessions: [...state.activeSessions, newSession],
        isLoading: false,
      }));
      return;
    }

    try {
      await apiClient.post('/api/caisse/sessions/register', {
        societe,
        compte,
        filiation,
        terminalId,
        codeCalcul,
      });

      set((state) => ({
        activeSessions: [
          ...state.activeSessions,
          {
            societe,
            compte,
            filiation,
            terminalId,
            timestamp: new Date(),
            codeCalcul,
            coffreEnCoursComptage: codeCalcul === 'C',
          },
        ],
      }));
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur enregistrement session';
      set({ error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  releaseSession: async (societe, compte, filiation, terminalId) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set((state) => ({
        activeSessions: state.activeSessions.filter(
          (s) =>
            !(
              s.societe === societe &&
              s.compte === compte &&
              s.filiation === filiation &&
              s.terminalId === terminalId
            ),
        ),
        isLoading: false,
      }));
      return;
    }

    try {
      await apiClient.post('/api/caisse/sessions/release', {
        societe,
        compte,
        filiation,
        terminalId,
      });

      set((state) => ({
        activeSessions: state.activeSessions.filter(
          (s) =>
            !(
              s.societe === societe &&
              s.compte === compte &&
              s.filiation === filiation &&
              s.terminalId === terminalId
            ),
        ),
      }));
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur libération session';
      set({ error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  forceOpenSession: async (societe, compte, filiation, terminalId, reason) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set((state) => ({
        activeSessions: state.activeSessions.filter(
          (s) =>
            !(
              s.societe === societe &&
              s.compte === compte &&
              s.filiation === filiation
            ),
        ),
        conflictDetected: false,
        conflictingSession: null,
        isLoading: false,
      }));
      return;
    }

    try {
      await apiClient.post('/api/caisse/sessions/force-open', {
        societe,
        compte,
        filiation,
        terminalId,
        reason,
      });

      set({
        conflictDetected: false,
        conflictingSession: null,
      });
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur ouverture forcée session';
      set({ error: message });
      throw e;
    } finally {
      set({ isLoading: false });
    }
  },

  setError: (error) => set({ error }),

  clearConflict: () =>
    set({ conflictDetected: false, conflictingSession: null, error: null }),

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.