Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/sessionTimestampStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
sessionTimestampStore getSessionTimestamp should guarantee timestamp calculation coherence (date*10^5 + time): AssertionError: expected 20260221091500 to be 2026022191500 // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/sessionTimestampStore.test.ts:129:31
    at processTicksAndReje

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useSessionTimestampStore } from '@/stores/sessionTimestampStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import type {
  GetSessionTimestampResponse,
  ValidateTimestampResponse,
} from '@/types/sessionTimestamp';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

const MOCK_TIMESTAMP_RESPONSE: GetSessionTimestampResponse = {
  sessionDate: new Date('2026-02-21T09:15:00'),
  sessionTime: '09:15',
  timestamp: 20260221091500,
};

const MOCK_VALIDATE_RESPONSE: ValidateTimestampResponse = {
  isValid: true,
  message: 'Timestamp valide',
};

describe('sessionTimestampStore', () => {
  beforeEach(() => {
    useSessionTimestampStore.setState({
      sessionDate: null,
      sessionTime: '',
      timestamp: 0,
      isLoading: false,
      error: null,
    });
    useDataSourceStore.setState({ isRealApi: false });
    vi.clearAllMocks();
  });

  describe('getSessionTimestamp', () => {
    it('should load session timestamp from mock data when isRealApi is false', async () => {
      useDataSourceStore.setState({ isRealApi: false });

      await useSessionTimestampStore.getState().getSessionTimestamp();

      const state = useSessionTimestampStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.sessionTime).toBe('09:15');
      expect(state.timestamp).toBe(20260221091500);
      expect(state.sessionDate).toBeInstanceOf(Date);
    });

    it('should set loading state during API call', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockImplementation(
        () =>
          new Promise((resolve) => {
            const currentState = useSessionTimestampStore.getState();
            expect(currentState.isLoading).toBe(true);
            resolve({
              data: MOCK_TIMESTAMP_RESPONSE,
              success: true,
              message: 'OK',
            } as ApiResponse<GetSessionTimestampResponse>);
          }),
      );

      await useSessionTimestampStore.getState().getSessionTimestamp();

      expect(useSessionTimestampStore.getState().isLoading).toBe(false);
    });

    it('should load session timestamp from API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockResolvedValue({
        data: MOCK_TIMESTAMP_RESPONSE,
        success: true,
        message: 'OK',
      } as ApiResponse<GetSessionTimestampResponse>);

      await useSessionTimestampStore.getState().getSessionTimestamp();

      const state = useSessionTimestampStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.sessionTime).toBe('09:15');
      expect(state.timestamp).toBe(20260221091500);
      expect(state.sessionDate).toBeInstanceOf(Date);
      expect(apiClient.get).toHaveBeenCalledWith('/api/session/timestamp');
    });

    it('should handle API error with Error instance', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const errorMessage = 'Network error';
      vi.mocked(apiClient.get).mockRejectedValue(new Error(errorMessage));

      await useSessionTimestampStore.getState().getSessionTimestamp();

      const state = useSessionTimestampStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBe(errorMessage);
      expect(state.sessionDate).toBeNull();
      expect(state.timestamp).toBe(0);
    });

    it('should handle API error with unknown error type', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValue('Unknown error');

      await useSessionTimestampStore.getState().getSessionTimestamp();

      const state = useSessionTimestampStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBe('Erreur récupération timestamp session');
    });

    it('should guarantee timestamp calculation coherence (date*10^5 + time)', async () => {
      useDataSourceStore.setState({ isRealApi: false });

      await useSessionTimestampStore.getState().getSessionTimestamp();

      const state = useSessionTimestampStore.getState();
      const expectedDate = 20260221;
      const expectedTime = 91500;
      const expectedTimestamp = expectedDate * 100000 + expectedTime;
      expect(state.timestamp).toBe(expectedTimestamp);
    });
  });

  describe('validateTimestamp', () => {
    it('should validate timestamp within 1440 minutes (24h) in mock mode', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const mockTimestamp = 20260221091500;
      const validTimestamp = mockTimestamp + 10000;

      const result = await useSessionTimestampStore.getState().validateTimestamp(validTimestamp);

      expect(result).toBe(true);
    });

    it('should reject timestamp outside 1440 minutes in mock mode', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const mockTimestamp = 20260221091500;
      const invalidTimestamp = mockTimestamp + 200000;

      const result = await useSessionTimestampStore.getState().validateTimestamp(invalidTimestamp);

      expect(result).toBe(false);
    });

    it('should validate timestamp via API when isRealApi is true', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const timestamp = 20260221091500;
      vi.mocked(apiClient.post).mockResolvedValue({
        data: MOCK_VALIDATE_RESPONSE,
        success: true,
        message: 'OK',
      } as ApiResponse<ValidateTimestampResponse>);

      const result = await useSessionTimestampStore.getState().validateTimestamp(timestamp);

      expect(result).toBe(true);
      expect(apiClient.post).toHaveBeenCalledWith('/api/session/validate-timestamp', {
        timestamp,
      });
    });

    it('should return false and set error on API validation failure', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const timestamp = 20260221091500;
      vi.mocked(apiClient.post).mockRejectedValue(new Error('Validation failed'));

      const result = await useSessionTimestampStore.getState().validateTimestamp(timestamp);

      expect(result).toBe(false);
      expect(useSessionTimestampStore.getState().error).toBe('Validation failed');
    });

    it('should return false and set generic error on unknown validation error', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const timestamp = 20260221091500;
      vi.mocked(apiClient.post).mockRejectedValue('Unknown error');

      const result = await useSessionTimestampStore.getState().validateTimestamp(timestamp);

      expect(result).toBe(false);
      expect(useSessionTimestampStore.getState().error).toBe('Erreur validation timestamp');
    });

    it('should ensure timestamp coherence with active caisse sessions', async () => {
      useDataSourceStore.setState({ isRealApi: false });
      const currentTimestamp = 20260221091500;
      const validTimestamp = 20260221101500;
      const diffMinutes = Math.abs(validTimestamp - currentTimestamp) / 100;

      const result = await useSessionTimestampStore.getState().validateTimestamp(validTimestamp);

      expect(diffMinutes).toBeLessThanOrEqual(1440);
      expect(result).toBe(true);
    });
  });

  describe('resetState', () => {
    it('should reset store to initial state', () => {
      useSessionTimestampStore.setState({
        sessionDate: new Date(),
        sessionTime: '10:30',
        timestamp: 20260221103000,
        isLoading: true,
        error: 'Some error',
      });

      useSessionTimestampStore.getState().resetState();

      const state = useSessionTimestampStore.getState();
      expect(state.sessionDate).toBeNull();
      expect(state.sessionTime).toBe('');
      expect(state.timestamp).toBe(0);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  SessionTimestamp,
  SessionInfo,
  GetSessionTimestampResponse,
  ValidateTimestampResponse,
} from '@/types/sessionTimestamp';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface SessionTimestampState {
  sessionDate: Date | null;
  sessionTime: string;
  timestamp: number;
  isLoading: boolean;
  error: string | null;
}

interface SessionTimestampActions {
  getSessionTimestamp: () => Promise<void>;
  validateTimestamp: (timestamp: number) => Promise<boolean>;
  resetState: () => void;
}

type SessionTimestampStore = SessionTimestampState & SessionTimestampActions;

const MOCK_SESSION_TIMESTAMP: SessionTimestamp = {
  sessionDate: new Date('2026-02-21T09:15:00'),
  sessionTime: '09:15',
  timestamp: 20260221091500,
};

const _MOCK_SESSION_INFO: SessionInfo = {
  sessionDate: new Date('2026-02-21T09:15:00'),
  sessionTime: '09:15',
  timestamp: 20260221091500,
  sessionId: 'SES-2026-02-21-001',
  operatorId: 'OPR-123',
  isActive: true,
};

const initialState: SessionTimestampState = {
  sessionDate: null,
  sessionTime: '',
  timestamp: 0,
  isLoading: false,
  error: null,
};

export const useSessionTimestampStore = create<SessionTimestampStore>()((set) => ({
  ...initialState,

  getSessionTimestamp: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({
        sessionDate: MOCK_SESSION_TIMESTAMP.sessionDate,
        sessionTime: MOCK_SESSION_TIMESTAMP.sessionTime,
        timestamp: MOCK_SESSION_TIMESTAMP.timestamp,
        isLoading: false,
      });
      return;
    }

    try {
      const response: ApiResponse<GetSessionTimestampResponse> = await apiClient.get(
        '/api/session/timestamp',
      );
      const data = response.data;
      set({
        sessionDate: new Date(data.sessionDate),
        sessionTime: data.sessionTime,
        timestamp: data.timestamp,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur récupération timestamp session';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  validateTimestamp: async (timestamp: number) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      const currentTimestamp = MOCK_SESSION_TIMESTAMP.timestamp;
      const diffMinutes = Math.abs(timestamp - currentTimestamp) / 100;
      return diffMinutes <= 1440;
    }

    try {
      const response: ApiResponse<ValidateTimestampResponse> = await apiClient.post(
        '/api/session/validate-timestamp',
        { timestamp },
      );
      return response.data.isValid;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation timestamp';
      set({ error: message });
      return false;
    }
  },

  resetState: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.