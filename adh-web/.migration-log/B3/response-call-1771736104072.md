```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useFacturationAppelStore } from '@/stores/facturationAppelStore';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type {
  HistoriqueAppel,
  FacturationRequest,
  GetHistoriqueAppelsResponse,
  GetCoefficientResponse,
  FacturerAppelResponse,
  GetClotureStatusResponse,
  DebloquerClotureResponse,
  MarquerGratuitResponse,
  AnnulerFacturationResponse,
} from '@/types/facturationAppel';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
  },
}));

vi.mock('@/stores/dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(() => ({ isRealApi: false })),
  },
}));

const MOCK_APPEL_1: HistoriqueAppel = {
  id: 1,
  societe: 'SOC1',
  prefixe: 'CAI01',
  dateAppel: new Date('2026-02-20T09:15:00'),
  heureAppel: '09:15:23',
  numeroTel: '+33612345678',
  duree: '00:12:35',
  montant: 1.89,
  qualite: 'OK',
  gratuite: false,
  raisonGratuite: null,
  facture: false,
};

const MOCK_APPEL_2: HistoriqueAppel = {
  id: 2,
  societe: 'SOC1',
  prefixe: 'CAI01',
  dateAppel: new Date('2026-02-19T14:22:00'),
  heureAppel: '14:22:11',
  numeroTel: '+34912567890',
  duree: '00:05:18',
  montant: 0.8,
  qualite: 'OK',
  gratuite: false,
  raisonGratuite: null,
  facture: true,
  operationId: 10234,
};

const MOCK_APPEL_3: HistoriqueAppel = {
  id: 3,
  societe: 'SOC1',
  prefixe: 'CAI02',
  dateAppel: new Date('2026-02-18T16:30:00'),
  heureAppel: '16:30:05',
  numeroTel: '+33145678901',
  duree: '00:02:15',
  montant: 0.34,
  qualite: 'OK',
  gratuite: true,
  raisonGratuite: 'Appel urgence medicale',
  facture: false,
};

const MOCK_APPEL_GRATUIT: HistoriqueAppel = {
  id: 4,
  societe: 'SOC1',
  prefixe: 'CAI01',
  dateAppel: new Date('2026-02-17T10:12:00'),
  heureAppel: '10:12:33',
  numeroTel: '+447890123456',
  duree: '00:18:42',
  montant: 2.81,
  qualite: 'OK',
  gratuite: true,
  raisonGratuite: 'Test gratuit',
  facture: false,
};

describe('facturationAppelStore', () => {
  beforeEach(() => {
    useFacturationAppelStore.getState().reset();
    vi.clearAllMocks();
    vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: false } as never);
  });

  describe('chargerHistoriqueAppels', () => {
    it('should load and filter mock historique when isRealApi is false', async () => {
      const store = useFacturationAppelStore.getState();

      await store.chargerHistoriqueAppels('SOC1', 'CAI01');

      const state = useFacturationAppelStore.getState();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
      expect(state.historiqueAppels.length).toBeGreaterThan(0);
      expect(state.historiqueAppels.every((a) => a.societe === 'SOC1')).toBe(true);
      expect(state.historiqueAppels.every((a) => a.prefixe === 'CAI01')).toBe(true);
    });

    it('should filter by date range in mock mode', async () => {
      const store = useFacturationAppelStore.getState();
      const dateDebut = new Date('2026-02-19T00:00:00');
      const dateFin = new Date('2026-02-20T23:59:59');

      await store.chargerHistoriqueAppels('SOC1', 'CAI01', dateDebut, dateFin);

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels.every((a) => a.dateAppel >= dateDebut)).toBe(true);
      expect(state.historiqueAppels.every((a) => a.dateAppel <= dateFin)).toBe(true);
    });

    it('should sort historique by date and time descending', async () => {
      const store = useFacturationAppelStore.getState();

      await store.chargerHistoriqueAppels('SOC1', 'CAI01');

      const state = useFacturationAppelStore.getState();
      for (let i = 1; i < state.historiqueAppels.length; i++) {
        const prev = state.historiqueAppels[i - 1];
        const curr = state.historiqueAppels[i];
        const prevTime = prev.dateAppel.getTime();
        const currTime = curr.dateAppel.getTime();
        
        if (prevTime === currTime) {
          expect(prev.heureAppel >= curr.heureAppel).toBe(true);
        } else {
          expect(prevTime >= currTime).toBe(true);
        }
      }
    });

    it('should call API and load historique when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { success: true, data: [MOCK_APPEL_1, MOCK_APPEL_2] },
      } as GetHistoriqueAppelsResponse);

      const store = useFacturationAppelStore.getState();
      await store.chargerHistoriqueAppels('SOC1', 'CAI01');

      const state = useFacturationAppelStore.getState();
      expect(apiClient.get).toHaveBeenCalledWith(
        expect.stringContaining('/api/facturation-appel/historique?societe=SOC1&prefixe=CAI01')
      );
      expect(state.historiqueAppels).toHaveLength(2);
      expect(state.error).toBeNull();
    });

    it('should handle API error', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Network error'));

      const store = useFacturationAppelStore.getState();
      await store.chargerHistoriqueAppels('SOC1', 'CAI01');

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels).toHaveLength(0);
      expect(state.error).toBe('Network error');
      expect(state.isLoading).toBe(false);
    });
  });

  describe('recupererCoefficient', () => {
    it('should load mock coefficient when isRealApi is false', async () => {
      const store = useFacturationAppelStore.getState();

      await store.recupererCoefficient();

      const state = useFacturationAppelStore.getState();
      expect(state.coefficientTelephone).toBe(0.15);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should call API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { success: true, data: { coefficient: 0.15 } },
      } as GetCoefficientResponse);

      const store = useFacturationAppelStore.getState();
      await store.recupererCoefficient();

      const state = useFacturationAppelStore.getState();
      expect(apiClient.get).toHaveBeenCalledWith('/api/facturation-appel/coefficient');
      expect(state.coefficientTelephone).toBe(0.15);
    });

    it('should handle API error', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Coefficient not found'));

      const store = useFacturationAppelStore.getState();
      await store.recupererCoefficient();

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Coefficient not found');
      expect(state.coefficientTelephone).toBeNull();
    });
  });

  describe('facturerAppel', () => {
    it('should reject facturation for gratuite appel', async () => {
      const store = useFacturationAppelStore.getState();
      const request: FacturationRequest = {
        appel: MOCK_APPEL_GRATUIT,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Appel gratuit - facturation non autorisée');
      expect(state.isLoading).toBe(false);
    });

    it('should mark appel as facture in mock mode', async () => {
      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1];
      store.cloture = { cloture_enCours: false, testReseau: 'OK' };

      const request: FacturationRequest = {
        appel: MOCK_APPEL_1,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels[0].facture).toBe(true);
      expect(state.historiqueAppels[0].operationId).toBeDefined();
    });

    it('should check cloture before facturation', async () => {
      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1];
      store.cloture = { cloture_enCours: true, testReseau: 'OK' };

      const request: FacturationRequest = {
        appel: MOCK_APPEL_1,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Opération bloquée - clôture en cours');
      expect(state.historiqueAppels[0].facture).toBe(false);
    });

    it('should call API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { success: true, data: { cloture_enCours: false, testReseau: 'OK' } },
      } as GetClotureStatusResponse);
      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: { success: true, data: { success: true, operationId: 99999 } },
      } as FacturerAppelResponse);

      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1];

      const request: FacturationRequest = {
        appel: MOCK_APPEL_1,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      expect(apiClient.post).toHaveBeenCalledWith('/api/facturation-appel/facturer', request);
      expect(state.historiqueAppels[0].facture).toBe(true);
      expect(state.historiqueAppels[0].operationId).toBe(99999);
    });

    it('should handle facturation failure', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { success: true, data: { cloture_enCours: false, testReseau: 'OK' } },
      } as GetClotureStatusResponse);
      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: { success: true, data: { success: false } },
      } as FacturerAppelResponse);

      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1];

      const request: FacturationRequest = {
        appel: MOCK_APPEL_1,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      await store.facturerAppel(request);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Échec facturation');
      expect(state.historiqueAppels[0].facture).toBe(false);
    });
  });

  describe('verifierCloture', () => {
    it('should return mock cloture status when isRealApi is false', async () => {
      const store = useFacturationAppelStore.getState();

      const result = await store.verifierCloture();

      const state = useFacturationAppelStore.getState();
      expect(result).toBe(false);
      expect(state.cloture?.cloture_enCours).toBe(false);
      expect(state.cloture?.testReseau).toBe('OK');
    });

    it('should call API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockResolvedValueOnce({
        data: { success: true, data: { cloture_enCours: true, testReseau: 'OK' } },
      } as GetClotureStatusResponse);

      const store = useFacturationAppelStore.getState();
      const result = await store.verifierCloture();

      expect(apiClient.get).toHaveBeenCalledWith('/api/facturation-appel/cloture-status');
      expect(result).toBe(true);
      expect(store.cloture?.cloture_enCours).toBe(true);
    });

    it('should handle API error and return false', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Cloture check failed'));

      const store = useFacturationAppelStore.getState();
      const result = await store.verifierCloture();

      const state = useFacturationAppelStore.getState();
      expect(result).toBe(false);
      expect(state.error).toBe('Cloture check failed');
      expect(state.cloture).toBeNull();
    });
  });

  describe('debloquerCloture', () => {
    it('should unlock cloture in mock mode', async () => {
      const store = useFacturationAppelStore.getState();
      store.cloture = { cloture_enCours: true, testReseau: 'OK' };

      await store.debloquerCloture();

      const state = useFacturationAppelStore.getState();
      expect(state.cloture?.cloture_enCours).toBe(false);
      expect(state.isLoading).toBe(false);
    });

    it('should call API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockResolvedValueOnce({
        data: { success: true, data: { success: true } },
      } as DebloquerClotureResponse);

      const store = useFacturationAppelStore.getState();
      store.cloture = { cloture_enCours: true, testReseau: 'OK' };

      await store.debloquerCloture();

      const state = useFacturationAppelStore.getState();
      expect(apiClient.post).toHaveBeenCalledWith('/api/facturation-appel/debloquer-cloture');
      expect(state.cloture?.cloture_enCours).toBe(false);
    });

    it('should handle API error', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Unlock failed'));

      const store = useFacturationAppelStore.getState();
      store.cloture = { cloture_enCours: true, testReseau: 'OK' };

      await store.debloquerCloture();

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Unlock failed');
    });
  });

  describe('marquerGratuit', () => {
    it('should mark appel as gratuit with reason in mock mode', async () => {
      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1, MOCK_APPEL_2];

      await store.marquerGratuit(1, 'Erreur ligne technique');

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels[0].gratuite).toBe(true);
      expect(state.historiqueAppels[0].raisonGratuite).toBe('Erreur ligne technique');
      expect(state.historiqueAppels[1].gratuite).toBe(false);
    });

    it('should call API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.put).mockResolvedValueOnce({
        data: { success: true, data: { success: true } },
      } as MarquerGratuitResponse);

      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1];

      await store.marquerGratuit(1, 'Urgence medicale');

      const state = useFacturationAppelStore.getState();
      expect(apiClient.put).toHaveBeenCalledWith(
        '/api/facturation-appel/marquer-gratuit/1',
        { raison: 'Urgence medicale' }
      );
      expect(state.historiqueAppels[0].gratuite).toBe(true);
      expect(state.historiqueAppels[0].raisonGratuite).toBe('Urgence medicale');
    });

    it('should handle API error', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.put).mockRejectedValueOnce(new Error('Marking failed'));

      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1];

      await store.marquerGratuit(1, 'Test');

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Marking failed');
    });
  });

  describe('annulerFacturation', () => {
    it('should cancel facturation in mock mode', async () => {
      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_2];

      await store.annulerFacturation(2);

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels[0].facture).toBe(false);
      expect(state.historiqueAppels[0].operationId).toBeUndefined();
    });

    it('should call API when isRealApi is true', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.delete).mockResolvedValueOnce({
        data: { success: true, data: { success: true } },
      } as AnnulerFacturationResponse);

      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_2];

      await store.annulerFacturation(2);

      const state = useFacturationAppelStore.getState();
      expect(apiClient.delete).toHaveBeenCalledWith('/api/facturation-appel/annuler/2');
      expect(state.historiqueAppels[0].facture).toBe(false);
      expect(state.historiqueAppels[0].operationId).toBeUndefined();
    });

    it('should handle API error', async () => {
      vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
      vi.mocked(apiClient.delete).mockRejectedValueOnce(new Error('Cancel failed'));

      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_2];

      await store.annulerFacturation(2);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Cancel failed');
    });
  });

  describe('filters', () => {
    it('should set filter societe', () => {
      const store = useFacturationAppelStore.getState();
      store.setFilterSociete('SOC2');

      const state = useFacturationAppelStore.getState();
      expect(state.filterSociete).toBe('SOC2');
    });

    it('should set filter date debut', () => {
      const store = useFacturationAppelStore.getState();
      const date = new Date('2026-02-15');
      store.setFilterDateDebut(date);

      const state = useFacturationAppelStore.getState();
      expect(state.filterDateDebut).toBe(date);
    });

    it('should set filter date fin', () => {
      const store = useFacturationAppelStore.getState();
      const date = new Date('2026-02-20');
      store.setFilterDateFin(date);

      const state = useFacturationAppelStore.getState();
      expect(state.filterDateFin).toBe(date);
    });

    it('should reset all filters', () => {
      const store = useFacturationAppelStore.getState();
      store.setFilterSociete('SOC2');
      store.setFilterDateDebut(new Date('2026-02-15'));
      store.setFilterDateFin(new Date('2026-02-20'));

      store.resetFilters();

      const state = useFacturationAppelStore.getState();
      expect(state.filterSociete).toBe('');
      expect(state.filterDateDebut).toBeNull();
      expect(state.filterDateFin).toBeNull();
    });
  });

  describe('error handling', () => {
    it('should set error', () => {
      const store = useFacturationAppelStore.getState();
      store.setError('Test error');

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBe('Test error');
    });

    it('should clear error', () => {
      const store = useFacturationAppelStore.getState();
      store.setError('Test error');
      store.setError(null);

      const state = useFacturationAppelStore.getState();
      expect(state.error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1];
      store.coefficientTelephone = 0.15;
      store.cloture = { cloture_enCours: false, testReseau: 'OK' };
      store.filterSociete = 'SOC1';
      store.error = 'Test error';

      store.reset();

      const state = useFacturationAppelStore.getState();
      expect(state.historiqueAppels).toHaveLength(0);
      expect(state.coefficientTelephone).toBeNull();
      expect(state.cloture).toBeNull();
      expect(state.filterSociete).toBe('');
      expect(state.filterDateDebut).toBeNull();
      expect(state.filterDateFin).toBeNull();
      expect(state.error).toBeNull();
      expect(state.isLoading).toBe(false);
    });
  });

  describe('loading states', () => {
    it('should set loading during chargerHistoriqueAppels', async () => {
      const store = useFacturationAppelStore.getState();
      const loadingPromise = store.chargerHistoriqueAppels('SOC1', 'CAI01');

      expect(useFacturationAppelStore.getState().isLoading).toBe(true);
      await loadingPromise;
      expect(useFacturationAppelStore.getState().isLoading).toBe(false);
    });

    it('should set loading during recupererCoefficient', async () => {
      const store = useFacturationAppelStore.getState();
      const loadingPromise = store.recupererCoefficient();

      expect(useFacturationAppelStore.getState().isLoading).toBe(true);
      await loadingPromise;
      expect(useFacturationAppelStore.getState().isLoading).toBe(false);
    });

    it('should set loading during facturerAppel', async () => {
      const store = useFacturationAppelStore.getState();
      store.historiqueAppels = [MOCK_APPEL_1];
      store.cloture = { cloture_enCours: false, testReseau: 'OK' };

      const request: FacturationRequest = {
        appel: MOCK_APPEL_1,
        numeroCompte: 12345,
        filiation: 1,
        typeCompte: 'GO',
      };

      const loadingPromise = store.facturerAppel(request);

      expect(useFacturationAppelStore.getState().isLoading).toBe(true);
      await loadingPromise;
      expect(useFacturationAppelStore.getState().isLoading).toBe(false);
    });
  });
});
```