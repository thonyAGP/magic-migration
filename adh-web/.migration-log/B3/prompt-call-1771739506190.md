Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/stores/__tests__/separationStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
useSeparationStore executeSeparation should execute and poll progress: AssertionError: expected true to be false // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/stores/__tests__/separationStore.test.ts:241:57
    at processTicksAndRejections (node:inte

CURRENT TEST FILE:
```typescript
// @vitest-environment jsdom
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useSeparationStore } from '../separationStore';

vi.mock('@/services/api/endpoints-lot6', () => ({
  separationApi: {
    searchAccount: vi.fn(),
    validate: vi.fn(),
    execute: vi.fn(),
    getProgress: vi.fn(),
    getResult: vi.fn(),
  },
}));

vi.mock('../dataSourceStore', () => ({
  useDataSourceStore: {
    getState: vi.fn(() => ({ isRealApi: true })),
  },
}));

vi.mock('../sessionStore', () => ({
  useSessionStore: {
    getState: vi.fn(() => ({
      currentSession: { id: 'session-1' },
      status: 'open',
      checkNetworkClosure: vi.fn().mockResolvedValue({ status: 'completed' }),
    })),
  },
}));

import { separationApi } from '@/services/api/endpoints-lot6';
import { useDataSourceStore } from '../dataSourceStore';

const mockAccounts = [
  { codeAdherent: 1001, filiation: 0, nom: 'Dupont', prenom: 'Jean', societe: 'ADH', solde: 1250, nbTransactions: 45 },
  { codeAdherent: 1002, filiation: 0, nom: 'Martin', prenom: 'Marie', societe: 'ADH', solde: 890.5, nbTransactions: 23 },
];

const mockPreview = {
  compteSource: mockAccounts[0],
  compteDestination: mockAccounts[1],
  nbOperationsADeplacer: 15,
  montantADeplacer: 450.00,
  garantiesImpactees: 0,
  avertissements: [],
};

const mockResult = {
  success: true,
  compteSource: mockAccounts[0],
  compteDestination: mockAccounts[1],
  nbOperationsDeplacees: 15,
  montantDeplace: 450.00,
  message: 'Separation effectuee avec succes',
  dateExecution: new Date().toISOString(),
};

const mockProgress = {
  operationId: 'op-001',
  progress: 50,
  status: 'in_progress' as const,
};

describe('useSeparationStore', () => {
  beforeEach(() => {
    useSeparationStore.setState({
      compteSource: null,
      compteDestination: null,
      preview: null,
      result: null,
      progress: null,
      currentStep: 'selection',
      searchResults: [],
      isSearching: false,
      isValidating: false,
      isExecuting: false,
      error: null,
      prerequisites: null,
      filiations: [],
      failedStep: null,
    });
    vi.clearAllMocks();
    vi.mocked(useDataSourceStore.getState).mockReturnValue({ isRealApi: true } as never);
  });

  describe('initial state', () => {
    it('should have default values', () => {
      const state = useSeparationStore.getState();
      expect(state.compteSource).toBeNull();
      expect(state.compteDestination).toBeNull();
      expect(state.preview).toBeNull();
      expect(state.result).toBeNull();
      expect(state.progress).toBeNull();
      expect(state.currentStep).toBe('selection');
      expect(state.searchResults).toEqual([]);
      expect(state.isSearching).toBe(false);
      expect(state.isValidating).toBe(false);
      expect(state.isExecuting).toBe(false);
      expect(state.error).toBeNull();
    });
  });

  describe('searchAccount', () => {
    it('should set search results on success', async () => {
      vi.mocked(separationApi.searchAccount).mockResolvedValue({
        data: { data: mockAccounts },
      } as never);

      await useSeparationStore.getState().searchAccount('ADH', 'Dupont');

      const results = useSeparationStore.getState().searchResults;
      expect(results).toHaveLength(2);
      expect(results[0]).toMatchObject({ codeAdherent: 1001, nom: 'Dupont' });
      expect(useSeparationStore.getState().isSearching).toBe(false);
    });

    it('should set error on failure in non-DEV mode', async () => {
      vi.mocked(separationApi.searchAccount).mockRejectedValue(new Error('Network error'));

      await useSeparationStore.getState().searchAccount('ADH', 'test');

      const state = useSeparationStore.getState();
      expect(state.isSearching).toBe(false);
      expect(state.error).toBe('Network error');
    });

    it('should handle null data', async () => {
      vi.mocked(separationApi.searchAccount).mockResolvedValue({
        data: { data: null },
      } as never);

      await useSeparationStore.getState().searchAccount('ADH', 'test');
      expect(useSeparationStore.getState().searchResults).toEqual([]);
    });
  });

  describe('selectSource', () => {
    it('should set source account', () => {
      useSeparationStore.getState().selectSource(mockAccounts[0] as never);
      expect(useSeparationStore.getState().compteSource).toEqual(mockAccounts[0]);
    });
  });

  describe('selectDestination', () => {
    it('should set destination account', () => {
      useSeparationStore.getState().selectDestination(mockAccounts[1] as never);
      expect(useSeparationStore.getState().compteDestination).toEqual(mockAccounts[1]);
    });
  });

  describe('validateSeparation', () => {
    it('should return error if accounts not selected', async () => {
      const result = await useSeparationStore.getState().validateSeparation('ADH', 'user1');

      expect(result).toEqual({ success: false, error: 'Comptes source et destination requis' });
    });

    it('should validate and set preview on success', async () => {
      useSeparationStore.setState({
        compteSource: mockAccounts[0] as never,
        compteDestination: mockAccounts[1] as never,
      });
      vi.mocked(separationApi.validate).mockResolvedValue({
        data: { data: mockPreview },
      } as never);

      const result = await useSeparationStore.getState().validateSeparation('ADH', 'user1');

      expect(result).toEqual({ success: true });
      const preview = useSeparationStore.getState().preview;
      expect(preview).toMatchObject({
        nbOperationsADeplacer: 15,
        montantADeplacer: 450.00,
      });
      expect(useSeparationStore.getState().currentStep).toBe('preview');
      expect(useSeparationStore.getState().isValidating).toBe(false);
    });

    it('should set error on validation failure', async () => {
      useSeparationStore.setState({
        compteSource: mockAccounts[0] as never,
        compteDestination: mockAccounts[1] as never,
      });
      vi.mocked(separationApi.validate).mockRejectedValue(new Error('Same account'));

      const result = await useSeparationStore.getState().validateSeparation('ADH', 'user1');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Same account');
      expect(useSeparationStore.getState().isValidating).toBe(false);
      expect(useSeparationStore.getState().error).toBe('Same account');
    });

    it('should set isValidating during validation', async () => {
      useSeparationStore.setState({
        compteSource: mockAccounts[0] as never,
        compteDestination: mockAccounts[1] as never,
      });
      let resolve: (v: unknown) => void;
      const promise = new Promise((r) => { resolve = r; });
      vi.mocked(separationApi.validate).mockReturnValue(promise as never);

      const validatePromise = useSeparationStore.getState().validateSeparation('ADH', 'user1');
      
      await vi.waitFor(() => {
        expect(useSeparationStore.getState().isValidating).toBe(true);
      });

      resolve!({ data: { data: mockPreview } });
      await validatePromise;
      expect(useSeparationStore.getState().isValidating).toBe(false);
    });
  });

  describe('executeSeparation', () => {
    it('should return error if accounts not selected', async () => {
      const result = await useSeparationStore.getState().executeSeparation('ADH', 'user1');

      expect(result).toEqual({ success: false, error: 'Comptes source et destination requis' });
    });

    it('should execute and poll progress', async () => {
      useSeparationStore.setState({
        compteSource: mockAccounts[0] as never,
        compteDestination: mockAccounts[1] as never,
      });
      vi.mocked(separationApi.execute).mockResolvedValue({
        data: { data: { operationId: 'op-001' } },
      } as never);
      vi.mocked(separationApi.getResult).mockResolvedValue({
        data: { data: mockResult },
      } as never);

      const result = await useSeparationStore.getState().executeSeparation('ADH', 'user1');

      expect(result).toEqual({ success: true });
      const storeResult = useSeparationStore.getState().result;
      expect(storeResult?.success).toBe(true);
      expect(storeResult?.nbOperationsDeplacees).toBe(15);
      expect(useSeparationStore.getState().currentStep).toBe('result');
      expect(useSeparationStore.getState().isExecuting).toBe(false);
    });

    it('should set error on execution failure', async () => {
      useSeparationStore.setState({
        compteSource: mockAccounts[0] as never,
        compteDestination: mockAccounts[1] as never,
      });
      vi.mocked(separationApi.execute).mockRejectedValue(new Error('Server error'));

      const result = await useSeparationStore.getState().executeSeparation('ADH', 'user1');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Server error');
      expect(useSeparationStore.getState().isExecuting).toBe(false);
      expect(useSeparationStore.getState().error).toBe('Server error');
      expect(useSeparationStore.getState().failedStep).toMatchObject({
        name: 'Execution separation',
        error: 'Server error',
      });
    });
  });

  describe('pollProgress', () => {
    it('should set result when available', async () => {
      useSeparationStore.setState({
        compteSource: mockAccounts[0] as never,
        compteDestination: mockAccounts[1] as never,
      });
      vi.mocked(separationApi.getResult).mockResolvedValue({
        data: { data: mockResult },
      } as never);

      await useSeparationStore.getState().pollProgress('op-001');

      const result = useSeparationStore.getState().result;
      expect(result?.success).toBe(true);
      expect(result?.nbOperationsDeplacees).toBe(15);
      expect(useSeparationStore.getState().currentStep).toBe('result');
    });

    it('should fallback to progress when result not ready', async () => {
      vi.mocked(separationApi.getResult).mockRejectedValue(new Error('Not ready'));
      vi.mocked(separationApi.getProgress).mockResolvedValue({
        data: { data: mockProgress },
      } as never);

      await useSeparationStore.getState().pollProgress('op-001');

      const progress = useSeparationStore.getState().progress;
      expect(progress).toMatchObject({
        operationId: 'op-001',
        progress: 50,
      });
    });

    it('should silently handle both errors', async () => {
      vi.mocked(separationApi.getResult).mockRejectedValue(new Error('fail'));
      vi.mocked(separationApi.getProgress).mockRejectedValue(new Error('fail'));

      await useSeparationStore.getState().pollProgress('op-001');
    });
  });

  describe('setStep', () => {
    it('should change the current step', () => {
      useSeparationStore.getState().setStep('confirmation');
      expect(useSeparationStore.getState().currentStep).toBe('confirmation');
    });
  });

  describe('reset', () => {
    it('should reset all state', () => {
      useSeparationStore.setState({
        compteSource: mockAccounts[0] as never,
        compteDestination: mockAccounts[1] as never,
        preview: mockPreview as never,
        result: mockResult as never,
        currentStep: 'result',
        error: 'error',
      });

      useSeparationStore.getState().reset();

      const state = useSeparationStore.getState();
      expect(state.compteSource).toBeNull();
      expect(state.compteDestination).toBeNull();
      expect(state.preview).toBeNull();
      expect(state.result).toBeNull();
      expect(state.currentStep).toBe('selection');
      expect(state.error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  SeparationAccount,
  SeparationPreview,
  SeparationResult,
  SeparationProgress,
  SeparationStep,
} from '@/types/separation';
import type { Filiation } from '@/components/caisse/separation/types';
import { separationApi } from '@/services/api/endpoints-lot6';
import { useDataSourceStore } from './dataSourceStore';
import { useSessionStore } from './sessionStore';

interface PrerequisiteCheck {
  canProceed: boolean;
  warnings: string[];
}

interface SeparationState {
  compteSource: SeparationAccount | null;
  compteDestination: SeparationAccount | null;
  preview: SeparationPreview | null;
  result: SeparationResult | null;
  progress: SeparationProgress | null;
  currentStep: SeparationStep;
  searchResults: SeparationAccount[];
  isSearching: boolean;
  isValidating: boolean;
  isExecuting: boolean;
  error: string | null;
  prerequisites: PrerequisiteCheck | null;
  filiations: Filiation[];
  failedStep: { name: string; error: string } | null;
}

interface SeparationActions {
  checkPrerequisites: () => Promise<PrerequisiteCheck>;
  searchAccount: (societe: string, query: string) => Promise<void>;
  selectSource: (account: SeparationAccount) => void;
  selectDestination: (account: SeparationAccount) => void;
  loadFiliations: (accountId: string) => Promise<void>;
  validateSeparation: (
    societe: string,
    operateur: string,
  ) => Promise<{ success: boolean; error?: string }>;
  executeSeparation: (
    societe: string,
    operateur: string,
  ) => Promise<{ success: boolean; error?: string }>;
  pollProgress: (operationId: string) => Promise<void>;
  retryFailedStep: () => void;
  markFailedStepDone: () => void;
  skipFailedStep: () => void;
  setStep: (step: SeparationStep) => void;
  reset: () => void;
}

type SeparationStore = SeparationState & SeparationActions;

const MOCK_ACCOUNTS: SeparationAccount[] = [
  { codeAdherent: 1001, filiation: 0, nom: 'Dupont', prenom: 'Jean', societe: 'ADH', solde: 1250.00, nbTransactions: 45 },
  { codeAdherent: 1002, filiation: 0, nom: 'Martin', prenom: 'Marie', societe: 'ADH', solde: 890.50, nbTransactions: 23 },
  { codeAdherent: 1003, filiation: 1, nom: 'Durand', prenom: 'Pierre', societe: 'ADH', solde: 320.00, nbTransactions: 12 },
];

const MOCK_FILIATIONS: Record<string, Filiation[]> = {
  '1001': [
    { id: 'fil-1', nom: 'Dupont', prenom: 'Sophie', typeRelation: 'conjoint', compteId: '1001-1' },
    { id: 'fil-2', nom: 'Dupont', prenom: 'Lucas', typeRelation: 'enfant', compteId: '1001-2' },
  ],
  '1002': [
    { id: 'fil-3', nom: 'Martin', prenom: 'Paul', typeRelation: 'parent', compteId: '1002-1' },
  ],
  '1003': [],
};

const initialState: SeparationState = {
  compteSource: null,
  compteDestination: null,
  preview: null,
  result: null,
  progress: null,
  currentStep: 'selection',
  searchResults: [],
  isSearching: false,
  isValidating: false,
  isExecuting: false,
  error: null,
  prerequisites: null,
  filiations: [],
  failedStep: null,
};

export const useSeparationStore = create<SeparationStore>()((set, get) => ({
  ...initialState,

  checkPrerequisites: async (): Promise<PrerequisiteCheck> => {
    const warnings: string[] = [];
    const session = useSessionStore.getState().currentSession;

    if (!session || useSessionStore.getState().status !== 'open') {
      warnings.push('Aucune session ouverte. Veuillez ouvrir une session avant de proceder.');
    }

    const closureResult = await useSessionStore.getState().checkNetworkClosure();
    if (closureResult.status !== 'completed') {
      warnings.push('La cloture reseau n\'est pas effectuee. Certaines operations pourraient etre incompletes.');
    }

    const result: PrerequisiteCheck = {
      canProceed: true,
      warnings,
    };
    set({ prerequisites: result });
    return result;
  },

  loadFiliations: async (accountId: string) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      const filiations = MOCK_FILIATIONS[accountId] ?? [];
      set({ filiations });
      return;
    }

    try {
      const response = await separationApi.searchAccount('ADH', accountId);
      // API would return filiations; for now use empty array in real mode
      set({ filiations: (response.data as unknown as { filiations?: Filiation[] })?.filiations ?? [] });
    } catch {
      set({ filiations: [] });
    }
  },

  searchAccount: async (societe, query) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isSearching: true, error: null });

    if (!isRealApi) {
      const filtered = MOCK_ACCOUNTS.filter(
        (a) =>
          a.nom.toLowerCase().includes(query.toLowerCase()) ||
          a.prenom.toLowerCase().includes(query.toLowerCase()) ||
          String(a.codeAdherent).includes(query),
      );
      set({ searchResults: filtered, isSearching: false });
      return;
    }

    try {
      const response = await separationApi.searchAccount(societe, query);
      set({ searchResults: response.data.data ?? [], isSearching: false });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur recherche compte';
      set({ searchResults: [], error: message, isSearching: false });
    }
  },

  selectSource: (account) => {
    set({ compteSource: account, filiations: [] });
    if (account) {
      get().loadFiliations(String(account.codeAdherent));
    }
  },

  selectDestination: (account) => {
    set({ compteDestination: account });
  },

  validateSeparation: async (societe, _operateur) => {
    const { compteSource, compteDestination } = get();
    if (!compteSource || !compteDestination) {
      return { success: false, error: 'Comptes source et destination requis' };
    }

    const { isRealApi } = useDataSourceStore.getState();
    set({ isValidating: true, error: null });

    if (!isRealApi) {
      const mockPreview: SeparationPreview = {
        compteSource,
        compteDestination,
        nbOperationsADeplacer: 15,
        montantADeplacer: 450.00,
        garantiesImpactees: 0,
        avertissements: [],
      };
      set({ preview: mockPreview, currentStep: 'preview', isValidating: false });
      return { success: true };
    }

    try {
      const response = await separationApi.validate({
        societe,
        codeAdherentSource: compteSource.codeAdherent,
        filiationSource: compteSource.filiation,
        codeAdherentDest: compteDestination.codeAdherent,
        filiationDest: compteDestination.filiation,
      });
      set({ preview: response.data.data ?? null, currentStep: 'preview', isValidating: false });
      return { success: true };
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation separation';
      set({ error: message, isValidating: false });
      return { success: false, error: message };
    }
  },

  executeSeparation: async (societe, operateur) => {
    const { compteSource, compteDestination } = get();
    if (!compteSource || !compteDestination) {
      return { success: false, error: 'Comptes source et destination requis' };
    }

    const { isRealApi } = useDataSourceStore.getState();
    set({ isExecuting: true, error: null, currentStep: 'processing' });

    if (!isRealApi) {
      const mockResult: SeparationResult = {
        success: true,
        compteSource,
        compteDestination,
        nbOperationsDeplacees: 15,
        montantDeplace: 450.00,
        message: 'Separation effectuee avec succes',
        dateExecution: new Date().toISOString(),
      };
      set({ result: mockResult, currentStep: 'result', isExecuting: false });
      return { success: true };
    }

    try {
      const response = await separationApi.execute({
        societe,
        codeAdherentSource: compteSource.codeAdherent,
        filiationSource: compteSource.filiation,
        codeAdherentDest: compteDestination.codeAdherent,
        filiationDest: compteDestination.filiation,
        operateur,
      });
      const operationId = response.data.data?.operationId;
      if (operationId) {
        await get().pollProgress(operationId);
      }
      return { success: true };
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur execution separation';
      set({
        error: message,
        failedStep: { name: 'Execution separation', error: message },
        isExecuting: false,
      });
      return { success: false, error: message };
    }
  },

  pollProgress: async (operationId) => {
    const { isRealApi } = useDataSourceStore.getState();

    if (!isRealApi) {
      const { compteSource, compteDestination } = get();
      const mockResult: SeparationResult = {
        success: true,
        compteSource: compteSource!,
        compteDestination: compteDestination!,
        nbOperationsDeplacees: 15,
        montantDeplace: 450.00,
        message: 'Separation effectuee avec succes',
        dateExecution: new Date().toISOString(),
      };
      set({ result: mockResult, currentStep: 'result' });
      return;
    }

    try {
      const resultResponse = await separationApi.getResult(operationId);
      set({
        result: resultResponse.data.data ?? null,
        currentStep: 'result',
      });
    } catch {
      try {
        const progressResponse = await separationApi.getProgress(operationId);
        set({ progress: progressResponse.data.data ?? null });
      } catch {
        // Silently ignore progress polling errors
      }
    }
  },

  retryFailedStep: () => {
    set({ failedStep: null, error: null });
    // Re-trigger execution - caller will handle
  },

  markFailedStepDone: () => {
    const { compteSource, compteDestination } = get();
    const mockResult: SeparationResult = {
      success: true,
      compteSource: compteSource!,
      compteDestination: compteDestination!,
      nbOperationsDeplacees: 0,
      montantDeplace: 0,
      message: 'Separation marquee comme terminee manuellement',
      dateExecution: new Date().toISOString(),
    };
    set({ failedStep: null, result: mockResult, currentStep: 'result', isExecuting: false });
  },

  skipFailedStep: () => {
    const { compteSource, compteDestination } = get();
    const mockResult: SeparationResult = {
      success: false,
      compteSource: compteSource!,
      compteDestination: compteDestination!,
      nbOperationsDeplacees: 0,
      montantDeplace: 0,
      message: 'Operation passee par l\'operateur',
      dateExecution: new Date().toISOString(),
    };
    set({ failedStep: null, result: mockResult, currentStep: 'result', isExecuting: false });
  },

  setStep: (step) => {
    set({ currentStep: step });
  },

  reset: () => set({ ...initialState }),
}));

```

Output the COMPLETE fixed test file. Do not omit any tests.