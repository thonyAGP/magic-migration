```typescript
import { create } from 'zustand';
import type {
  Session,
  UnilateralBilateral,
  SessionClosureResult,
  FermetureSessionsState,
} from '@/types/fermetureSessions';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface FermetureSessionsActions {
  loadSessions: (filters?: { statut?: string }) => Promise<void>;
  loadUnilateralBilateralTypes: () => Promise<void>;
  fermerSession: (sessionId: number) => Promise<void>;
  generateClosureCode: (sessionId: number) => string;
  validateSessionClosure: (sessionId: number) => Promise<boolean>;
  setCurrentSession: (session: Session | null) => void;
  clearError: () => void;
  reset: () => void;
}

type FermetureSessionsStore = FermetureSessionsState & FermetureSessionsActions;

const MOCK_SESSIONS: Session[] = [
  { id: 1, dateOuverture: new Date('2026-02-19T08:00:00'), dateFermeture: null, statut: 'O' },
  { id: 2, dateOuverture: new Date('2026-02-18T08:00:00'), dateFermeture: null, statut: 'O' },
  { id: 3, dateOuverture: new Date('2026-02-17T08:00:00'), dateFermeture: null, statut: 'O' },
  { id: 4, dateOuverture: new Date('2026-02-16T08:00:00'), dateFermeture: new Date('2026-02-16T18:00:00'), statut: 'C' },
  { id: 5, dateOuverture: new Date('2026-02-15T08:00:00'), dateFermeture: new Date('2026-02-15T18:00:00'), statut: 'C' },
];

const MOCK_TYPES: UnilateralBilateral[] = [
  { code: 'UNI', libelle: 'Unilateral', type: 'unilateral' },
  { code: 'BIL', libelle: 'Bilateral', type: 'bilateral' },
  { code: 'MIX', libelle: 'Mixed', type: 'mixed' },
];

const initialState: FermetureSessionsState = {
  sessions: [],
  currentSession: null,
  unilateralBilateralTypes: [],
  isLoading: false,
  error: null,
  isClosing: false,
};

export const useFermetureSessionsStore = create<FermetureSessionsStore>()((set, get) => ({
  ...initialState,

  loadSessions: async (filters) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const filtered = filters?.statut
        ? MOCK_SESSIONS.filter((s) => s.statut === filters.statut)
        : MOCK_SESSIONS;
      set({ sessions: filtered, isLoading: false });
      return;
    }

    try {
      const params = filters?.statut ? `?statut=${filters.statut}` : '';
      const response = await apiClient.get<ApiResponse<{ sessions: Session[] }>>(
        `/api/fermeture-sessions/sessions${params}`,
      );
      set({ sessions: response.data.data?.sessions ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement sessions';
      set({ sessions: [], error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  loadUnilateralBilateralTypes: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({ unilateralBilateralTypes: MOCK_TYPES, isLoading: false });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<{ types: UnilateralBilateral[] }>>(
        '/api/fermeture-sessions/types',
      );
      set({ unilateralBilateralTypes: response.data.data?.types ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement types';
      set({ unilateralBilateralTypes: [], error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  fermerSession: async (sessionId) => {
    const { isRealApi } = useDataSourceStore.getState();
    const { validateSessionClosure, generateClosureCode } = get();

    set({ isClosing: true, error: null });

    const isValid = await validateSessionClosure(sessionId);
    if (!isValid) {
      set({ isClosing: false, error: 'Session non éligible à la fermeture' });
      return;
    }

    const closureCode = generateClosureCode(sessionId);

    if (!isRealApi) {
      set((state) => ({
        sessions: state.sessions.map((s) =>
          s.id === sessionId
            ? { ...s, dateFermeture: new Date(), statut: 'C' as const }
            : s,
        ),
        currentSession:
          state.currentSession?.id === sessionId
            ? { ...state.currentSession, dateFermeture: new Date(), statut: 'C' as const }
            : state.currentSession,
        isClosing: false,
      }));
      return;
    }

    try {
      const response = await apiClient.post<ApiResponse<SessionClosureResult>>(
        `/api/fermeture-sessions/close/${sessionId}`,
        {},
      );

      if (response.data.data?.success) {
        set((state) => ({
          sessions: state.sessions.map((s) =>
            s.id === sessionId
              ? { ...s, dateFermeture: new Date(), statut: 'C' as const }
              : s,
          ),
          currentSession:
            state.currentSession?.id === sessionId
              ? { ...state.currentSession, dateFermeture: new Date(), statut: 'C' as const }
              : state.currentSession,
        }));
      } else {
        set({ error: 'Échec fermeture session' });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur fermeture session';
      set({ error: message });
    } finally {
      set({ isClosing: false });
    }
  },

  generateClosureCode: (sessionId) => {
    const D = sessionId % 10;
    const base = 'N15';
    const decimalPart = D > 0 ? `.${D}` : '';
    const suffix = 'CZ';
    return `${base}${decimalPart}${suffix}`;
  },

  validateSessionClosure: async (sessionId) => {
    const { isRealApi } = useDataSourceStore.getState();
    const { sessions } = get();

    const session = sessions.find((s) => s.id === sessionId);
    if (!session) {
      set({ error: 'Session introuvable' });
      return false;
    }

    if (session.statut !== 'O') {
      set({ error: 'Seules les sessions ouvertes peuvent être fermées' });
      return false;
    }

    if (!isRealApi) {
      return true;
    }

    try {
      const response = await apiClient.post<ApiResponse<{ valid: boolean; errors: string[] }>>(
        `/api/fermeture-sessions/validate/${sessionId}`,
        {},
      );
      const result = response.data.data;
      if (!result?.valid && result?.errors?.length) {
        set({ error: result.errors.join(', ') });
      }
      return result?.valid ?? false;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation';
      set({ error: message });
      return false;
    }
  },

  setCurrentSession: (session) => {
    set({ currentSession: session, error: null });
  },

  clearError: () => {
    set({ error: null });
  },

  reset: () => set({ ...initialState }),
}));
```