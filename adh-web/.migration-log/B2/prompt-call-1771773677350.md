Generate a React page component for the "TicketFermetureSession" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

PAGE REQUIREMENTS:
- Use store via useTicketFermetureSessionStore()
- Destructure 20+ fields from store
- useCallback for event handlers
- useEffect for init + cleanup (call reset on unmount)
- ScreenLayout wrapper from @/components/layout (import { ScreenLayout } from "@/components/layout")
- ScreenLayout takes children + className props (no title prop)
- Tailwind v4 classes for styling
- Handle loading, error, and empty states

UI LAYOUT:
{
  "type": "modal-dialog",
  "sections": [
    {
      "name": "header",
      "controls": [
        "SessionNumber (readonly)",
        "DateComptable (readonly)",
        "NomVillage (readonly)"
      ]
    },
    {
      "name": "montants",
      "controls": [
        "CaisseDepart (readonly)",
        "ApportCoffre (readonly)",
        "Versement (readonly)",
        "Retrait (readonly)",
        "SoldeCash (readonly)",
        "SoldeCarte (readonly)",
        "Change (readonly)",
        "FraisChange (readonly)"
      ]
    },
    {
      "name": "actions",
      "controls": [
        "PrinterSelector (dropdown: 1 ou 9)",
        "GenerateButton (primary)",
        "CancelButton (secondary)"
      ]
    }
  ]
}

STORE INTERFACE (actions and state available):
import { create } from 'zustand';
import type {
  RecapFermetureSession,
  MontantComptable,
  LoadRecapDataRequest,
  LoadMontantsRequest,
  GenerateTicketRequest,
  PrinterOption,
} from '@/types/ticketFermetureSession';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface TicketFermetureSessionState {
  recapData: RecapFermetureSession | null;
  montantsComptables: MontantComptable[];
  isLoading: boolean;
  error: string | null;
  finTache: string;
  printerNum: PrinterOption;
}

interface TicketFermetureSessionActions {
  loadRecapData: (societe: string, session: number) => Promise<void>;
  loadMontantsComptables: (societe: string, session: number) => Promise<void>;
  generateTicketFermeture: (
    societe: string,
    session: number,
    dateComptable: Date,
  ) => Promise<void>;
  validateFinTache: (finTache: string) => boolean;
  selectPrinter: (printerNum: PrinterOption) => void;
  reset: () => void;
}

type TicketFermetureSessionStore = TicketFermetureSessionState &
  TicketFermetureSessionActions;

const MOCK_RECAP: RecapFermetureSession = {
  societe: 'SOC1',
  session: 142,
  dateComptable: new Date('2026-02-08'),
  heureDebutSession: '08:00',
  caisseDepart: 500,
  apportCoffre: 2000,
  versement: 1500,
  retrait: 300,
  soldeCash: 3200,
  soldeCarte: 1850,
  change: 450,
  fraisChange: 15,
  deviseLocale: 'EUR',
  nomVillage: 'Club Med Peisey-Vallandry',
  editionDetaillee: true,
};

const MOCK_MONTANTS: MontantComptable[] = [
  {
    cumulQuantite: 12,
    cumulMontant: 540,
    totalMontant: 540,
    equivalent: 540,
  },
  {
    cumulQuantite: 8,
    cumulMontant: 320,
    totalMontant: 320,
    equivalent: 320,
  },
  {
    cumulQuantite: 5,
    cumulMontant: 175,
    totalMontant: 175,
    equivalent: 175,
  },
];

const initialState: TicketFermetureSessionState = {
  recapData: null,
  montantsComptables: [],
  isLoading: false,
  error: null,
  finTache: '',
  printerNum: 1,
};

export const useTicketFermetureSessionStore = create<TicketFermetureSessionStore>()(
  (set, get) => ({
    ...initialState,

    loadRecapData: async (societe, session) => {
      const { isRealApi } = useDataSourceStore.getState();
      set({ isLoading: true, error: null });

      if (!isRealApi) {
        set({
          recapData: { ...MOCK_RECAP, societe, session },
          isLoading: false,
        });
        return;
      }

      try {
        const response = await apiClient.get<
          ApiResponse<RecapFermetureSession>
        >('/api/ticketFermetureSession/recap', {
          params: { societe, session },
        });
        set({ recapData: response.data.data ?? null });
      } catch (e: unknown) {
        const message =
          e instanceof Error ? e.message : 'Erreur chargement récapitulatif';
        set({ recapData: null, error: message });
      } finally {
        set({ isLoading: false });
 

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export interface RecapFermetureSession {
  societe: string;
  session: number;
  dateComptable: Date;
  heureDebutSession: string;
  caisseDepart: number;
  apportCoffre: number;
  versement: number;
  retrait: number;
  soldeCash: number;
  soldeCarte: number;
  change: number;
  fraisChange: number;
  deviseLocale: string;
  nomVillage: string;
  editionDetaillee: boolean;
}

export interface MontantComptable {
  cumulQuantite: number;
  cumulMontant: number;
  totalMontant: number;
  equivalent: number;
}

export interface TicketFermetureSessionState {
  recapData: RecapFermetureSession | null;
  montantsComptables: MontantComptable[];
  isLoading: boolean;
  error: string | null;
  finTache: string;
  printerNum: number;
}

export interface LoadRecapDataRequest {
  societe: string;
  session: number;
}

export interface LoadRecapDataResponse extends ApiResponse<RecapFermetureSession> {}

export interface LoadMontantsRequest {
  societe: string;
  session: number;
}

export interface LoadMontantsResponse extends ApiResponse<MontantComptable[]> {}

export interface GenerateTicketRequest {
  societe: string;
  session: number;
  dateComptable: Date;
  printerNum: number;
}

export interface GenerateTicketResponse extends ApiResponse<void> {}

export interface ValidateFinTacheRequest {
  finTache: string;
}

export interface ValidateFinTacheResponse extends ApiResponse<boolean> {}

export interface SelectPrinterRequest {
  printerNum: number;
}

export type PrinterOption = 1 | 9;

export const PRINTER_OPTIONS = {
  PRIMARY: 1,
  SECONDARY: 9,
} as const;

export const BUSINESS_RULES = {
  FIN_TACHE_VALIDATION: 'RM-001: Vérifier que W0_fin_tache === "F" avant de procéder',
  PRIMARY_PRINTER: 'RM-002: Si CURRENTPRINTERNUM === 1, utiliser l\'imprimante principale',
  SECONDARY_PRINTER: 'RM-003: Si CURRENTPRINTERNUM === 9, utiliser l\'imprimante secondaire',
} as const;

SPEC UI DESCRIPTION:
> **Structure**: 4 onglets (Resume | Ecrans | Donnees | Connexions)
| Taches | 23 (0 ecrans visibles) |
Le programme ADH IDE 138 assure la génération d'un tableau récapitulatif pour la clôture de session. Il traite les données de fermeture de caisse (montants par mode de paiement, devises, articles) en construisant une synthèse structurée à partir de 25 paramètres d'entrée couvrant les montants (cartes, chèques, OD), les devises avec taux de change, et les informations de facturation (date comptable, numéro session, imputation). Le programme effectue une seule tâche sans écran visible, opérant en mode traitement batch avec calcul d'index sur la table temporaire `pv_discounts`.
Bien que statué comme orphelin potentiel (aucun caller direct identifié), ce programme doit logiquement être appelé depuis les modules de fermeture caisse (ADH IDE 131, 299) ou de réimpression de tickets (IDE 151) pour consigner les récapitulatifs de session. Il lit exclusivement la table `devise_in` (taux de change) sans écriture dans les tables permanentes, ce qui le positionne comme un utilitaire de mise en forme de données pour les rapports ou écrans de récapitulation.
Son intégration dans la migration se fera par transformation des 30 expressions (principalement des références de paramètres et une formule de calcul `[AA]+1`) en logique applicative C#, sans dépendance critique à d'autres programmes, rendant sa complexité faible et son impact de migration limité.
<!-- TAB:Ecrans -->
## 8. ECRANS
*(Programme sans ecran visible)*
    INIT[Init controles]
| Ecrans visibles | 0 | Ecran unique ou traitement batch |

REFERENCE PATTERN:
```tsx
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import {
  ExtraitAccountSelector,
  ExtraitTransactionGrid,
  ExtraitFormatDialog,
} from '@/components/caisse/extrait';
import { EmailSendDialog } from '@/components/caisse/dialogs';
import { useExtraitStore } from '@/stores/extraitStore';
import { useAuthStore } from '@/stores';
import type { ExtraitAccountInfo, ExtraitPrintFormat } from '@/types/extrait';

type Phase = 'search' | 'extrait';

export function ExtraitPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);
  const societe = 'ADH';

  const selectedAccount = useExtraitStore((s) => s.selectedAccount);
  const transactions = useExtraitStore((s) => s.transactions);
  const summary = useExtraitStore((s) => s.summary);
  const searchResults = useExtraitStore((s) => s.searchResults);
  const isSearching = useExtraitStore((s) => s.isSearching);
  const isLoadingExtrait = useExtraitStore((s) => s.isLoadingExtrait);
  const isPrinting = useExtraitStore((s) => s.isPrinting);
  const error = useExtraitStore((s) => s.error);
  const searchAccount = useExtraitStore((s) => s.searchAccount);
  const selectAccount = useExtraitStore((s) => s.selectAccount);
  const loadExtrait = useExtraitStore((s) => s.loadExtrait);
  const printExtrait = useExtraitStore((s) => s.printExtrait);
  const reset = useExtraitStore((s) => s.reset);

  const [phase, setPhase] = useState<Phase>('search');
  const [showFormatDialog, setShowFormatDialog] = useState(false);
  const [showEmailDialog, setShowEmailDialog] = useState(false);

  useEffect(() => {
    return () => reset();
  }, [reset]);

  const handleSelectAccount = useCallback(
    (account: ExtraitAccountInfo) => {
      selectAccount(account);
      loadExtrait(societe, account.codeAdherent, account.filiation);
      setPhase('extrait');
    },
    [selectAccount, loadExtrait, societe],
  );

  const handlePrintFormat = useCallback(
    async (format: ExtraitPrintFormat) => {
      if (!selectedAccount) return;
      await printExtrait(
        societe,
        selectedAccount.codeAdherent,
        selectedAccount.filiation,
        format,
      );
      setShowFormatDialog(false);
    },
    [selectedAccount, printExtrait, societe],
  );

  const handleBack = () => {
    if (phase === 'extrait') {
      reset();
      setPhase('search');
    } else {
      navigate('/caisse/menu');
    }
  };

  return (
    <ScreenLayout>
      <div className="space-y-6 max-w-4xl mx-auto">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold">Extrait de compte</h2>
            <p className="text-on-surface-muted text-sm mt-1">
              {phase === 'search'
                ? 'Rechercher un compte adherent'
                : `Compte: ${selectedAccount?.nom} ${selectedAccount?.prenom} #${selectedAccount?.codeAdherent}`}
            </p>
          </div>
          {user && (
            <span className="text-xs text-on-surface-muted">
              {user.prenom} {user.nom}
            </span>
          )}
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md text-sm">
            {error}
          </div>
        )}

        {phase === 'search' && (
          <>
            <ExtraitAccountSelector
              onSelect={handleSelectAccount}
              onSearch={(q) => searchAccount(societe, q)}
              searchResults={searchResults}
              isSearching={isSearching}
              isLoading={isLoadingExtrait}
            />
            <div className="flex justify-start">
              <button
                onClick={handleBack}
                className="px-4 py-2 border border-border rounded-md text-on-surface hover:bg-surface-hover"
              >
                Retour au menu
              </button>
            </div>
          </>
        )}

        {phase === 'extrait' && (
          <>
            <ExtraitTransactionGrid
              transactions={transactions}
              summary={summary}
              isLoading={isLoadingExtrait}
            />

            <div className="flex gap-3 justify-between">
              <button
                onClick={handleBack}
                className="px-4 py-2 border border-border rounded-md text-on-surface hover:bg-surface-hover"
              >
                Nouvelle recherche
              </button>
              <div className="flex gap-3">
                <button
                  onClick={() => setShowEmailDialog(true)}
                  className="px-4 py-2 border border-border rounded-md text-on-surface hover:bg-surface-hover"
                >
                  Envoyer par email
                </button>
                <button
                  onClick={() => setShowFormatDialog(true)}
                  className="px-4 py-2 bg-primary text-white rounded-md hover:bg-primary-dark"
                >
                  Imprimer
                </button>
              </div>
            </div>

            <ExtraitFormatDialog
              open={showFormatDialog}
              onClose={() => setShowFormatDialog(false)}
              onSelectFormat={handlePrintFormat}
              isPrinting={isPrinting}
            />

            <EmailSendDialog
              open={showEmailDialog}
              onClose={() => setShowEmailDialog(false)}
              documentType="extrait"
              documentId={selectedAccount ? String(selectedAccount.codeAdherent) : ''}
            />
          </>
        )}
      </div>
    </ScreenLayout>
  );
}

```