Generate Vitest unit tests for the "ticketFermetureSessionStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  RecapFermetureSession,
  MontantComptable,
  LoadRecapDataRequest,
  LoadMontantsRequest,
  GenerateTicketRequest,
  PrinterOption,
} from '@/types/ticketFermetureSession';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface TicketFermetureSessionState {
  recapData: RecapFermetureSession | null;
  montantsComptables: MontantComptable[];
  isLoading: boolean;
  error: string | null;
  finTache: string;
  printerNum: PrinterOption;
}

interface TicketFermetureSessionActions {
  loadRecapData: (societe: string, session: number) => Promise<void>;
  loadMontantsComptables: (societe: string, session: number) => Promise<void>;
  generateTicketFermeture: (
    societe: string,
    session: number,
    dateComptable: Date,
  ) => Promise<void>;
  validateFinTache: (finTache: string) => boolean;
  selectPrinter: (printerNum: PrinterOption) => void;
  reset: () => void;
}

type TicketFermetureSessionStore = TicketFermetureSessionState &
  TicketFermetureSessionActions;

const MOCK_RECAP: RecapFermetureSession = {
  societe: 'SOC1',
  session: 142,
  dateComptable: new Date('2026-02-08'),
  heureDebutSession: '08:00',
  caisseDepart: 500,
  apportCoffre: 2000,
  versement: 1500,
  retrait: 300,
  soldeCash: 3200,
  soldeCarte: 1850,
  change: 450,
  fraisChange: 15,
  deviseLocale: 'EUR',
  nomVillage: 'Club Med Peisey-Vallandry',
  editionDetaillee: true,
};

const MOCK_MONTANTS: MontantComptable[] = [
  {
    cumulQuantite: 12,
    cumulMontant: 540,
    totalMontant: 540,
    equivalent: 540,
  },
  {
    cumulQuantite: 8,
    cumulMontant: 320,
    totalMontant: 320,
    equivalent: 320,
  },
  {
    cumulQuantite: 5,
    cumulMontant: 175,
    totalMontant: 175,
    equivalent: 175,
  },
];

const initialState: TicketFermetureSessionState = {
  recapData: null,
  montantsComptables: [],
  isLoading: false,
  error: null,
  finTache: '',
  printerNum: 1,
};

export const useTicketFermetureSessionStore = create<TicketFermetureSessionStore>()(
  (set, get) => ({
    ...initialState,

    loadRecapData: async (societe, session) => {
      const { isRealApi } = useDataSourceStore.getState();
      set({ isLoading: true, error: null });

      if (!isRealApi) {
        set({
          recapData: { ...MOCK_RECAP, societe, session },
          isLoading: false,
        });
        return;
      }

      try {
        const response = await apiClient.get<
          ApiResponse<RecapFermetureSession>
        >('/api/ticketFermetureSession/recap', {
          params: { societe, session },
        });
        set({ recapData: response.data.data ?? null });
      } catch (e: unknown) {
        const message =
          e instanceof Error ? e.message : 'Erreur chargement récapitulatif';
        set({ recapData: null, error: message });
      } finally {
        set({ isLoading: false });
      }
    },

    loadMontantsComptables: async (societe, session) => {
      const { isRealApi } = useDataSourceStore.getState();
      set({ isLoading: true, error: null });

      if (!isRealApi) {
        set({
          montantsComptables: MOCK_MONTANTS,
          isLoading: false,
        });
        return;
      }

      try {
        const response = await apiClient.get<ApiResponse<MontantComptable[]>>(
          '/api/ticketFermetureSession/montants',
          {
            params: { societe, session },
          },
        );
        set({ montantsComptables: response.data.data ?? [] });
      } catch (e: unknown) {
        const message =
          e instanceof Error ? e.message : 'Erreur chargement montants';
        set({ montantsComptables: [], error: message });
      } finally {
        set({ isLoading: false });
      }
    },

    generateTicketFermeture: async (societe, session, dateComptable) => {
      const { isRealApi } = useDataSourceStore.getState();
      const { finTache, printerNum } = get();

      if (!get().validateFinTache(finTache)) {
        set({
          error:
            'La tâche doit être marquée comme terminée (finTache = "F") avant de générer le ticket',
        });
        return;
      }

      set({ isLoading: true, error: null });

      if (!isRealApi) {
        set({ isLoading: false });
        return;
      }

      try {
        await apiClient.post<ApiResponse<void>>(
          '/api/ticketFermetureSession/generate',
          {
            societe,
            session,
            dateComptable,
            printerNum,
          },
        );
      } catch (e: unknown) {
        const message =
          e instanceof Error ? e.message : 'Erreur génération ticket';
        set({ error: message });
      } finally {
        set({ isLoading: false });
      }
    },

    validateFinTache: (finTache) => {
      return finTache === 'F';
    },

    selectPrinter: (printerNum) => {
      set({ printerNum });
    },

    reset: () => set({ ...initialState }),
  }),
);

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export interface RecapFermetureSession {
  societe: string;
  session: number;
  dateComptable: Date;
  heureDebutSession: string;
  caisseDepart: number;
  apportCoffre: number;
  versement: number;
  retrait: number;
  soldeCash: number;
  soldeCarte: number;
  change: number;
  fraisChange: number;
  deviseLocale: string;
  nomVillage: string;
  editionDetaillee: boolean;
}

export interface MontantComptable {
  cumulQuantite: number;
  cumulMontant: number;
  totalMontant: number;
  equivalent: number;
}

export interface TicketFermetureSessionState {
  recapData: RecapFermetureSession | null;
  montantsComptables: MontantComptable[];
  isLoading: boolean;
  error: string | null;
  finTache: string;
  printerNum: number;
}

export interface LoadRecapDataRequest {
  societe: string;
  session: number;
}

export interface LoadRecapDataResponse extends ApiResponse<RecapFermetureSession> {}

export interface LoadMontantsRequest {
  societe: string;
  session: number;
}

export interface LoadMontantsResponse extends ApiResponse<MontantComptable[]> {}

export interface GenerateTicketRequest {
  societe: string;
  session: number;
  dateComptable: Date;
  printerNum: number;
}

export interface GenerateTicketResponse extends ApiResponse<void> {}

export interface ValidateFinTacheRequest {
  finTache: string;
}

export interface ValidateFinTacheResponse extends ApiResponse<boolean> {}

export interface SelectPrinterRequest {
  printerNum: number;
}

export type PrinterOption = 1 | 9;

export const PRINTER_OPTIONS = {
  PRIMARY: 1,
  SECONDARY: 9,
} as const;

export const BUSINESS_RULES = {
  FIN_TACHE_VALIDATION: 'RM-001: Vérifier que W0_fin_tache === "F" avant de procéder',
  PRIMARY_PRINTER: 'RM-002: Si CURRENTPRINTERNUM === 1, utiliser l\'imprimante principale',
  SECONDARY_PRINTER: 'RM-003: Si CURRENTPRINTERNUM === 9, utiliser l\'imprimante secondaire',
} as const;

ACTIONS TO COVER:
[
  {
    "name": "generateTicketFermeture",
    "params": [
      "societe: string",
      "session: number",
      "dateComptable: Date"
    ],
    "businessRules": [
      "RM-001: Vérifier que W0_fin_tache === 'F' avant de procéder",
      "RM-002: Si CURRENTPRINTERNUM === 1, utiliser l'imprimante principale",
      "RM-003: Si CURRENTPRINTERNUM === 9, utiliser l'imprimante secondaire"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "loadRecapData",
    "params": [
      "societe: string",
      "session: number"
    ],
    "businessRules": [
      "Charger les données depuis histo_sessions_caisse_detail",
      "Récupérer la devise locale depuis devise_in",
      "Calculer les montants comptables depuis cc_comptable"
    ],
    "returns": "Promise<RecapFermetureSession>"
  },
  {
    "name": "validateFinTache",
    "params": [
      "finTache: string"
    ],
    "businessRules": [
      "RM-001: Condition W0_fin_tache === 'F' doit être vraie pour continuer"
    ],
    "returns": "boolean"
  },
  {
    "name": "selectPrinter",
    "params": [
      "printerNum: number"
    ],
    "businessRules": [
      "RM-002: Si printerNum === 1, utiliser imprimante principale",
      "RM-003: Si printerNum === 9, utiliser imprimante secondaire"
    ],
    "returns": "void"
  }
]