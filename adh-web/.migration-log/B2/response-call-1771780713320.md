```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useCharacterValidationStore } from '@/stores/characterValidationStore';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type { ApiResponse } from '@/services/api/apiClient';
import type { ValidateCharactersResponse, ForbiddenCharactersResponse } from '@/types/characterValidation';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    post: vi.fn(),
    get: vi.fn(),
  },
}));

const MOCK_FORBIDDEN_CHARS = [
  '@', '#', '$', '%', '&', '*', '<', '>', '|', '\\', '/', '?', '"', "'",
  '\n', '\r', '\t', '\0', '\x01', '\x02', '\x03',
];

describe('characterValidationStore', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    useCharacterValidationStore.getState().reset();
    useDataSourceStore.setState({ isRealApi: false });
  });

  describe('validateCharacters', () => {
    it('should validate string with invalid characters in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const result = await store.validateCharacters('test@email.com');
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(4);
      expect(useCharacterValidationStore.getState().lastValidationResult).toEqual(result);
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });

    it('should validate string with no invalid characters in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const result = await store.validateCharacters('valid-name');
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
      expect(useCharacterValidationStore.getState().lastValidationResult).toEqual(result);
    });

    it('should detect multiple invalid characters in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const result = await store.validateCharacters('special$char%here');
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('$%');
      expect(result.position).toBe(7);
    });

    it('should return valid result for unknown string in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const result = await store.validateCharacters('unknown-input');
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });

    it('should set isValidating during API call in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const promise = store.validateCharacters('test');
      
      await vi.waitFor(() => {
        expect(useCharacterValidationStore.getState().isValidating).toBe(true);
      });
      
      await promise;
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });

    it('should validate string via API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<ValidateCharactersResponse> = {
        data: {
          result: {
            isValid: false,
            invalidCharacters: '@',
            position: 5,
          },
        },
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce(mockResponse);
      
      const store = useCharacterValidationStore.getState();
      const result = await store.validateCharacters('email@domain.com');
      
      expect(apiClient.post).toHaveBeenCalledWith('/api/validation/check-string', {
        input: 'email@domain.com',
      });
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(5);
      expect(useCharacterValidationStore.getState().lastValidationResult).toEqual(result);
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });

    it('should handle API error in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const errorMessage = 'Network error';
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error(errorMessage));
      
      const store = useCharacterValidationStore.getState();
      const result = await store.validateCharacters('test-input');
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
      expect(useCharacterValidationStore.getState().error).toBe(errorMessage);
      expect(useCharacterValidationStore.getState().lastValidationResult).toBe(null);
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });

    it('should handle API error with unknown error type', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce('Unknown error');
      
      const store = useCharacterValidationStore.getState();
      await store.validateCharacters('test-input');
      
      expect(useCharacterValidationStore.getState().error).toBe('Erreur validation caractères');
    });

    it('should handle missing data in API response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<ValidateCharactersResponse> = {
        data: undefined,
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce(mockResponse);
      
      const store = useCharacterValidationStore.getState();
      const result = await store.validateCharacters('test');
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });
  });

  describe('loadForbiddenCharacters', () => {
    it('should load forbidden characters in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      await store.loadForbiddenCharacters();
      
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toEqual(MOCK_FORBIDDEN_CHARS);
      expect(useCharacterValidationStore.getState().forbiddenCharacters.length).toBe(21);
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toContain('@');
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toContain('$');
    });

    it('should load forbidden characters via API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<ForbiddenCharactersResponse> = {
        data: {
          characters: ['@', '#', '$'],
        },
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce(mockResponse);
      
      const store = useCharacterValidationStore.getState();
      await store.loadForbiddenCharacters();
      
      expect(apiClient.get).toHaveBeenCalledWith('/api/validation/forbidden-characters');
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toEqual(['@', '#', '$']);
      expect(useCharacterValidationStore.getState().error).toBe(null);
    });

    it('should handle API error when loading forbidden characters', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const errorMessage = 'Failed to load';
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error(errorMessage));
      
      const store = useCharacterValidationStore.getState();
      await store.loadForbiddenCharacters();
      
      expect(useCharacterValidationStore.getState().error).toBe(errorMessage);
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toEqual([]);
    });

    it('should handle unknown error type when loading forbidden characters', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce('Unknown error');
      
      const store = useCharacterValidationStore.getState();
      await store.loadForbiddenCharacters();
      
      expect(useCharacterValidationStore.getState().error).toBe('Erreur chargement caractères interdits');
    });

    it('should handle missing data in API response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<ForbiddenCharactersResponse> = {
        data: undefined,
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce(mockResponse);
      
      const store = useCharacterValidationStore.getState();
      await store.loadForbiddenCharacters();
      
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toEqual([]);
    });
  });

  describe('checkString', () => {
    it('should detect invalid character at first position', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#', '$'];
      
      const result = store.checkString('@username', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(0);
      expect(useCharacterValidationStore.getState().lastValidationResult).toEqual(result);
    });

    it('should detect invalid character in middle of string', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#', '$'];
      
      const result = store.checkString('user@name', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(4);
    });

    it('should detect multiple different invalid characters', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#', '$', '%'];
      
      const result = store.checkString('test@user#name$end', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@#$');
      expect(result.position).toBe(4);
    });

    it('should only list each invalid character once', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@'];
      
      const result = store.checkString('test@@user@@name', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(4);
    });

    it('should return valid result for string with no invalid characters', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#', '$'];
      
      const result = store.checkString('validusername', forbiddenChars);
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });

    it('should handle empty string', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#'];
      
      const result = store.checkString('', forbiddenChars);
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });

    it('should handle empty forbidden characters list', () => {
      const store = useCharacterValidationStore.getState();
      
      const result = store.checkString('any@text#here', []);
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });

    it('should detect special characters like newline and tab', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['\n', '\t', '\r'];
      
      const result = store.checkString('line1\nline2\ttab', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('\n\t');
      expect(result.position).toBe(5);
    });
  });

  describe('setError', () => {
    it('should set error message', () => {
      const store = useCharacterValidationStore.getState();
      
      store.setError('Custom error message');
      
      expect(useCharacterValidationStore.getState().error).toBe('Custom error message');
    });

    it('should clear error message', () => {
      const store = useCharacterValidationStore.getState();
      store.setError('Error');
      
      store.setError(null);
      
      expect(useCharacterValidationStore.getState().error).toBe(null);
    });
  });

  describe('setIsValidating', () => {
    it('should set isValidating to true', () => {
      const store = useCharacterValidationStore.getState();
      
      store.setIsValidating(true);
      
      expect(useCharacterValidationStore.getState().isValidating).toBe(true);
    });

    it('should set isValidating to false', () => {
      const store = useCharacterValidationStore.getState();
      store.setIsValidating(true);
      
      store.setIsValidating(false);
      
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      const store = useCharacterValidationStore.getState();
      store.setError('Error message');
      store.setIsValidating(true);
      store.checkString('test@email', ['@']);
      useCharacterValidationStore.setState({ forbiddenCharacters: ['@', '#'] });
      
      store.reset();
      
      const state = useCharacterValidationStore.getState();
      expect(state.forbiddenCharacters).toEqual([]);
      expect(state.lastValidationResult).toBe(null);
      expect(state.isValidating).toBe(false);
      expect(state.error).toBe(null);
    });
  });
});
```