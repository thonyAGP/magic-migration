```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { renderHook, act, waitFor } from "@testing-library/react";
import { useGestionCaisseStore } from "@/stores/gestionCaisseStore";
import { apiClient } from "@/services/api/apiClient";
import type { ApiResponse } from "@/services/api/apiClient";
import type {
  CaisseParameters,
  CaisseSession,
  DateComptable,
  CaisseControl,
  CaisseConcurrence,
  CaisseMovement,
} from "@/types/gestionCaisse";

vi.mock("@/services/api/apiClient");

const MOCK_PARAMETRES: CaisseParameters = {
  numeroPoste: 1,
  nomPoste: "CAISSE_01",
  deviseLocale: "EUR",
  seuilAlerte: 500,
  imprimanteTicket: "PRINTER_01",
  imprimanteRapport: "PRINTER_02",
};

const MOCK_SESSION_ACTIVE: CaisseSession = {
  sessionId: 123,
  numeroPoste: 1,
  dateOuverture: "2026-02-22T08:00:00",
  dateFermeture: null,
  statut: "ouverte",
  operateurOuverture: "OP001",
  operateurFermeture: null,
};

const MOCK_DATE_COMPTABLE: DateComptable = {
  dateComptable: "2026-02-22",
  journeeOuverte: true,
};

const MOCK_CONTROLE_COFFRE: CaisseControl = {
  sessionId: 123,
  integrite: true,
  messageErreur: null,
};

const MOCK_CONCURRENCES: CaisseConcurrence[] = [
  {
    numeroPoste: 2,
    operateur: "OP002",
    dateOuverture: "2026-02-22T08:30:00",
  },
];

const MOCK_MOVEMENT: CaisseMovement = {
  movementId: 456,
  sessionId: 123,
  type: "apport_especes",
  montant: 200,
  deviseCode: "EUR",
  dateCreation: "2026-02-22T09:00:00",
};

describe("gestionCaisseStore", () => {
  beforeEach(() => {
    const { getState } = useGestionCaisseStore;
    act(() => {
      getState().parametres = null;
      getState().sessionActive = null;
      getState().dateComptable = null;
      getState().controlesCoffre = [];
      getState().concurrences = [];
      getState().loading = false;
      getState().error = null;
    });
    vi.clearAllMocks();
  });

  describe("chargerParametres", () => {
    it("should load caisse parameters successfully", async () => {
      const mockResponse: ApiResponse<CaisseParameters> = {
        success: true,
        data: MOCK_PARAMETRES,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.chargerParametres();
      });

      expect(apiClient.get).toHaveBeenCalledWith("/api/caisse/parametres");
      expect(result.current.parametres).toEqual(MOCK_PARAMETRES);
      expect(result.current.loading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it("should set error when loading parameters fails", async () => {
      const mockError: ApiResponse<CaisseParameters> = {
        success: false,
        error: "Configuration caisse invalide",
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.chargerParametres();
      });

      expect(result.current.parametres).toBeNull();
      expect(result.current.error).toBe("Configuration caisse invalide");
      expect(result.current.loading).toBe(false);
    });

    it("should set loading state during fetch", async () => {
      const mockResponse: ApiResponse<CaisseParameters> = {
        success: true,
        data: MOCK_PARAMETRES,
      };
      vi.mocked(apiClient.get).mockImplementation(
        () =>
          new Promise((resolve) =>
            setTimeout(() => resolve(mockResponse), 100)
          )
      );

      const { result } = renderHook(() => useGestionCaisseStore());

      act(() => {
        void result.current.chargerParametres();
      });

      expect(result.current.loading).toBe(true);

      await waitFor(() => {
        expect(result.current.loading).toBe(false);
      });
    });
  });

  describe("chargerSessionActive", () => {
    it("should load active session and validate integrity", async () => {
      const mockSessionResponse: ApiResponse<CaisseSession> = {
        success: true,
        data: MOCK_SESSION_ACTIVE,
      };
      const mockIntegriteResponse: ApiResponse<{ valide: boolean }> = {
        success: true,
        data: { valide: true },
      };

      vi.mocked(apiClient.get)
        .mockResolvedValueOnce(mockSessionResponse)
        .mockResolvedValueOnce(mockIntegriteResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.chargerSessionActive();
      });

      expect(apiClient.get).toHaveBeenCalledWith("/api/caisse/session/active");
      expect(apiClient.get).toHaveBeenCalledWith("/api/caisse/integrite-dates");
      expect(result.current.sessionActive).toEqual(MOCK_SESSION_ACTIVE);
      expect(result.current.error).toBeNull();
    });

    it("should handle closed session", async () => {
      const closedSession: CaisseSession = {
        ...MOCK_SESSION_ACTIVE,
        statut: "fermee",
        dateFermeture: "2026-02-22T17:00:00",
      };
      const mockResponse: ApiResponse<CaisseSession> = {
        success: true,
        data: closedSession,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.chargerSessionActive();
      });

      expect(result.current.sessionActive?.statut).toBe("fermee");
    });

    it("should handle error when loading session", async () => {
      const mockError: ApiResponse<CaisseSession> = {
        success: false,
        error: "Session introuvable",
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.chargerSessionActive();
      });

      expect(result.current.sessionActive).toBeNull();
      expect(result.current.error).toBe("Session introuvable");
    });
  });

  describe("verifierDateComptable", () => {
    it("should verify accounting date is open", async () => {
      const mockResponse: ApiResponse<DateComptable> = {
        success: true,
        data: MOCK_DATE_COMPTABLE,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.verifierDateComptable();
      });

      expect(apiClient.get).toHaveBeenCalledWith("/api/caisse/date-comptable");
      expect(result.current.dateComptable).toEqual(MOCK_DATE_COMPTABLE);
      expect(result.current.dateComptable?.journeeOuverte).toBe(true);
    });

    it("should detect closed accounting day", async () => {
      const closedDate: DateComptable = {
        dateComptable: "2026-02-21",
        journeeOuverte: false,
      };
      const mockResponse: ApiResponse<DateComptable> = {
        success: true,
        data: closedDate,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.verifierDateComptable();
      });

      expect(result.current.dateComptable?.journeeOuverte).toBe(false);
    });
  });

  describe("controlerCoffre", () => {
    it("should verify cash box integrity successfully", async () => {
      const mockResponse: ApiResponse<CaisseControl> = {
        success: true,
        data: MOCK_CONTROLE_COFFRE,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.controlerCoffre();
      });

      expect(apiClient.get).toHaveBeenCalledWith("/api/caisse/controle-coffre");
      expect(result.current.controlesCoffre).toHaveLength(1);
      expect(result.current.controlesCoffre[0].integrite).toBe(true);
    });

    it("should detect integrity errors", async () => {
      const errorControl: CaisseControl = {
        sessionId: 123,
        integrite: false,
        messageErreur: "Ecart detecte dans sessions_coffre2",
      };
      const mockResponse: ApiResponse<CaisseControl> = {
        success: true,
        data: errorControl,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.controlerCoffre();
      });

      expect(result.current.controlesCoffre[0].integrite).toBe(false);
      expect(result.current.controlesCoffre[0].messageErreur).toBeTruthy();
    });
  });

  describe("detecterSessionsConcurrentes", () => {
    it("should detect concurrent sessions", async () => {
      const mockResponse: ApiResponse<CaisseConcurrence[]> = {
        success: true,
        data: MOCK_CONCURRENCES,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.detecterSessionsConcurrentes();
      });

      expect(apiClient.get).toHaveBeenCalledWith(
        "/api/caisse/concurrences"
      );
      expect(result.current.concurrences).toHaveLength(1);
      expect(result.current.concurrences[0].numeroPoste).toBe(2);
    });

    it("should handle no concurrent sessions", async () => {
      const mockResponse: ApiResponse<CaisseConcurrence[]> = {
        success: true,
        data: [],
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.detecterSessionsConcurrentes();
      });

      expect(result.current.concurrences).toHaveLength(0);
    });
  });

  describe("ouvrirSession", () => {
    it("should open new session successfully", async () => {
      const mockResponse: ApiResponse<CaisseSession> = {
        success: true,
        data: MOCK_SESSION_ACTIVE,
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.ouvrirSession();
      });

      expect(apiClient.post).toHaveBeenCalledWith("/api/caisse/session/ouvrir");
      expect(result.current.sessionActive).toEqual(MOCK_SESSION_ACTIVE);
      expect(result.current.error).toBeNull();
    });

    it("should reject opening when closure in progress", async () => {
      const mockError: ApiResponse<CaisseSession> = {
        success: false,
        error: "Cloture reseau en cours",
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.ouvrirSession();
      });

      expect(result.current.sessionActive).toBeNull();
      expect(result.current.error).toBe("Cloture reseau en cours");
    });

    it("should reject opening when stock incoherence detected", async () => {
      const mockError: ApiResponse<CaisseSession> = {
        success: false,
        error: "Incoherence stock monnaie detectee",
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.ouvrirSession();
      });

      expect(result.current.error).toContain("Incoherence");
    });
  });

  describe("apportCoffre", () => {
    it("should record cash deposit successfully", async () => {
      const mockResponse: ApiResponse<CaisseMovement> = {
        success: true,
        data: MOCK_MOVEMENT,
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.apportCoffre(200, "EUR");
      });

      expect(apiClient.post).toHaveBeenCalledWith("/api/caisse/apport-coffre", {
        montant: 200,
        deviseCode: "EUR",
      });
      expect(result.current.error).toBeNull();
    });

    it("should reject negative amounts", async () => {
      const mockError: ApiResponse<CaisseMovement> = {
        success: false,
        error: "Montant invalide",
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.apportCoffre(-100, "EUR");
      });

      expect(result.current.error).toBe("Montant invalide");
    });
  });

  describe("apportProduit", () => {
    it("should record product supply successfully", async () => {
      const mockResponse: ApiResponse<CaisseMovement> = {
        success: true,
        data: { ...MOCK_MOVEMENT, type: "apport_produit" },
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.apportProduit(101, 50);
      });

      expect(apiClient.post).toHaveBeenCalledWith("/api/caisse/apport-produit", {
        produitId: 101,
        quantite: 50,
      });
      expect(result.current.error).toBeNull();
    });

    it("should reject invalid product ID", async () => {
      const mockError: ApiResponse<CaisseMovement> = {
        success: false,
        error: "Produit introuvable",
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.apportProduit(999, 10);
      });

      expect(result.current.error).toBe("Produit introuvable");
    });
  });

  describe("remiseCoffre", () => {
    it("should record cash withdrawal successfully", async () => {
      const mockResponse: ApiResponse<CaisseMovement> = {
        success: true,
        data: { ...MOCK_MOVEMENT, type: "remise_coffre" },
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.remiseCoffre(300, "EUR");
      });

      expect(apiClient.post).toHaveBeenCalledWith("/api/caisse/remise-coffre", {
        montant: 300,
        deviseCode: "EUR",
      });
      expect(result.current.error).toBeNull();
    });
  });

  describe("fermerSession", () => {
    it("should close session successfully", async () => {
      const closedSession: CaisseSession = {
        ...MOCK_SESSION_ACTIVE,
        statut: "fermee",
        dateFermeture: "2026-02-22T17:00:00",
      };
      const mockResponse: ApiResponse<CaisseSession> = {
        success: true,
        data: closedSession,
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.fermerSession();
      });

      expect(apiClient.post).toHaveBeenCalledWith("/api/caisse/session/fermer");
      expect(result.current.sessionActive?.statut).toBe("fermee");
      expect(result.current.error).toBeNull();
    });

    it("should detect cash box discrepancies", async () => {
      const mockError: ApiResponse<CaisseSession> = {
        success: false,
        error: "Ecart detecte: attendu 500 EUR, reel 480 EUR",
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.fermerSession();
      });

      expect(result.current.error).toContain("Ecart detecte");
    });
  });

  describe("consulterHistorique", () => {
    it("should load session history", async () => {
      const mockSessions: CaisseSession[] = [
        MOCK_SESSION_ACTIVE,
        { ...MOCK_SESSION_ACTIVE, sessionId: 122, statut: "fermee" },
      ];
      const mockResponse: ApiResponse<CaisseSession[]> = {
        success: true,
        data: mockSessions,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.consulterHistorique();
      });

      expect(apiClient.get).toHaveBeenCalledWith("/api/caisse/historique");
      expect(result.current.error).toBeNull();
    });
  });

  describe("consulterSession", () => {
    it("should load specific session details", async () => {
      const mockResponse: ApiResponse<CaisseSession> = {
        success: true,
        data: MOCK_SESSION_ACTIVE,
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.consulterSession(123);
      });

      expect(apiClient.get).toHaveBeenCalledWith("/api/caisse/session/123");
      expect(result.current.error).toBeNull();
    });

    it("should handle session not found", async () => {
      const mockError: ApiResponse<CaisseSession> = {
        success: false,
        error: "Session 999 introuvable",
      };
      vi.mocked(apiClient.get).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.consulterSession(999);
      });

      expect(result.current.error).toBe("Session 999 introuvable");
    });
  });

  describe("reimprimerTickets", () => {
    it("should reprint session tickets successfully", async () => {
      const mockResponse: ApiResponse<{ success: boolean }> = {
        success: true,
        data: { success: true },
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockResponse);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.reimprimerTickets(123);
      });

      expect(apiClient.post).toHaveBeenCalledWith(
        "/api/caisse/reimprimer-tickets",
        { sessionId: 123 }
      );
      expect(result.current.error).toBeNull();
    });

    it("should handle printer errors", async () => {
      const mockError: ApiResponse<{ success: boolean }> = {
        success: false,
        error: "Imprimante non disponible",
      };
      vi.mocked(apiClient.post).mockResolvedValue(mockError);

      const { result } = renderHook(() => useGestionCaisseStore());

      await act(async () => {
        await result.current.reimprimerTickets(123);
      });

      expect(result.current.error).toBe("Imprimante non disponible");
    });
  });
});
```