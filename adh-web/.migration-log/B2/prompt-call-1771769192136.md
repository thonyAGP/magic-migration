Generate Vitest unit tests for the "sessionListStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  Session,
  SessionFilter,
  GetSessionsListRequest,
  GetSessionsListResponse,
} from '@/types/sessionList';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface SessionListState {
  sessions: Session[];
  isLoading: boolean;
  error: string | null;
  filters: SessionFilter;
}

interface SessionListActions {
  fetchSessions: (filters: SessionFilter) => Promise<void>;
  setFilters: (filters: Partial<SessionFilter>) => void;
  clearError: () => void;
  reset: () => void;
}

type SessionListStore = SessionListState & SessionListActions;

const MOCK_SESSIONS: Session[] = [
  {
    id: 1,
    societe: 'CAI001',
    caisse: 'CAISSE_01',
    operateur: 'MARTIN',
    dateOuverture: new Date('2026-02-21T08:00:00'),
    etat: 'O',
    montantOuverture: 500.00,
  },
  {
    id: 2,
    societe: 'CAI001',
    caisse: 'CAISSE_02',
    operateur: 'DUPONT',
    dateOuverture: new Date('2026-02-21T08:15:00'),
    etat: 'O',
    montantOuverture: 300.00,
  },
  {
    id: 3,
    societe: 'CAI001',
    caisse: 'CAISSE_01',
    operateur: 'BERNARD',
    dateOuverture: new Date('2026-02-20T08:00:00'),
    etat: '',
    montantOuverture: 450.00,
  },
  {
    id: 4,
    societe: 'CAI002',
    caisse: 'CAISSE_03',
    operateur: 'LEFEVRE',
    dateOuverture: new Date('2026-02-21T09:00:00'),
    etat: 'O',
    montantOuverture: 600.00,
  },
  {
    id: 5,
    societe: 'CAI002',
    caisse: 'CAISSE_04',
    operateur: 'ROUSSEAU',
    dateOuverture: new Date('2026-02-20T14:00:00'),
    etat: '',
    montantOuverture: null,
  },
];

const initialState: SessionListState = {
  sessions: [],
  isLoading: false,
  error: null,
  filters: {
    existeSession: true,
    existeSessionOuverte: true,
    societe: null,
    deviseLocale: null,
  },
};

export const useSessionListStore = create<SessionListStore>()((set, get) => ({
  ...initialState,

  fetchSessions: async (filters) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      let filtered = [...MOCK_SESSIONS];

      if (filters.societe) {
        filtered = filtered.filter((s) => s.societe === filters.societe);
      }

      if (filters.existeSessionOuverte) {
        filtered = filtered.filter((s) => s.etat === 'O');
      } else if (filters.existeSession) {
        filtered = filtered.filter((s) => s.etat === '' || s.etat === 'O');
      }

      set({ sessions: filtered, isLoading: false });
      return;
    }

    try {
      const params: GetSessionsListRequest = {};

      if (filters.societe) {
        params.societe = filters.societe;
      }
      if (filters.existeSession !== undefined) {
        params.existeSession = filters.existeSession;
      }
      if (filters.existeSessionOuverte !== undefined) {
        params.existeSessionOuverte = filters.existeSessionOuverte;
      }
      if (filters.deviseLocale) {
        params.deviseLocale = filters.deviseLocale;
      }

      const response: ApiResponse<GetSessionsListResponse> = await apiClient.get(
        '/api/sessions/list',
        { params },
      );

      const sessions = (response.data.data ?? []).map((s) => ({
        ...s,
        dateOuverture: new Date(s.dateOuverture),
      }));

      set({ sessions, isLoading: false });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement sessions';
      set({ sessions: [], error: message, isLoading: false });
    }
  },

  setFilters: (newFilters) => {
    const currentFilters = get().filters;
    const updatedFilters = { ...currentFilters, ...newFilters };
    set({ filters: updatedFilters });
    get().fetchSessions(updatedFilters);
  },

  clearError: () => set({ error: null }),

  reset: () => set({ ...initialState }),
}));

TYPES:
export interface Session {
  id: number;
  societe: string;
  caisse: string;
  operateur: string;
  dateOuverture: Date;
  etat: string;
  montantOuverture: number | null;
}

export interface SessionFilter {
  existeSession: boolean;
  existeSessionOuverte: boolean;
  societe: string | null;
  deviseLocale: string | null;
}

export interface SessionListState {
  sessions: Session[];
  isLoading: boolean;
  error: string | null;
  filters: SessionFilter;
  fetchSessions: (filters: SessionFilter) => Promise<void>;
  setFilters: (filters: Partial<SessionFilter>) => void;
  clearError: () => void;
}

export interface GetSessionsListRequest {
  societe?: string;
  existeSession?: boolean;
  existeSessionOuverte?: boolean;
  deviseLocale?: string;
}

export type GetSessionsListResponse = Session[];

export const SESSION_STATE_EMPTY = '';
export const SESSION_STATE_OPEN = 'O';

export const SESSION_FILTER_DEFAULTS = {
  existeSession: true,
  existeSessionOuverte: true,
  societe: null,
  deviseLocale: null,
} as const satisfies SessionFilter;

ACTIONS TO COVER:
[
  {
    "name": "fetchSessions",
    "params": [
      "filters: SessionFilter"
    ],
    "businessRules": [
      "RM-003: Filter sessions where existeSession is true",
      "RM-004: Filter sessions where existeSessionOuverte is true",
      "RM-001: Check if session state (etat) is empty string",
      "RM-002: Check if session state (etat) equals 'O' (ouvert)"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "setFilters",
    "params": [
      "filters: Partial<SessionFilter>"
    ],
    "businessRules": [
      "Update filter state and trigger data refresh"
    ],
    "returns": "void"
  },
  {
    "name": "clearError",
    "params": [],
    "businessRules": [
      "Clear error state"
    ],
    "returns": "void"
  }
]