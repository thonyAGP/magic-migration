Generate Vitest unit tests for the "deviseSessionStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type { UpdateDeviseSessionRequest, DeviseSes sionState } from '@/types/deviseSession';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface DeviseSessionActions {
  updateDeviseSession: (
    codeDevise: string,
    modePaiement: string,
    quand: string,
    type: string,
    quantite: number,
    cumulOpChange: boolean,
  ) => Promise<void>;
  reset: () => void;
}

type DeviseSessionStore = DeviseSes sionState & DeviseSessionActions;

const initialState: Omit<DeviseSes sionState, 'updateDeviseSession'> = {
  isLoading: false,
  error: null,
};

export const useDeviseSessionStore = create<DeviseSessionStore>()((set) => ({
  ...initialState,

  updateDeviseSession: async (
    codeDevise,
    modePaiement,
    quand,
    type,
    quantite,
    cumulOpChange,
  ) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({ isLoading: false });
      return;
    }

    try {
      const payload: UpdateDeviseSessionRequest = {
        codeDevise,
        modePaiement,
        quand,
        type,
        quantite,
        cumulOpChange,
      };

      await apiClient.put('/api/caisse/devise-session', payload);
      set({ isLoading: false });
    } catch (e: unknown) {
      const message =
        e instanceof Error ? e.message : 'Erreur mise Ã  jour session devise';
      set({ error: message, isLoading: false });
    }
  },

  reset: () => set({ ...initialState }),
}));

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export interface DeviseSession {
  codeDevise: string;
  modePaiement: string;
  quand: string;
  type: string;
  quantite: number;
  cumulOpChange: boolean;
}

export interface UpdateDeviseSes sionRequest {
  codeDevise: string;
  modePaiement: string;
  quand: string;
  type: string;
  quantite: number;
  cumulOpChange: boolean;
}

export type UpdateDeviseSes sionResponse = void;

export interface DeviseSes sionState {
  isLoading: boolean;
  error: string | null;
  updateDeviseSession: (
    codeDevise: string,
    modePaiement: string,
    quand: string,
    type: string,
    quantite: number,
    cumulOpChange: boolean
  ) => Promise<void>;
}

ACTIONS TO COVER:
[
  {
    "name": "updateDeviseSession",
    "params": [
      "codeDevise: string",
      "modePaiement: string",
      "quand: string",
      "type: string",
      "quantite: number",
      "cumulOpChange: boolean"
    ],
    "businessRules": [
      "RM-001: If cumulOpChange is false, overwrite quantity; otherwise accumulate quantity to existing session record"
    ],
    "returns": "Promise<void>"
  }
]