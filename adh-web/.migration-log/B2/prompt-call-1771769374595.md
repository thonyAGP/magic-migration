Generate a React component: MontantsComptesPanel for the "SaisieContenuCaisse" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

COMPONENT REQUIREMENTS:
- Props interface at the top of the file
- Tailwind v4 classes for styling
- Use shared UI components from @/components/ui/ when applicable (DataGrid, Dialog, etc.)
- Handle loading and empty states

SECTION TO IMPLEMENT:
{
  "name": "montantsComptes",
  "controls": [
    "Label: Montants comptés (lecture seule)",
    "Monnaie comptée",
    "Produits comptés",
    "Cartes comptées",
    "Chèques comptés",
    "OD comptés",
    "Devises comptées"
  ]
}

PAGE (shows how this component is used):
import { useState, useEffect, useCallback } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Button } from '@/components/ui';
import { useSaisieContenuCaisseStore } from '@/stores/saisieContenuCaisseStore';
import { useAuthStore } from '@/stores';
import { cn } from '@/lib/utils';

type Phase = 'comptage' | 'recapitulatif' | 'confirmation';

export const SaisieContenuCaissePage = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const user = useAuthStore((s) => s.user);

  const sessionId = Number(searchParams.get('sessionId')) || null;
  const quand = (searchParams.get('quand') as 'O' | 'F') || null;

  const activeDevise = useSaisieContenuCaisseStore((s) => s.activeDevise);
  const comptageDevises = useSaisieContenuCaisseStore((s) => s.comptageDevises);
  const recapMOP = useSaisieContenuCaisseStore((s) => s.recapMOP);
  const validationResult = useSaisieContenuCaisseStore(
    (s) => s.validationResult,
  );
  const isValidating = useSaisieContenuCaisseStore((s) => s.isValidating);
  const validationError = useSaisieContenuCaisseStore((s) => s.validationError);
  const isPersisting = useSaisieContenuCaisseStore((s) => s.isPersisting);
  const canSubmit = useSaisieContenuCaisseStore((s) => s.canSubmit);
  const devisesAutorisees = useSaisieContenuCaisseStore(
    (s) => s.devisesAutorisees,
  );

  const initComptage = useSaisieContenuCaisseStore((s) => s.initComptage);
  const updateQuantite = useSaisieContenuCaisseStore((s) => s.updateQuantite);
  const switchDevise = useSaisieContenuCaisseStore((s) => s.switchDevise);
  const validateComptage = useSaisieContenuCaisseStore(
    (s) => s.validateComptage,
  );
  const loadRecapMOP = useSaisieContenuCaisseStore((s) => s.loadRecapMOP);
  const persistComptage = useSaisieContenuCaisseStore((s) => s.persistComptage);
  const resetState = useSaisieCont

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export interface Denomination {
  id: number;
  deviseCode: string;
  valeur: number;
  libelle: string;
}

export interface ComptageDetail {
  denominationId: number;
  deviseCode: string;
  valeur: number;
  quantite: number;
  total: number;
}

export interface RecapMOP {
  moyenPaiement: string;
  moyenPaiementLibelle: string;
  attendu: number;
  compte: number;
  ecart: number;
}

export interface DeviseComptage {
  deviseCode: string;
  deviseLibelle: string;
  totalSaisi: number;
  denominations: ComptageDetail[];
}

export interface ValidationResult {
  totalCaisse: number;
  totalMonnaie: number;
  totalProduits: number;
  totalCartes: number;
  totalCheques: number;
  totalOD: number;
  shouldProcess: boolean;
  nbreDevise: number;
  fromIms: boolean;
}

export interface PersistanceResult {
  success: boolean;
  ticketUrl?: string;
  sessionId: number;
  timestamp: string;
}

export interface SaisieContenuCaisseState {
  activeDevise: string | null;
  comptageDevises: Map<string, DeviseComptage>;
  recapMOP: RecapMOP[];
  validationResult: ValidationResult | null;
  isValidating: boolean;
  validationError: string | null;
  isPersisting: boolean;
  canSubmit: boolean;
  devisesAutorisees: string[];
  sessionId: number | null;
  quand: "O" | "F" | null;

  initComptage: (
    sessionId: number,
    quand: "O" | "F",
    devisesAutorisees: string[]
  ) => Promise<void>;

  updateQuantite: (
    deviseCode: string,
    denominationId: number,
    quantite: number
  ) => void;

  switchDevise: (deviseCode: string) => void;

  validateComptage: () => Promise<ValidationResult>;

  loadRecapMOP: (sessionId: number) => Promise<RecapMOP[]>;

  persistComptage: (
    sessionId: number,
    validationResult: ValidationResult
  ) => Promise<PersistanceResult>;

  resetState: () => void;

  setValidationError: (error: string | null) => void;
}

export type GetDenominationsRequest = {
  deviseCode: string;
};

export type GetDenominationsResponse = ApiResponse<Denomination[]>;

export type ValidateComptageRequest = {
  comptageDevises: Record<string, DeviseComptage>;
  nbreDevise: number;
  fromIms: boolean;
};

export type ValidateComptageResponse = ApiResponse<ValidationResult>;

export type GetRecapMOPRequest = {
  sessionId: number;
};

export type GetRecapMOPResponse = ApiResponse<RecapMOP[]>;

export type PersistComptageRequest = {
  sessionId: number;
  validationResult: ValidationResult;
  comptageDevises: Record<string, DeviseComptage>;
  recapMOP: RecapMOP[];
};

export type PersistComptageResponse = ApiResponse<PersistanceResult>;

export const COMPTAGE_ACTION_TYPES = {
  INIT: "INIT_COMPTAGE",
  UPDATE_QUANTITE: "UPDATE_QUANTITE",
  SWITCH_DEVISE: "SWITCH_DEVISE",
  VALIDATE: "VALIDATE_COMPTAGE",
  LOAD_RECAP: "LOAD_RECAP_MOP",
  PERSIST: "PERSIST_COMPTAGE",
  SET_ERROR: "SET_VALIDATION_ERROR",
  RESET: "RESET_STATE",
} as const;

export type ComptageActionType =
  (typeof COMPTAGE_ACTION_TYPES)[keyof typeof COMPTAGE_ACTION_TYPES];

export const MOYEN_PAIEMENT_CODES = {
  MONNAIE: "M",
  CARTES: "C",
  CHEQUES: "CH",
  OD: "OD",
  PRODUITS: "P",
} as const;

export type MoyenPaiementCode =
  (typeof MOYEN_PAIEMENT_CODES)[keyof typeof MOYEN_PAIEMENT_CODES];

export const VALIDATION_RULES = {
  RM_001: "shouldProcess = totalCaisse <> 0 OR nbreDevise <> 0 OR FROM_IMS = 'O'",
  MIN_QUANTITE: 0,
  ECART_TOLERANCE: 0,
} as const;