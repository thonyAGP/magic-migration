Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/choixPyrStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
choixPyrStore fetchHebergements should load hebergements in mock mode and filter by date: AssertionError: expected [ â€¦(3) ] to have a length of 2 but got 3
    at Proxy.<anonymous> (file:///D:/Projects/Lecteur_Magic/adh-web/node_modules/.pnpm/@vitest+expect@4.0.18/node_modules/@vitest/expe
choixPyrStore fetchHebergements should set loading state during fetch: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/choixPyrStore.test.ts:93:36
    at file:///D:/Projects/Lecteur_Magic/adh-web/node
choixPyrStore fetchHebergements should exclude expired hebergements (dateFin < today): AssertionError: expected true to be false // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/choixPyrStore.test.ts:104:26
    at file:///D:/Projects/Lecteur_Magic/adh-web/nod
choixPyrStore selectChambre should set loading state during selection: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/choixPyrStore.test.ts:340:40
    at file:///D:/Projects/Lecteur_Magic/adh-web/nod

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useChoixPyrStore } from '@/stores/choixPyrStore';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { FetchHebergementsResponse, SelectChambreResponse, Hebergement, ClientGm } from '@/types/choixPyr';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    get: vi.fn(),
    post: vi.fn(),
  },
}));

const MOCK_CLIENT: ClientGm = {
  societe: 1,
  compte: 1001,
  filiation: 0,
  nom: 'DUBOIS',
  prenom: 'Marc',
};

const TODAY = new Date('2026-02-22');
const PAST_DATE = new Date('2026-02-15');
const FUTURE_DATE = new Date('2026-02-28');

const MOCK_HEBERGEMENTS: Hebergement[] = [
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '101',
    dateDebut: PAST_DATE,
    dateFin: FUTURE_DATE,
    statut: 'ACTIF',
  },
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '203',
    dateDebut: PAST_DATE,
    dateFin: null,
    statut: 'ACTIF',
  },
];

const EXPIRED_HEBERGEMENT: Hebergement = {
  societe: 1,
  compte: 1001,
  filiation: 0,
  chambre: '305',
  dateDebut: new Date('2026-01-10'),
  dateFin: new Date('2026-02-10'),
  statut: 'ACTIF',
};

describe('choixPyrStore', () => {
  beforeEach(() => {
    useChoixPyrStore.getState().reset();
    useDataSourceStore.setState({ isRealApi: false });
    vi.clearAllMocks();
    vi.setSystemTime(TODAY);
  });

  describe('fetchHebergements', () => {
    it('should load hebergements in mock mode and filter by date', async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();

      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      expect(state.hebergements).toHaveLength(2);
      expect(state.hebergements.find(h => h.chambre === '101')).toBeDefined();
      expect(state.hebergements.find(h => h.chambre === '203')).toBeDefined();
      expect(state.hebergements.find(h => h.chambre === '305')).toBeUndefined();
      expect(state.clientInfo).toEqual(MOCK_CLIENT);
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });

    it('should set loading state during fetch', async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();
      
      let isLoadingDuringFetch = false;
      
      const promise = fetchHebergements(1, 1001, 0);
      
      await new Promise(resolve => setTimeout(resolve, 0));
      isLoadingDuringFetch = useChoixPyrStore.getState().isLoading;
      
      await promise;
      
      expect(isLoadingDuringFetch).toBe(true);
      expect(useChoixPyrStore.getState().isLoading).toBe(false);
    });

    it('should exclude expired hebergements (dateFin < today)', async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();

      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      const hasExpired = state.hebergements.some(h => h.chambre === '305');
      expect(hasExpired).toBe(false);
      expect(state.hebergements.every(h => h.dateFin === null || h.dateFin >= TODAY)).toBe(true);
    });

    it('should include hebergements with null dateFin', async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();

      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      const nullDateFin = state.hebergements.find(h => h.chambre === '203');
      expect(nullDateFin).toBeDefined();
      expect(nullDateFin?.dateFin).toBeNull();
    });

    it('should call API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: FetchHebergementsResponse = {
        success: true,
        data: {
          hebergements: MOCK_HEBERGEMENTS,
          clientInfo: MOCK_CLIENT,
        },
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce({ data: mockResponse });

      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);

      expect(apiClient.get).toHaveBeenCalledWith(
        '/api/choixPyr/hebergements?societe=1&compte=1001&filiation=0'
      );
      const state = useChoixPyrStore.getState();
      expect(state.hebergements).toEqual(MOCK_HEBERGEMENTS);
      expect(state.clientInfo).toEqual(MOCK_CLIENT);
    });

    it('should handle API error', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error('Network error'));

      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Network error');
      expect(state.hebergements).toEqual([]);
      expect(state.clientInfo).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should handle unknown error type', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce('string error');

      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Erreur chargement hebergements');
    });

    it('should handle null data in API response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: FetchHebergementsResponse = {
        success: true,
        data: {
          hebergements: [],
          clientInfo: MOCK_CLIENT,
        },
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce({ data: mockResponse });

      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);

      const state = useChoixPyrStore.getState();
      expect(state.hebergements).toEqual([]);
    });

    it('should clear previous error on new fetch', async () => {
      const store = useChoixPyrStore.getState();
      store.setError('Previous error');
      
      await store.fetchHebergements(1, 1001, 0);

      expect(useChoixPyrStore.getState().error).toBeNull();
    });
  });

  describe('selectChambre', () => {
    beforeEach(async () => {
      const { fetchHebergements } = useChoixPyrStore.getState();
      await fetchHebergements(1, 1001, 0);
    });

    it('should select chambre in mock mode', async () => {
      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      const hebergement = hebergements[0];

      await selectChambre(hebergement);

      const state = useChoixPyrStore.getState();
      expect(state.selectedHebergement).toEqual(hebergement);
      expect(state.error).toBeNull();
      expect(state.isLoading).toBe(false);
    });

    it('should validate hebergement belongs to client', async () => {
      const { selectChambre } = useChoixPyrStore.getState();
      const invalidHebergement: Hebergement = {
        ...MOCK_HEBERGEMENTS[0],
        compte: 9999,
      };

      await selectChambre(invalidHebergement);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Hebergement non valide pour ce client');
      expect(state.selectedHebergement).toBeNull();
    });

    it('should validate societe matches', async () => {
      const { selectChambre } = useChoixPyrStore.getState();
      const invalidHebergement: Hebergement = {
        ...MOCK_HEBERGEMENTS[0],
        societe: 999,
      };

      await selectChambre(invalidHebergement);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Hebergement non valide pour ce client');
    });

    it('should validate filiation matches', async () => {
      const { selectChambre } = useChoixPyrStore.getState();
      const invalidHebergement: Hebergement = {
        ...MOCK_HEBERGEMENTS[0],
        filiation: 99,
      };

      await selectChambre(invalidHebergement);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Hebergement non valide pour ce client');
    });

    it('should handle missing clientInfo', async () => {
      useChoixPyrStore.setState({ clientInfo: null });
      const { selectChambre, hebergements } = useChoixPyrStore.getState();

      await selectChambre(hebergements[0]);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Aucune information client disponible');
    });

    it('should call API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: SelectChambreResponse = {
        success: true,
        data: {
          success: true,
          selectedChambre: '101',
        },
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: mockResponse });

      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      const hebergement = hebergements[0];

      await selectChambre(hebergement);

      expect(apiClient.post).toHaveBeenCalledWith('/api/choixPyr/select', {
        societe: 1,
        compte: 1001,
        filiation: 0,
        chambre: hebergement.chambre,
      });
      expect(useChoixPyrStore.getState().selectedHebergement).toEqual(hebergement);
    });

    it('should handle API error during selection', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error('Selection failed'));

      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      await selectChambre(hebergements[0]);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Selection failed');
      expect(state.isLoading).toBe(false);
    });

    it('should handle API success=false response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: SelectChambreResponse = {
        success: false,
        data: {
          success: false,
          selectedChambre: '',
        },
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce({ data: mockResponse });

      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      await selectChambre(hebergements[0]);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Echec selection chambre');
    });

    it('should handle unknown error type during selection', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce('unknown error');

      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      await selectChambre(hebergements[0]);

      const state = useChoixPyrStore.getState();
      expect(state.error).toBe('Erreur selection chambre');
    });

    it('should set loading state during selection', async () => {
      const { selectChambre, hebergements } = useChoixPyrStore.getState();
      
      let isLoadingDuringSelection = false;
      
      const promise = selectChambre(hebergements[0]);
      
      await new Promise(resolve => setTimeout(resolve, 0));
      isLoadingDuringSelection = useChoixPyrStore.getState().isLoading;
      
      await promise;
      
      expect(isLoadingDuringSelection).toBe(true);
      expect(useChoixPyrStore.getState().isLoading).toBe(false);
    });
  });

  describe('cancelSelection', () => {
    it('should clear selected hebergement', () => {
      useChoixPyrStore.setState({ selectedHebergement: MOCK_HEBERGEMENTS[0] });

      const { cancelSelection } = useChoixPyrStore.getState();
      cancelSelection();

      const state = useChoixPyrStore.getState();
      expect(state.selectedHebergement).toBeNull();
    });

    it('should clear error on cancel', () => {
      useChoixPyrStore.setState({ 
        selectedHebergement: MOCK_HEBERGEMENTS[0],
        error: 'Some error',
      });

      const { cancelSelection } = useChoixPyrStore.getState();
      cancelSelection();

      const state = useChoixPyrStore.getState();
      expect(state.error).toBeNull();
    });
  });

  describe('setError', () => {
    it('should set error message', () => {
      const { setError } = useChoixPyrStore.getState();

      setError('Test error');

      expect(useChoixPyrStore.getState().error).toBe('Test error');
    });

    it('should clear error when passed null', () => {
      useChoixPyrStore.setState({ error: 'Existing error' });
      const { setError } = useChoixPyrStore.getState();

      setError(null);

      expect(useChoixPyrStore.getState().error).toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      useChoixPyrStore.setState({
        hebergements: MOCK_HEBERGEMENTS,
        selectedHebergement: MOCK_HEBERGEMENTS[0],
        clientInfo: MOCK_CLIENT,
        isLoading: true,
        error: 'Some error',
      });

      const { reset } = useChoixPyrStore.getState();
      reset();

      const state = useChoixPyrStore.getState();
      expect(state.hebergements).toEqual([]);
      expect(state.selectedHebergement).toBeNull();
      expect(state.clientInfo).toBeNull();
      expect(state.isLoading).toBe(false);
      expect(state.error).toBeNull();
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  Hebergement,
  ClientGm,
  ChoixPyrState,
  FetchHebergementsResponse,
  SelectChambreResponse,
} from '@/types/choixPyr';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface ChoixPyrActions {
  fetchHebergements: (
    societe: number,
    compte: number,
    filiation: number
  ) => Promise<void>;
  selectChambre: (hebergement: Hebergement) => Promise<void>;
  cancelSelection: () => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

type ChoixPyrStore = ChoixPyrState & ChoixPyrActions;

const MOCK_CLIENT: ClientGm = {
  societe: 1,
  compte: 1001,
  filiation: 0,
  nom: 'DUBOIS',
  prenom: 'Marc',
};

const MOCK_HEBERGEMENTS: Hebergement[] = [
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '101',
    dateDebut: new Date('2026-02-15'),
    dateFin: new Date('2026-02-28'),
    statut: 'ACTIF',
  },
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '203',
    dateDebut: new Date('2026-02-18'),
    dateFin: null,
    statut: 'ACTIF',
  },
  {
    societe: 1,
    compte: 1001,
    filiation: 0,
    chambre: '305',
    dateDebut: new Date('2026-02-10'),
    dateFin: new Date('2026-03-05'),
    statut: 'ACTIF',
  },
];

const initialState: ChoixPyrState = {
  hebergements: [],
  selectedHebergement: null,
  clientInfo: null,
  isLoading: false,
  error: null,
};

export const useChoixPyrStore = create<ChoixPyrStore>()((set, get) => ({
  ...initialState,

  fetchHebergements: async (societe, compte, filiation) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const today = new Date();
      const validHebergements = MOCK_HEBERGEMENTS.filter(
        (h) => h.dateDebut <= today && (h.dateFin === null || h.dateFin >= today)
      );
      set({
        hebergements: validHebergements,
        clientInfo: MOCK_CLIENT,
        isLoading: false,
      });
      return;
    }

    try {
      const response = await apiClient.get<FetchHebergementsResponse>(
        `/api/choixPyr/hebergements?societe=${societe}&compte=${compte}&filiation=${filiation}`
      );
      const data = response.data.data;
      set({
        hebergements: data?.hebergements ?? [],
        clientInfo: data?.clientInfo ?? null,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement hebergements';
      set({ hebergements: [], clientInfo: null, error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  selectChambre: async (hebergement) => {
    const { isRealApi } = useDataSourceStore.getState();
    const { clientInfo } = get();

    if (!clientInfo) {
      set({ error: 'Aucune information client disponible' });
      return;
    }

    if (
      hebergement.societe !== clientInfo.societe ||
      hebergement.compte !== clientInfo.compte ||
      hebergement.filiation !== clientInfo.filiation
    ) {
      set({ error: 'Hebergement non valide pour ce client' });
      return;
    }

    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({
        selectedHebergement: hebergement,
        isLoading: false,
      });
      return;
    }

    try {
      const response = await apiClient.post<SelectChambreResponse>(
        '/api/choixPyr/select',
        {
          societe: hebergement.societe,
          compte: hebergement.compte,
          filiation: hebergement.filiation,
          chambre: hebergement.chambre,
        }
      );
      if (response.data.data?.success) {
        set({ selectedHebergement: hebergement });
      } else {
        set({ error: 'Echec selection chambre' });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur selection chambre';
      set({ error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  cancelSelection: () => {
    set({ selectedHebergement: null, error: null });
  },

  setError: (error) => {
    set({ error });
  },

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.