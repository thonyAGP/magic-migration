Generate Vitest unit tests for the "controleOuvertureCaisseStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  CaisseControl,
  CaisseCalculee,
  ValidationError,
  ModeUniCheck,
} from '@/types/controleOuvertureCaisse';
import { useDataSourceStore } from './dataSourceStore';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';

interface ControleOuvertureCaisseState {
  isValidating: boolean;
  validationResult: CaisseCalculee | null;
  validationError: ValidationError | null;
}

interface ControleOuvertureCaisseActions {
  validateOuvertureCaisse: (params: CaisseControl) => Promise<CaisseCalculee>;
  checkModeUniBi: (mode: string) => Promise<ModeUniCheck>;
  clearValidation: () => void;
  reset: () => void;
}

type ControleOuvertureCaisseStore = ControleOuvertureCaisseState & ControleOuvertureCaisseActions;

const MOCK_VALIDATION_SUCCESS_UNI: CaisseCalculee = {
  caisseCalculee: 1500,
  caisseCalculeeMonnaie: 800,
  caisseCalculeeProduits: 500,
  caisseCalculeeCartes: 150,
  caisseCalculeeCheque: 50,
  caisseCalculeeOd: 0,
  caisseCalculeeNbDevise: 10,
};

const MOCK_VALIDATION_SUCCESS_BI: CaisseCalculee = {
  caisseCalculee: 2200,
  caisseCalculeeMonnaie: 1200,
  caisseCalculeeProduits: 700,
  caisseCalculeeCartes: 250,
  caisseCalculeeCheque: 50,
  caisseCalculeeOd: 0,
  caisseCalculeeNbDevise: 15,
};

const MOCK_VALIDATION_ERROR: ValidationError = {
  code: 'ERR_SESSION_ALREADY_OPEN',
  message: 'Une session est déjà ouverte pour ce numéro de chrono',
  field: 'chronoSession',
};

const calculateCaisseTotals = (params: CaisseControl): CaisseCalculee => {
  const caisseCalculee = params.soldeInitial + params.approCoffre + params.approArticles;
  const caisseCalculeeMonnaie = params.soldeInitialMonnaie + params.approCoffre;
  const caisseCalculeeProduits = params.soldeInitialProduits + params.approArticles;
  const caisseCalculeeNbDevise = params.soldeInitialNbreDevise + params.approNbreDevises;

  return {
    caisseCalculee,
    caisseCalculeeMonnaie,
    caisseCalculeeProduits,
    caisseCalculeeCartes: params.soldeInitialCartes,
    caisseCalculeeCheque: params.soldeInitialCheques,
    caisseCalculeeOd: params.soldeInitialOd,
    caisseCalculeeNbDevise,
  };
};

const initialState: ControleOuvertureCaisseState = {
  isValidating: false,
  validationResult: null,
  validationError: null,
};

export const useControleOuvertureCaisseStore = create<ControleOuvertureCaisseStore>()((set) => ({
  ...initialState,

  validateOuvertureCaisse: async (params) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isValidating: true, validationError: null, validationResult: null });

    if (!isRealApi) {
      const isBiMode = params.modeUniBi === 'B';
      
      if (params.chronoSession === 999) {
        set({
          validationError: MOCK_VALIDATION_ERROR,
          isValidating: false,
        });
        throw new Error(MOCK_VALIDATION_ERROR.message);
      }

      const mockResult = isBiMode ? MOCK_VALIDATION_SUCCESS_BI : MOCK_VALIDATION_SUCCESS_UNI;
      set({
        validationResult: mockResult,
        isValidating: false,
      });
      return mockResult;
    }

    try {
      const response = await apiClient.post<ApiResponse<CaisseCalculee>>(
        '/api/caisse/controle-ouverture',
        { params },
      );

      const result = response.data.data;
      if (!result) {
        throw new Error('Aucune donnée retournée par le serveur');
      }

      set({ validationResult: result });
      return result;
    } catch (e: unknown) {
      const errorData: ValidationError = {
        code: 'ERR_CALCULATION_ERROR',
        message: e instanceof Error ? e.message : 'Erreur lors du contrôle d\'ouverture',
        field: null,
      };
      set({ validationError: errorData });
      throw e;
    } finally {
      set({ isValidating: false });
    }
  },

  checkModeUniBi: async (mode) => {
    const { isRealApi } = useDataSourceStore.getState();

    const isUni = mode !== 'B';
    const isBi = mode === 'B';

    if (!isRealApi) {
      return { isUni, isBi };
    }

    return { isUni, isBi };
  },

  clearValidation: () => {
    set({ validationResult: null, validationError: null });
  },

  reset: () => set({ ...initialState }),
}));

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export interface CaisseControl {
  societe: string;
  deviseLocale: string;
  modeUniBi: string;
  chronoSession: number;
  soldeInitial: number;
  soldeInitialMonnaie: number;
  soldeInitialProduits: number;
  soldeInitialCartes: number;
  soldeInitialCheques: number;
  soldeInitialOd: number;
  soldeInitialNbreDevise: number;
  approCoffre: number;
  approArticles: number;
  approNbreDevises: number;
}

export interface CaisseCalculee {
  caisseCalculee: number;
  caisseCalculeeMonnaie: number;
  caisseCalculeeProduits: number;
  caisseCalculeeCartes: number;
  caisseCalculeeCheque: number;
  caisseCalculeeOd: number;
  caisseCalculeeNbDevise: number;
}

export interface ValidationError {
  code: string;
  message: string;
  field: string | null;
}

export interface ModeUniCheck {
  isUni: boolean;
  isBi: boolean;
}

export interface ControleOuvertureCaisseRequest {
  params: CaisseControl;
}

export interface ControleOuvertureCaisseResponse extends ApiResponse {
  data?: CaisseCalculee;
  error?: ValidationError;
}

export interface ControleOuvertureCaisseState {
  isValidating: boolean;
  validationResult: CaisseCalculee | null;
  validationError: ValidationError | null;
  validateOuvertureCaisse: (params: CaisseControl) => Promise<CaisseCalculee>;
  checkModeUniBi: (mode: string) => Promise<ModeUniCheck>;
  clearValidation: () => void;
}

export const VALIDATION_ERROR_CODES = {
  SESSION_ALREADY_OPEN: "ERR_SESSION_ALREADY_OPEN",
  INSUFFICIENT_PERMISSIONS: "ERR_INSUFFICIENT_PERMISSIONS",
  MISSING_PARAMETERS: "ERR_MISSING_PARAMETERS",
  INVALID_MODE: "ERR_INVALID_MODE",
  CALCULATION_ERROR: "ERR_CALCULATION_ERROR",
} as const;

export type ValidationErrorCode = (typeof VALIDATION_ERROR_CODES)[keyof typeof VALIDATION_ERROR_CODES];

export const MODE_UNI_BI = {
  UNI: "U",
  BI: "B",
} as const;

export type ModeUniType = (typeof MODE_UNI_BI)[keyof typeof MODE_UNI_BI];

ACTIONS TO COVER:
[
  {
    "name": "validateOuvertureCaisse",
    "params": [
      "params: CaisseControl"
    ],
    "businessRules": [
      "RM-001: If modeUniBi != 'B', execute UNI-mode specific validation",
      "RM-002: If modeUniBi == 'B', execute BI-mode specific validation",
      "Calculate caisseCalculee = soldeInitial + approCoffre + approArticles (Expression 1)",
      "Calculate caisseCalculeeMonnaie = soldeInitialMonnaie + approCoffre (Expression 2)",
      "Calculate caisseCalculeeProduits = soldeInitialProduits + approArticles (Expression 3)",
      "Calculate caisseCalculeeNbDevise = soldeInitialNbreDevise + approNbreDevises (Expression 7)",
      "Validate session not already open for this chrono",
      "Validate operator has required permissions",
      "Validate all required parameters are present",
      "Return calculated caisse values or error code"
    ],
    "returns": "Promise<CaisseCalculee>"
  },
  {
    "name": "checkModeUniBi",
    "params": [
      "mode: string"
    ],
    "businessRules": [
      "RM-001: Check if mode != 'B' for UNI-specific routing",
      "RM-002: Check if mode == 'B' for BI-specific routing"
    ],
    "returns": "Promise<{ isUni: boolean; isBi: boolean }>"
  }
]