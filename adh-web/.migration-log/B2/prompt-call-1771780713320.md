Fix the failing tests in D:/Projects/Lecteur_Magic/adh-web/src/__tests__/characterValidationStore.test.ts.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST ERRORS:
characterValidationStore validateCharacters should set isValidating during API call in mock mode: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/characterValidationStore.test.ts:76:67
    at file:///D:/Projects/Lecteur_Magic/a
characterValidationStore validateCharacters should validate string via API in real mode: AssertionError: expected true to be false // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/characterValidationStore.test.ts:101:30
    at processTicksAndRejections (node:in
characterValidationStore validateCharacters should handle missing data in API response: AssertionError: expected false to be true // Object.is equality
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/characterValidationStore.test.ts:143:30
    at processTicksAndRejections (node:in
characterValidationStore loadForbiddenCharacters should load forbidden characters via API in real mode: AssertionError: expected [] to deeply equal [ '@', '#', '$' ]
    at D:/Projects/Lecteur_Magic/adh-web/src/__tests__/characterValidationStore.test.ts:174:74
    at processTicksAndRejections (node:inte

CURRENT TEST FILE:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useCharacterValidationStore } from '@/stores/characterValidationStore';
import { apiClient } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';
import type { ApiResponse } from '@/services/api/apiClient';
import type { ValidateCharactersResponse, ForbiddenCharactersResponse } from '@/types/characterValidation';

vi.mock('@/services/api/apiClient', () => ({
  apiClient: {
    post: vi.fn(),
    get: vi.fn(),
  },
}));

const MOCK_FORBIDDEN_CHARS = [
  '@', '#', '$', '%', '&', '*', '<', '>', '|', '\\', '/', '?', '"', "'",
  '\n', '\r', '\t', '\0', '\x01', '\x02', '\x03',
];

describe('characterValidationStore', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    useCharacterValidationStore.getState().reset();
    useDataSourceStore.setState({ isRealApi: false });
  });

  describe('validateCharacters', () => {
    it('should validate string with invalid characters in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const result = await store.validateCharacters('test@email.com');
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(4);
      expect(useCharacterValidationStore.getState().lastValidationResult).toEqual(result);
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });

    it('should validate string with no invalid characters in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const result = await store.validateCharacters('valid-name');
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
      expect(useCharacterValidationStore.getState().lastValidationResult).toEqual(result);
    });

    it('should detect multiple invalid characters in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const result = await store.validateCharacters('special$char%here');
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('$%');
      expect(result.position).toBe(7);
    });

    it('should return valid result for unknown string in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const result = await store.validateCharacters('unknown-input');
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });

    it('should set isValidating during API call in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      const promise = store.validateCharacters('test');
      
      expect(useCharacterValidationStore.getState().isValidating).toBe(true);
      
      await promise;
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });

    it('should validate string via API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<ValidateCharactersResponse> = {
        data: {
          result: {
            isValid: false,
            invalidCharacters: '@',
            position: 5,
          },
        },
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce(mockResponse);
      
      const store = useCharacterValidationStore.getState();
      const result = await store.validateCharacters('email@domain.com');
      
      expect(apiClient.post).toHaveBeenCalledWith('/api/validation/check-string', {
        input: 'email@domain.com',
      });
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(5);
      expect(useCharacterValidationStore.getState().lastValidationResult).toEqual(result);
    });

    it('should handle API error in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const errorMessage = 'Network error';
      vi.mocked(apiClient.post).mockRejectedValueOnce(new Error(errorMessage));
      
      const store = useCharacterValidationStore.getState();
      const result = await store.validateCharacters('test-input');
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
      expect(useCharacterValidationStore.getState().error).toBe(errorMessage);
      expect(useCharacterValidationStore.getState().lastValidationResult).toBe(null);
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });

    it('should handle API error with unknown error type', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.post).mockRejectedValueOnce('Unknown error');
      
      const store = useCharacterValidationStore.getState();
      await store.validateCharacters('test-input');
      
      expect(useCharacterValidationStore.getState().error).toBe('Erreur validation caractères');
    });

    it('should handle missing data in API response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<ValidateCharactersResponse> = {
        data: undefined,
      };
      vi.mocked(apiClient.post).mockResolvedValueOnce(mockResponse);
      
      const store = useCharacterValidationStore.getState();
      const result = await store.validateCharacters('test');
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });
  });

  describe('loadForbiddenCharacters', () => {
    it('should load forbidden characters in mock mode', async () => {
      const store = useCharacterValidationStore.getState();
      
      await store.loadForbiddenCharacters();
      
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toEqual(MOCK_FORBIDDEN_CHARS);
      expect(useCharacterValidationStore.getState().forbiddenCharacters.length).toBe(21);
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toContain('@');
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toContain('$');
    });

    it('should load forbidden characters via API in real mode', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<ForbiddenCharactersResponse> = {
        data: {
          characters: ['@', '#', '$'],
        },
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce(mockResponse);
      
      const store = useCharacterValidationStore.getState();
      await store.loadForbiddenCharacters();
      
      expect(apiClient.get).toHaveBeenCalledWith('/api/validation/forbidden-characters');
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toEqual(['@', '#', '$']);
      expect(useCharacterValidationStore.getState().error).toBe(null);
    });

    it('should handle API error when loading forbidden characters', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const errorMessage = 'Failed to load';
      vi.mocked(apiClient.get).mockRejectedValueOnce(new Error(errorMessage));
      
      const store = useCharacterValidationStore.getState();
      await store.loadForbiddenCharacters();
      
      expect(useCharacterValidationStore.getState().error).toBe(errorMessage);
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toEqual([]);
    });

    it('should handle unknown error type when loading forbidden characters', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      vi.mocked(apiClient.get).mockRejectedValueOnce('Unknown error');
      
      const store = useCharacterValidationStore.getState();
      await store.loadForbiddenCharacters();
      
      expect(useCharacterValidationStore.getState().error).toBe('Erreur chargement caractères interdits');
    });

    it('should handle missing data in API response', async () => {
      useDataSourceStore.setState({ isRealApi: true });
      const mockResponse: ApiResponse<ForbiddenCharactersResponse> = {
        data: undefined,
      };
      vi.mocked(apiClient.get).mockResolvedValueOnce(mockResponse);
      
      const store = useCharacterValidationStore.getState();
      await store.loadForbiddenCharacters();
      
      expect(useCharacterValidationStore.getState().forbiddenCharacters).toEqual([]);
    });
  });

  describe('checkString', () => {
    it('should detect invalid character at first position', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#', '$'];
      
      const result = store.checkString('@username', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(0);
      expect(useCharacterValidationStore.getState().lastValidationResult).toEqual(result);
    });

    it('should detect invalid character in middle of string', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#', '$'];
      
      const result = store.checkString('user@name', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(4);
    });

    it('should detect multiple different invalid characters', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#', '$', '%'];
      
      const result = store.checkString('test@user#name$end', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@#$');
      expect(result.position).toBe(4);
    });

    it('should only list each invalid character once', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@'];
      
      const result = store.checkString('test@@user@@name', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('@');
      expect(result.position).toBe(4);
    });

    it('should return valid result for string with no invalid characters', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#', '$'];
      
      const result = store.checkString('validusername', forbiddenChars);
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });

    it('should handle empty string', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['@', '#'];
      
      const result = store.checkString('', forbiddenChars);
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });

    it('should handle empty forbidden characters list', () => {
      const store = useCharacterValidationStore.getState();
      
      const result = store.checkString('any@text#here', []);
      
      expect(result.isValid).toBe(true);
      expect(result.invalidCharacters).toBe('');
      expect(result.position).toBe(null);
    });

    it('should detect special characters like newline and tab', () => {
      const store = useCharacterValidationStore.getState();
      const forbiddenChars = ['\n', '\t', '\r'];
      
      const result = store.checkString('line1\nline2\ttab', forbiddenChars);
      
      expect(result.isValid).toBe(false);
      expect(result.invalidCharacters).toBe('\n\t');
      expect(result.position).toBe(5);
    });
  });

  describe('setError', () => {
    it('should set error message', () => {
      const store = useCharacterValidationStore.getState();
      
      store.setError('Custom error message');
      
      expect(useCharacterValidationStore.getState().error).toBe('Custom error message');
    });

    it('should clear error message', () => {
      const store = useCharacterValidationStore.getState();
      store.setError('Error');
      
      store.setError(null);
      
      expect(useCharacterValidationStore.getState().error).toBe(null);
    });
  });

  describe('setIsValidating', () => {
    it('should set isValidating to true', () => {
      const store = useCharacterValidationStore.getState();
      
      store.setIsValidating(true);
      
      expect(useCharacterValidationStore.getState().isValidating).toBe(true);
    });

    it('should set isValidating to false', () => {
      const store = useCharacterValidationStore.getState();
      store.setIsValidating(true);
      
      store.setIsValidating(false);
      
      expect(useCharacterValidationStore.getState().isValidating).toBe(false);
    });
  });

  describe('reset', () => {
    it('should reset all state to initial values', () => {
      const store = useCharacterValidationStore.getState();
      store.setError('Error message');
      store.setIsValidating(true);
      store.checkString('test@email', ['@']);
      useCharacterValidationStore.setState({ forbiddenCharacters: ['@', '#'] });
      
      store.reset();
      
      const state = useCharacterValidationStore.getState();
      expect(state.forbiddenCharacters).toEqual([]);
      expect(state.lastValidationResult).toBe(null);
      expect(state.isValidating).toBe(false);
      expect(state.error).toBe(null);
    });
  });
});
```

SOURCE FILE BEING TESTED:
```typescript
import { create } from 'zustand';
import type {
  ValidationResult,
  ValidateCharactersRequest,
  ValidateCharactersResponse,
  CheckStringRequest,
  CheckStringResponse,
  ForbiddenCharactersResponse,
  CharacterValidationState,
} from '@/types/characterValidation';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

const MOCK_FORBIDDEN_CHARS = [
  '@', '#', '$', '%', '&', '*', '<', '>', '|', '\\', '/', '?', '"', "'",
  '\n', '\r', '\t', '\0', '\x01', '\x02', '\x03',
];

const MOCK_VALIDATION_RESULTS: Record<string, ValidationResult> = {
  'test@email.com': {
    isValid: false,
    invalidCharacters: '@',
    position: 4,
  },
  'valid-name': {
    isValid: true,
    invalidCharacters: '',
    position: null,
  },
  'special$char%here': {
    isValid: false,
    invalidCharacters: '$%',
    position: 7,
  },
};

const initialState = {
  forbiddenCharacters: [],
  lastValidationResult: null,
  isValidating: false,
  error: null,
};

export const useCharacterValidationStore = create<CharacterValidationState>()((set, get) => ({
  ...initialState,

  validateCharacters: async (input: string): Promise<ValidationResult> => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isValidating: true, error: null });

    if (!isRealApi) {
      const mockResult = MOCK_VALIDATION_RESULTS[input] || {
        isValid: true,
        invalidCharacters: '',
        position: null,
      };
      set({ lastValidationResult: mockResult, isValidating: false });
      return mockResult;
    }

    try {
      const response = await apiClient.post<ApiResponse<ValidateCharactersResponse>>(
        '/api/validation/check-string',
        { input } as ValidateCharactersRequest,
      );
      const result = response.data.data?.result || {
        isValid: true,
        invalidCharacters: '',
        position: null,
      };
      set({ lastValidationResult: result });
      return result;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation caractères';
      set({ error: message, lastValidationResult: null });
      return {
        isValid: false,
        invalidCharacters: '',
        position: null,
      };
    } finally {
      set({ isValidating: false });
    }
  },

  loadForbiddenCharacters: async (): Promise<void> => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ error: null });

    if (!isRealApi) {
      set({ forbiddenCharacters: MOCK_FORBIDDEN_CHARS });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<ForbiddenCharactersResponse>>(
        '/api/validation/forbidden-characters',
      );
      const characters = response.data.data?.characters || [];
      set({ forbiddenCharacters: characters });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement caractères interdits';
      set({ error: message, forbiddenCharacters: [] });
    }
  },

  checkString: (input: string, forbiddenChars: string[]): ValidationResult => {
    const invalidCharsFound: string[] = [];
    let firstInvalidPosition: number | null = null;

    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      if (forbiddenChars.includes(char)) {
        if (firstInvalidPosition === null) {
          firstInvalidPosition = i;
        }
        if (!invalidCharsFound.includes(char)) {
          invalidCharsFound.push(char);
        }
      }
    }

    const result: ValidationResult = {
      isValid: invalidCharsFound.length === 0,
      invalidCharacters: invalidCharsFound.join(''),
      position: firstInvalidPosition,
    };

    set({ lastValidationResult: result });
    return result;
  },

  setError: (error: string | null) => set({ error }),

  setIsValidating: (isValidating: boolean) => set({ isValidating }),

  reset: () => set({ ...initialState }),
}));
```

Output the COMPLETE fixed test file. Do not omit any tests.