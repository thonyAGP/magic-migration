Review the generated code against the original specification.

Produce a JSON report:
```json
{
  "programId": 0,
  "programName": "",
  "coveragePct": 0,
  "rulesImplemented": 0,
  "rulesTotal": 0,
  "missingRules": [
    "rule descriptions not implemented"
  ],
  "recommendations": [
    "improvement suggestions"
  ]
}
```

Check:
1. Every business rule from the contract is implemented in the store
2. Every table from the contract has corresponding entity types
3. Every API endpoint is wired to the store
4. UI layout matches the spec description
5. Error handling is present for all actions

CONTRACT RULES:
[
  {
    "id": "RM-001",
    "description": "Condition: PI code calcul [A] egale 'C'",
    "condition": "PI code calcul [A]='C'",
    "variables": [
      "EN"
    ],
    "status": "IMPL",
    "targetFile": "adh-web/src/stores/saisieContenuCaisseStore.ts",
    "gapNotes": ""
  },
  {
    "id": "RM-002",
    "description": "Condition: PI code calcul [A] egale 'D'",
    "condition": "PI code calcul [A]='D'",
    "variables": [
      "EN"
    ],
    "status": "IMPL",
    "targetFile": "adh-web/src/services/printer/generators/ouvertureTicketGenerator.ts",
    "gapNotes": ""
  },
  {
    "id": "RM-003",
    "description": "Negation de (coffre en cours comptage [C]) (condition inversee)",
    "condition": "NOT (coffre en cours comptage [C])",
    "variables": [
      "EP"
    ],
    "status": "IMPL",
    "targetFile": "adh-web/src/__tests__/approTicketStore.test.ts",
    "gapNotes": ""
  },
  {
    "id": "RM-004",
    "description": "Negation de VG78 (condition inversee)",
    "condition": "NOT VG78",
    "variables": [],
    "status": "MISSING",
    "targetFile": "",
    "gapNotes": ""
  }
]

SPEC EXCERPT:
﻿# ADH IDE 116 - Calcul concurrence sessions

> **Analyse**: Phases 1-4 2026-02-08 02:56 -> 02:56 (4s) | Assemblage 02:56
> **Pipeline**: V7.2 Enrichi
> **Structure**: 4 onglets (Resume | Ecrans | Donnees | Connexions)

<!-- TAB:Resume -->

## 1. FICHE D'IDENTITE

| Attribut | Valeur |
|----------|--------|
| Projet | ADH |
| IDE Position | 116 |
| Nom Programme | Calcul concurrence sessions |
| Fichier source | `Prg_116.xml` |
| Dossier IDE | Caisse |
| Taches | 5 (0 ecrans visibles) |
| Tables modifiees | 1 |
| Programmes appeles | 0 |
| Complexite | **BASSE** (score 7/100) |

## 2. DESCRIPTION FONCTIONNELLE

ADH IDE 116 - Calcul concurrence sessions

Le programme ADH IDE 116 est responsable de la détection et gestion des ouvertures de session concurrentes pour un même compte membre. Il intervient lors de l'accès à la caisse pour vérifier qu'une session n'est pas déjà active sur un autre terminal, ce qui pourrait créer des incohérences de solde ou des mouvements contradictoires.

Le flux principal interroge la table `concurrence_sessions` pour identifier les sessions actives associées au couple (societe, compte, filiation). Si une session existe déjà, le programme peut soit bloquer l'accès (mode strict), soit afficher un avertissement à l'opérateur lui permettant de forcer l'ouverture après validation. Cette logique est critique pour garantir l'intégrité transactionnelle en environnement multi-caisse.

Les appels émis depuis Gestion caisse (IDE 121) ou sa variante IDE 298 déclenchent ce contrôle avant de créer une nouvelle session de travail. Le programme met à jour l'enregistrement de concurrence avec un timestamp et un identifiant terminal, permettant ainsi aux gestionnaires de tracer les conflits potentiels et de nettoyer les sessions "zombies" abandonnées sans fermeture propre.

## 3. BLOCS FONCTIONNELS

## 5. REGLES METIER

4 regles identifiees:

### Autres (4 regles)

#### <a id="rm-RM-001"></a>[RM-001] Condition: PI code calcul [A] egale 'C'

| Element | Detail |
|---------|--------|
| **Condition** | `PI code calcul [A]='C'` |
| **Si vrai** | Action si vrai |
| **Variables** | EN (PI code calcul) |
| **Expression source** | Expression 1 : `PI code calcul [A]='C'` |
| **Exemple** | Si PI code calcul [A]='C' â†’ Action si vrai |

#### <a id="rm-RM-002"></a>[RM-002] Condition: PI code calcul [A] egale 'D'

| Element | Detail |
|---------|--------|
| **Condition** | `PI code calcul [A]='D'` |
| **Si vrai** | Action si vrai |
| **Variables** | EN (PI code calcul) |
| **Expression source** | Expression 2 : `PI code calcul [A]='D'` |
| **Exemple** | Si PI code calcul [A]='D' â†’ Action si vrai |

#### <a id="rm-RM-003"></a>[RM-003] Negation de (coffre en cours comptage [C]) (condition inversee)

| Element | Detail |
|---------|--------|
| **Condition** | `NOT (coffre en cours comptage [C])` |
| **Si vrai** | Action si vrai |
| **Variables** | EP (coffre en cours comptage) |
| **Expression source** | Expression 7 : `NOT (coffre en cours comptage [C])` |
| **Exemple** | Si NOT (coffre en cours comptage [C]) â†’ Action si vrai |

#### <a id="rm-RM-004"></a>[RM-004] Negation de VG78 (condition inversee)

| Element | Detail |
|---------|--------|
| **Condition** | `NOT VG78` |
| **Si vrai** | Action si vrai |
| **Expression source** | Expression 8 : `NOT VG78` |
| **Exemple** | Si NOT VG78 â†’ Action si vrai |

## 6. CONTEXTE

- **Appele par**: [Gestion caisse (IDE 121)](ADH-IDE-121.md), [Gestion caisse 142 (IDE 298)](ADH-IDE-298.md)
- **Appelle**: 0 programmes | **Tables**: 1 (W:1 R:1 L:0) | **Taches**: 5 | **Expressions**: 9

<!-- TAB:Ecrans -->

## 8. ECRANS

*(Programme sans ecran visible)*

## 9. NAVIGATION

### 9.3 Structure hierarchique (0 tache)

| Position | Tache | Type | Dimensions | Bloc |
|----------|-------|------|------------|------|

### 9.4 Algorigramme

```mermaid
flowchart TD
    START([START])
    INIT[Init controles]
    SAISIE[Traitement principal]
    DECISION{PI code calcul}
    PROCESS[Traitement]
    UPDATE[MAJ 1 tables]
    ENDOK([END OK])
    ENDKO([END KO])

    START --> INIT --> SAISIE --> DECISION
    DECISION -->|OUI| PROCESS
    DECISION -->|NON| ENDKO
    PROCESS --> UPDATE --> ENDOK

    style START fill:#3fb950,color:#000
    style ENDOK fill:#3fb950,color:#000
    style ENDKO fill:#f85149,color:#fff
    style DECISION fill:#58a6ff,color:#000
```

> **Legende**: Vert = START/END OK | Rouge = END KO | Bleu = Decisions
> *Algorigramme auto-genere. Utiliser `/algorigramme` pour une synthese metier detaillee.*

<!-- TAB:Donnees -->

## 10. TABLES

### Tables utilisees (1)

| ID | Nom | Description | Type | R | W | L | Usages |
|----|-----|-------------|------|---|---|---|--------|
| 227 | concurrence_sessions | Sessions de caisse | DB | R | **W** |   | 5 |

### Colonnes par table (1 / 1 tables avec colonnes identifiees)

<details>
<summary>Table 227 - concurrence_sessions (R/**W**) - 5 usages</summary>

| Lettre | Variable | Acces | Type |
|--------|----------|-------|------|


GENERATED FILES:

--- types/sessionConcurrency.ts ---
import type { ApiResponse } from "@/services/api/apiClient";

export type SessionConcurrencyCodeCalcul = 'C' | 'D';

export interface SessionConcurrency {
  societe: string;
  compte: number;
  filiation: number;
  terminalId: string;
  timestamp: Date;
  codeCalcul: string | null;
  coffreEnCoursComptage: boolean;
}

export interface SessionConflictResult {
  allowed: boolean;
  conflictingSession?: SessionConcurrency;
  reason?: string;
}

export interface RegisterSessionRequest {
  societe: string;
  compte: number;
  filiation: number;
  terminalId: string;
  codeCalcul: SessionConcurrencyCodeCalcul;
}

export interface ReleaseSessionRequest {
  societe: string;
  compte: number;
  filiation: number;
  terminalId: string;
}

export interface ForceOpenSessionRequest {
  societe: string;
  compte: number;
  filiation: number;
  terminalId: string;
  reason: string;
}

export interface CheckConcurrencyResponse extends ApiResponse {
  data: SessionConflictResult;
}

export interface RegisterSessionResponse extends ApiResponse {
  data: {
    success: boolean;
  };
}

export interface ReleaseSessionResponse extends ApiResponse {
  data: {
    success: boolean;
  };
}

export interface ForceOpenSessionResponse extends ApiResponse {
  data: {
    success: boolean;
  };
}

export interface SessionConcurrencyState {
  activeSessions: SessionConcurrency[];
  isLoading: boolean;
  error: string | null;
  conflictDetected: boolean;
  conflictingSession: SessionConcurrency | null;
  checkConcurrency: (
    societe: string,
    compte: number,
    filiation: number
  ) => Promise<SessionConflictResult>;
  registerSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
    codeCalcul: SessionConcurrencyCodeCalcul
  ) => Promise<void>;
  releaseSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string
  ) => P

--- stores/sessionConcurrencyStore.ts ---
import { create } from 'zustand';
import type {
  SessionConcurrency,
  SessionConflictResult,
  SessionConcurrencyCodeCalcul,
} from '@/types/sessionConcurrency';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from './dataSourceStore';

interface SessionConcurrencyState {
  activeSessions: SessionConcurrency[];
  isLoading: boolean;
  error: string | null;
  conflictDetected: boolean;
  conflictingSession: SessionConcurrency | null;
}

interface SessionConcurrencyActions {
  checkConcurrency: (
    societe: string,
    compte: number,
    filiation: number,
  ) => Promise<SessionConflictResult>;
  registerSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
    codeCalcul: SessionConcurrencyCodeCalcul,
  ) => Promise<void>;
  releaseSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
  ) => Promise<void>;
  forceOpenSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
    reason: string,
  ) => Promise<void>;
  setError: (error: string | null) => void;
  clearConflict: () => void;
  reset: () => void;
}

type SessionConcurrencyStore = SessionConcurrencyState & SessionConcurrencyActions;

const MOCK_SESSIONS: SessionConcurrency[] = [
  {
    societe: 'SOC1',
    compte: 1001,
    filiation: 0,
    terminalId: 'TERM01',
    timestamp: new Date('2026-02-21T08:30:00'),
    codeCalcul: 'C',
    coffreEnCoursComptage: false,
  },
  {
    societe: 'SOC1',
    compte: 1002,
    filiation: 0,
    terminalId: 'TERM02',
    timestamp: new Date('2026-02-21T09:15:00'),
    codeCalcul: 'D',
    coffreEnCoursComptage: true,
  },
];

const initialState: SessionConcurrencyState = {
  activeSessions: [],
  isLoading: false,
  error: null,
  conflictDetected: false,
  conflic

--- services/api/endpoints-sessionConcurrency.ts ---
import { apiClient, type ApiResponse } from '@/services/api/apiClient';
import type {
  SessionConcurrency,
  RegisterSessionRequest,
  ReleaseSessionRequest,
  ForceOpenSessionRequest,
  CheckConcurrencyResponse,
  RegisterSessionResponse,
  ReleaseSessionResponse,
  ForceOpenSessionResponse,
} from '@/types/sessionConcurrency';

export const sessionConcurrencyApi = {
  getConcurrentSession: (terminal: string, devise?: string) =>
    apiClient.get<ApiResponse<SessionConcurrency | null>>(
      `/api/caisse/sessions/concurrent?terminal=${encodeURIComponent(terminal)}${devise ? `&devise=${encodeURIComponent(devise)}` : ''}`,
    ),

  checkConcurrency: (
    societe: string,
    compte: number,
    filiation: number,
  ) =>
    apiClient.get<CheckConcurrencyResponse>(
      `/api/caisse/sessions/check?societe=${encodeURIComponent(societe)}&compte=${compte}&filiation=${filiation}`,
    ),

  registerSession: (data: RegisterSessionRequest) =>
    apiClient.post<RegisterSessionResponse>(
      '/api/caisse/sessions/register',
      data,
    ),

  releaseSession: (data: ReleaseSessionRequest) =>
    apiClient.post<ReleaseSessionResponse>(
      '/api/caisse/sessions/release',
      data,
    ),

  forceOpenSession: (data: ForceOpenSessionRequest) =>
    apiClient.post<ForceOpenSessionResponse>(
      '/api/caisse/sessions/force-open',
      data,
    ),
};

--- pages/SessionConcurrencyPage.tsx ---
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Dialog } from '@/components/ui';
import { useSessionConcurrencyStore } from '@/stores/sessionConcurrencyStore';
import { useAuthStore } from '@/stores';

export function SessionConcurrencyPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);

  const activeSessions = useSessionConcurrencyStore((s) => s.activeSessions);
  const isLoading = useSessionConcurrencyStore((s) => s.isLoading);
  const error = useSessionConcurrencyStore((s) => s.error);
  const conflictDetected = useSessionConcurrencyStore((s) => s.conflictDetected);
  const conflictingSession = useSessionConcurrencyStore((s) => s.conflictingSession);
  const forceOpenSession = useSessionConcurrencyStore((s) => s.forceOpenSession);
  const setError = useSessionConcurrencyStore((s) => s.setError);
  const clearConflict = useSessionConcurrencyStore((s) => s.clearConflict);
  const reset = useSessionConcurrencyStore((s) => s.reset);

  const [showConflictDialog, setShowConflictDialog] = useState(false);
  const [forceReason, setForceReason] = useState('');

  useEffect(() => {
    setShowConflictDialog(conflictDetected && !!conflictingSession);
  }, [conflictDetected, conflictingSession]);

  useEffect(() => {
    return () => reset();
  }, [reset]);

  const handleCloseConflict = useCallback(() => {
    setShowConflictDialog(false);
    clearConflict();
    setForceReason('');
    navigate('/caisse/menu');
  }, [clearConflict, navigate]);

  const handleForceOpen = useCallback(async () => {
    if (!conflictingSession || !forceReason.trim()) {
      setError('Veuillez saisir une raison pour forcer l\'ouverture');
      return;
    }

    try {
      await forceOpenSession(
        conflictingSession.societe,
        conflictingSession.compte,
        conflictingSess

--- components/caisse/sessionConcurrency/BackgroundValidationPanel.tsx ---
import { useEffect } from 'react';
import { Dialog, Button } from '@/components/ui';
import { useSessionConcurrencyStore } from '@/stores/sessionConcurrencyStore';
import type { SessionConcurrency } from '@/types/sessionConcurrency';

interface BackgroundValidationPanelProps {
  societe: string;
  compte: number;
  filiation: number;
  onValidationComplete?: (allowed: boolean) => void;
}

export const BackgroundValidationPanel = ({
  societe,
  compte,
  filiation,
  onValidationComplete,
}: BackgroundValidationPanelProps) => {
  const conflictDetected = useSessionConcurrencyStore((s) => s.conflictDetected);
  const conflictingSession = useSessionConcurrencyStore((s) => s.conflictingSession);
  const checkConcurrency = useSessionConcurrencyStore((s) => s.checkConcurrency);
  const clearConflict = useSessionConcurrencyStore((s) => s.clearConflict);
  const isLoading = useSessionConcurrencyStore((s) => s.isLoading);

  useEffect(() => {
    const validateSession = async () => {
      const result = await checkConcurrency(societe, compte, filiation);
      onValidationComplete?.(result.allowed);
    };

    validateSession();
  }, [societe, compte, filiation, checkConcurrency, onValidationComplete]);

  const handleClose = () => {
    clearConflict();
    onValidationComplete?.(false);
  };

  const formatSessionDetails = (session: SessionConcurrency) => {
    const timestamp = new Date(session.timestamp);
    const dateStr = timestamp.toLocaleDateString('fr-FR');
    const timeStr = timestamp.toLocaleTimeString('fr-FR');
    
    return {
      terminal: session.terminalId,
      date: dateStr,
      time: timeStr,
      calcul: session.codeCalcul === 'C' ? 'Caisse' : session.codeCalcul === 'D' ? 'Détail' : 'Non défini',
      comptage: session.coffreEnCoursComptage ? 'Oui' : 'Non',
    };
  };

  if (!conflictDetected || !conflictingSession) {
    return null;
  }

  const details = formatSessionDetails(conflict

--- components/caisse/sessionConcurrency/ConflictWarningPanel.tsx ---
import { memo } from 'react';
import { Button, Dialog } from '@/components/ui';
import type { SessionConcurrency } from '@/types/sessionConcurrency';

interface ConflictWarningPanelProps {
  open: boolean;
  conflictingSession: SessionConcurrency | null;
  onCancel: () => void;
  onForceOpen: () => void;
  isLoading?: boolean;
}

export const ConflictWarningPanel = memo<ConflictWarningPanelProps>(({
  open,
  conflictingSession,
  onCancel,
  onForceOpen,
  isLoading = false,
}) => {
  if (!conflictingSession) return null;

  const formattedTimestamp = new Date(conflictingSession.timestamp).toLocaleString('fr-FR', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });

  return (
    <Dialog open={open} onClose={onCancel}>
      <div className="bg-white rounded-lg shadow-xl p-6 max-w-lg w-full">
        <div className="flex items-start gap-3 mb-4">
          <div className="flex-shrink-0 w-10 h-10 rounded-full bg-yellow-100 flex items-center justify-center">
            <svg className="w-6 h-6 text-yellow-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
          </div>
          <div className="flex-1">
            <h3 className="text-lg font-semibold text-gray-900 mb-1">
              Session déjà ouverte
            </h3>
            <p className="text-sm text-gray-600">
              Une session est déjà active pour ce compte. Forcer l'ouverture fermera automatiquement la session existante.
            </p>
          </div>
        </div>

        <div className="bg-gray-50 rounded-lg p-4 mb-6 space-y-2">
          <div className="flex justify-between items-center">
            <span className="text-sm font-medium text-gray-700">Termi