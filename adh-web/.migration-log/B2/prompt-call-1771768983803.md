Generate a React component: ConflictWarningPanel for the "SessionConcurrency" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

COMPONENT REQUIREMENTS:
- Props interface at the top of the file
- Tailwind v4 classes for styling
- Use shared UI components from @/components/ui/ when applicable (DataGrid, Dialog, etc.)
- Handle loading and empty states

SECTION TO IMPLEMENT:
{
  "name": "conflictWarning",
  "controls": [
    "Message d'avertissement",
    "DÃ©tails session conflictuelle (terminal, timestamp)",
    "Bouton Annuler",
    "Bouton Forcer Ouverture"
  ]
}

PAGE (shows how this component is used):
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { ScreenLayout } from '@/components/layout';
import { Dialog } from '@/components/ui';
import { useSessionConcurrencyStore } from '@/stores/sessionConcurrencyStore';
import { useAuthStore } from '@/stores';

export function SessionConcurrencyPage() {
  const navigate = useNavigate();
  const user = useAuthStore((s) => s.user);

  const activeSessions = useSessionConcurrencyStore((s) => s.activeSessions);
  const isLoading = useSessionConcurrencyStore((s) => s.isLoading);
  const error = useSessionConcurrencyStore((s) => s.error);
  const conflictDetected = useSessionConcurrencyStore((s) => s.conflictDetected);
  const conflictingSession = useSessionConcurrencyStore((s) => s.conflictingSession);
  const forceOpenSession = useSessionConcurrencyStore((s) => s.forceOpenSession);
  const setError = useSessionConcurrencyStore((s) => s.setError);
  const clearConflict = useSessionConcurrencyStore((s) => s.clearConflict);
  const reset = useSessionConcurrencyStore((s) => s.reset);

  const [showConflictDialog, setShowConflictDialog] = useState(false);
  const [forceReason, setForceReason] = useState('');

  useEffect(() => {
    setShowConflictDialog(conflictDetected && !!conflictingSession);
  }, [conflictDetected, conflictingSession]);

  useEffect(() => {
    return () => reset();
  }, [reset]);

  const handleCloseConflict = useCallback(() => {
    setShowConflictDialog(false);
    clearConflict();
    setForceReason('');
    navigate('/caisse/menu');
  }, [clearConflict, navigate]);

  const handleForceOpen = useCallback(async () => {
    if (!conflictingSession || !forceReason.trim()) {
      setError('Veuillez saisir une raison pour forcer l\'ouverture');
      return;
    }

    try {
      await forceOpenSession(
        conflictingSession.societe,
        conflictingSession.compte,
        conflictingSess

TYPES:
import type { ApiResponse } from "@/services/api/apiClient";

export type SessionConcurrencyCodeCalcul = 'C' | 'D';

export interface SessionConcurrency {
  societe: string;
  compte: number;
  filiation: number;
  terminalId: string;
  timestamp: Date;
  codeCalcul: string | null;
  coffreEnCoursComptage: boolean;
}

export interface SessionConflictResult {
  allowed: boolean;
  conflictingSession?: SessionConcurrency;
  reason?: string;
}

export interface RegisterSessionRequest {
  societe: string;
  compte: number;
  filiation: number;
  terminalId: string;
  codeCalcul: SessionConcurrencyCodeCalcul;
}

export interface ReleaseSessionRequest {
  societe: string;
  compte: number;
  filiation: number;
  terminalId: string;
}

export interface ForceOpenSessionRequest {
  societe: string;
  compte: number;
  filiation: number;
  terminalId: string;
  reason: string;
}

export interface CheckConcurrencyResponse extends ApiResponse {
  data: SessionConflictResult;
}

export interface RegisterSessionResponse extends ApiResponse {
  data: {
    success: boolean;
  };
}

export interface ReleaseSessionResponse extends ApiResponse {
  data: {
    success: boolean;
  };
}

export interface ForceOpenSessionResponse extends ApiResponse {
  data: {
    success: boolean;
  };
}

export interface SessionConcurrencyState {
  activeSessions: SessionConcurrency[];
  isLoading: boolean;
  error: string | null;
  conflictDetected: boolean;
  conflictingSession: SessionConcurrency | null;
  checkConcurrency: (
    societe: string,
    compte: number,
    filiation: number
  ) => Promise<SessionConflictResult>;
  registerSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
    codeCalcul: SessionConcurrencyCodeCalcul
  ) => Promise<void>;
  releaseSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string
  ) => Promise<void>;
  forceOpenSession: (
    societe: string,
    compte: number,
    filiation: number,
    terminalId: string,
    reason: string
  ) => Promise<void>;
  setError: (error: string | null) => void;
  clearConflict: () => void;
}