Generate Vitest unit tests for the "fermetureSessionsStore".

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

TEST REQUIREMENTS:
- Use @vitest-environment jsdom
- import { describe, it, expect, beforeEach, vi } from "vitest"
- vi.mock() for API service
- beforeEach: reset store state
- AAA pattern (Arrange, Act, Assert)
- Test EACH action: success path + error path + loading state
- Mock data as constants at top of file
- Test business rules explicitly

STORE TO TEST:
import { create } from 'zustand';
import type {
  Session,
  UnilateralBilateral,
  SessionClosureResult,
  FermetureSessionsState,
} from '@/types/fermetureSessions';
import { apiClient } from '@/services/api/apiClient';
import type { ApiResponse } from '@/services/api/apiClient';
import { useDataSourceStore } from '@/stores/dataSourceStore';

interface FermetureSessionsActions {
  loadSessions: (filters?: { statut?: string }) => Promise<void>;
  loadUnilateralBilateralTypes: () => Promise<void>;
  fermerSession: (sessionId: number) => Promise<void>;
  generateClosureCode: (sessionId: number) => string;
  validateSessionClosure: (sessionId: number) => Promise<boolean>;
  setCurrentSession: (session: Session | null) => void;
  clearError: () => void;
  reset: () => void;
}

type FermetureSessionsStore = FermetureSessionsState & FermetureSessionsActions;

const MOCK_SESSIONS: Session[] = [
  { id: 1, dateOuverture: new Date('2026-02-19T08:00:00'), dateFermeture: null, statut: 'O' },
  { id: 2, dateOuverture: new Date('2026-02-18T08:00:00'), dateFermeture: null, statut: 'O' },
  { id: 3, dateOuverture: new Date('2026-02-17T08:00:00'), dateFermeture: null, statut: 'O' },
  { id: 4, dateOuverture: new Date('2026-02-16T08:00:00'), dateFermeture: new Date('2026-02-16T18:00:00'), statut: 'C' },
  { id: 5, dateOuverture: new Date('2026-02-15T08:00:00'), dateFermeture: new Date('2026-02-15T18:00:00'), statut: 'C' },
];

const MOCK_TYPES: UnilateralBilateral[] = [
  { code: 'UNI', libelle: 'Unilateral', type: 'unilateral' },
  { code: 'BIL', libelle: 'Bilateral', type: 'bilateral' },
  { code: 'MIX', libelle: 'Mixed', type: 'mixed' },
];

const initialState: FermetureSessionsState = {
  sessions: [],
  currentSession: null,
  unilateralBilateralTypes: [],
  isLoading: false,
  error: null,
  isClosing: false,
};

export const useFermetureSessionsStore = create<FermetureSessionsStore>()((set, get) => ({
  ...initialState,

  loadSessions: async (filters) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      const filtered = filters?.statut
        ? MOCK_SESSIONS.filter((s) => s.statut === filters.statut)
        : MOCK_SESSIONS;
      set({ sessions: filtered, isLoading: false });
      return;
    }

    try {
      const params = filters?.statut ? `?statut=${filters.statut}` : '';
      const response = await apiClient.get<ApiResponse<{ sessions: Session[] }>>(
        `/api/fermeture-sessions/sessions${params}`,
      );
      set({ sessions: response.data.data?.sessions ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement sessions';
      set({ sessions: [], error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  loadUnilateralBilateralTypes: async () => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoading: true, error: null });

    if (!isRealApi) {
      set({ unilateralBilateralTypes: MOCK_TYPES, isLoading: false });
      return;
    }

    try {
      const response = await apiClient.get<ApiResponse<{ types: UnilateralBilateral[] }>>(
        '/api/fermeture-sessions/types',
      );
      set({ unilateralBilateralTypes: response.data.data?.types ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement types';
      set({ unilateralBilateralTypes: [], error: message });
    } finally {
      set({ isLoading: false });
    }
  },

  fermerSession: async (sessionId) => {
    const { isRealApi } = useDataSourceStore.getState();
    const { validateSessionClosure, generateClosureCode } = get();

    set({ isClosing: true, error: null });

    const isValid = await validateSessionClosure(sessionId);
    if (!isValid) {
      set({ isClosing: false, error: 'Session non éligible à la fermeture' });
      return;
    }

    const closureCode = generateClosureCode(sessionId);

    if (!isRealApi) {
      set((state) => ({
        sessions: state.sessions.map((s) =>
          s.id === sessionId
            ? { ...s, dateFermeture: new Date(), statut: 'C' as const }
            : s,
        ),
        currentSession:
          state.currentSession?.id === sessionId
            ? { ...state.currentSession, dateFermeture: new Date(), statut: 'C' as const }
            : state.currentSession,
        isClosing: false,
      }));
      return;
    }

    try {
      const response = await apiClient.post<ApiResponse<SessionClosureResult>>(
        `/api/fermeture-sessions/close/${sessionId}`,
        {},
      );

      if (response.data.data?.success) {
        set((state) => ({
          sessions: state.sessions.map((s) =>
            s.id === sessionId
              ? { ...s, dateFermeture: new Date(), statut: 'C' as const }
              : s,
          ),
          currentSession:
            state.currentSession?.id === sessionId
              ? { ...state.currentSession, dateFermeture: new Date(), statut: 'C' as const }
              : state.currentSession,
        }));
      } else {
        set({ error: 'Échec fermeture session' });
      }
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur fermeture session';
      set({ error: message });
    } finally {
      set({ isClosing: false });
    }
  },

  generateClosureCode: (sessionId) => {
    const D = sessionId % 10;
    const base = 'N15';
    const decimalPart = D > 0 ? `.${D}` : '';
    const suffix = 'CZ';
    return `${base}${decimalPart}${suffix}`;
  },

  validateSessionClosure: async (sessionId) => {
    const { isRealApi } = useDataSourceStore.getState();
    const { sessions } = get();

    const session = sessions.find((s) => s.id === sessionId);
    if (!session) {
      set({ error: 'Session introuvable' });
      return false;
    }

    if (session.statut !== 'O') {
      set({ error: 'Seules les sessions ouvertes peuvent être fermées' });
      return false;
    }

    if (!isRealApi) {
      return true;
    }

    try {
      const response = await apiClient.post<ApiResponse<{ valid: boolean; errors: string[] }>>(
        `/api/fermeture-sessions/validate/${sessionId}`,
        {},
      );
      const result = response.data.data;
      if (!result?.valid && result?.errors?.length) {
        set({ error: result.errors.join(', ') });
      }
      return result?.valid ?? false;
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur validation';
      set({ error: message });
      return false;
    }
  },

  setCurrentSession: (session) => {
    set({ currentSession: session, error: null });
  },

  clearError: () => {
    set({ error: null });
  },

  reset: () => set({ ...initialState }),
}));

TYPES:
// Fermeture Sessions types (ADH IDE 131)

export type SessionStatus = 'O' | 'C' | 'B'; // Open, Closed, Blocked

export interface Session {
  id: number;
  dateOuverture: Date;
  dateFermeture: Date | null;
  statut: SessionStatus;
}

export interface UnilateralBilateral {
  code: string;
  libelle: string;
  type: string;
}

export interface SessionClosureCode {
  sessionId: number;
  code: string;
  generatedAt: Date;
}

export interface SessionValidation {
  valid: boolean;
  errors: string[];
}

export interface SessionClosureResult {
  success: boolean;
  closureCode: string;
  sessionId: number;
  closedAt: Date;
}

// API Request/Response types

export interface FetchSessionsRequest {
  statut?: SessionStatus;
}

export interface FetchSessionsResponse {
  sessions: Session[];
}

export type FetchUnilateralBilateralRequest = Record<string, never>;

export interface FetchUnilateralBilateralResponse {
  types: UnilateralBilateral[];
}

export interface ValidateSessionClosureRequest {
  sessionId: number;
}

export interface ValidateSessionClosureResponse {
  valid: boolean;
  errors: string[];
}

export interface CloseSessionRequest {
  sessionId: number;
}

export interface CloseSessionResponse {
  success: boolean;
  closureCode: string;
}

// Store state interface

export interface FermetureSessionsState {
  sessions: Session[];
  currentSession: Session | null;
  unilateralBilateralTypes: UnilateralBilateral[];
  isLoading: boolean;
  error: string | null;
  isClosing: boolean;

  // Actions
  loadSessions: (filters?: FetchSessionsRequest) => Promise<void>;
  loadUnilateralBilateralTypes: () => Promise<void>;
  fermerSession: (sessionId: number) => Promise<void>;
  generateClosureCode: (sessionId: number) => string;
  validateSessionClosure: (sessionId: number) => Promise<boolean>;
  setCurrentSession: (session: Session | null) => void;
  clearError: () => void;
  reset: () => void;
}

// Mock data helpers

export const mockSession = (overrides?: Partial<Session>): Session => ({
  id: Math.floor(Math.random() * 10000),
  dateOuverture: new Date(2026, 1, 20),
  dateFermeture: null,
  statut: 'O',
  ...overrides,
});

export const mockUnilateralBilateral = (overrides?: Partial<UnilateralBilateral>): UnilateralBilateral => ({
  code: 'UNI',
  libelle: 'Unilateral',
  type: 'unilateral',
  ...overrides,
});

export const DEFAULT_SESSIONS: Session[] = [
  mockSession({ id: 1, dateOuverture: new Date(2026, 1, 19) }),
  mockSession({ id: 2, dateOuverture: new Date(2026, 1, 18) }),
  mockSession({ id: 3, dateOuverture: new Date(2026, 1, 17) }),
  mockSession({ id: 4, dateOuverture: new Date(2026, 1, 16) }),
  mockSession({ id: 5, dateOuverture: new Date(2026, 1, 15) }),
];

export const DEFAULT_UNILATERAL_BILATERAL: UnilateralBilateral[] = [
  mockUnilateralBilateral({ code: 'UNI', libelle: 'Unilateral', type: 'unilateral' }),
  mockUnilateralBilateral({ code: 'BIL', libelle: 'Bilateral', type: 'bilateral' }),
  mockUnilateralBilateral({ code: 'MIX', libelle: 'Mixed', type: 'mixed' }),
];

ACTIONS TO COVER:
[
  {
    "name": "loadSessions",
    "params": [],
    "businessRules": [
      "Retrieve all sessions from initialisation___ini table",
      "Filter sessions with status 'O' (open)"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "loadUnilateralBilateralTypes",
    "params": [],
    "businessRules": [
      "Load unilateral/bilateral type reference data",
      "Used for session closure validation"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "fermerSession",
    "params": [
      "sessionId: number"
    ],
    "businessRules": [
      "Apply rule RM-001: Generate code format 'N15'&IF([D]>0,'.'&Trim(Str([D],'1')),'')&'CZ'",
      "Set session status to 'C' (closed)",
      "Record closure timestamp",
      "Validate session closure eligibility"
    ],
    "returns": "Promise<void>"
  },
  {
    "name": "generateClosureCode",
    "params": [
      "sessionId: number"
    ],
    "businessRules": [
      "Implement RM-001: Format code as 'N15' + optional decimal part + 'CZ'",
      "If [D] > 0, append '.' and trimmed string representation of [D]",
      "Concatenate with 'CZ' suffix"
    ],
    "returns": "string"
  },
  {
    "name": "validateSessionClosure",
    "params": [
      "sessionId: number"
    ],
    "businessRules": [
      "Check session exists and is open (status = 'O')",
      "Verify no pending operations",
      "Ensure all required closure data is present"
    ],
    "returns": "Promise<boolean>"
  }
]