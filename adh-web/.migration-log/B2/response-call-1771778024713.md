## Analyse de couverture ADH IDE 134 - Mise à jour detail session WS

**Résultat : 15% de couverture - 0/6 règles implémentées**

### Problèmes critiques identifiés

#### 1. **Toutes les règles business marquées N/A mais logique manquante**

Le contrat liste 6 règles business (RM-001 à RM-006) toutes marquées **status: "N/A"** avec des notes indiquant que c'est du "Backend-only WS". Cependant, la spec fonctionnelle décrit clairement la logique de routing vers 4 tables différentes :

- `histo_sessions_caisse_article` (Type='V')
- `histo_sessions_caisse_detail` (Type='I')
- `histo_sessions_caisse_devise` (Type='E')
- `histo_sessions_caisse_remise`

**Le code généré ne reflète aucune de ces distinctions.**

#### 2. **Incohérence entre types TS et logique métier**

```typescript
export type SessionDetailActionType = 'E' | 'V' | 'I';
```

Ce type définit bien les 3 valeurs possibles, mais :
- Aucun switch/if pour router différemment selon `type`
- Un seul endpoint `/api/session-detail/log` qui reçoit tout
- Aucune validation business côté frontend

#### 3. **Architecture générique inadaptée**

Le store actuel envoie un payload unique :

```typescript
const payload = {
  societe, deviseLocale, uniBi, chronoSession,
  quand, quoi, type,
  montant, montantMonnaie, montantProduits, montantCartes, // ...
};
await apiClient.post('/api/session-detail/log', payload);
```

**Problème** : La spec indique que selon `type`, différents champs sont pertinents et différentes tables sont ciblées. Le payload actuel mélange tout.

#### 4. **Règles business non implémentées**

| Règle | Condition | Implémentation |
|-------|-----------|----------------|
| RM-001 | `Type='E'` → table devise | ❌ Aucune logique |
| RM-002 | `nbreDevises<>0` → activer devise detail | ❌ Aucune validation |
| RM-003 | `Type='V'` → table article | ❌ Aucune logique |
| RM-004 | `Type='V' AND montantProduits<>0` | ❌ Aucune validation |
| RM-005 | `Quand='O' AND Type='I'` → traitement spécial | ❌ Aucune logique |
| RM-006 | `ouvertureAuto ? 'O' : ''` | ⚠️ Partiellement (mapping booléen) |

#### 5. **Page UI inutile pour un service backend-only**

```tsx
<p className="text-on-surface-muted text-sm mt-1">
  Programme backend de journalisation (aucune interface visible)
</p>
```

Si vraiment backend-only, pourquoi créer `SessionDetailPage.tsx` ? Cela ajoute de la complexité inutile.

### Recommandations prioritaires

#### 1. **Clarifier l'architecture backend-only**

**Option A** : Service pur sans UI
```typescript
// Supprimer SessionDetailPage.tsx
// Garder uniquement sessionDetailStore.ts comme service
export const sessionDetailService = {
  logArticleDetail: (data) => apiClient.post('/api/session-detail/article', data),
  logDeviseDetail: (data) => apiClient.post('/api/session-detail/devise', data),
  logSessionDetail: (data) => apiClient.post('/api/session-detail/detail', data),
  logRemiseDetail: (data) => apiClient.post('/api/session-detail/remise', data),
};
```

**Option B** : Implémenter le routing frontend
```typescript
export const useSessionDetailStore = create<SessionDetailStore>((set) => ({
  logSessionDetail: async (request: LogSessionDetailRequest) => {
    const endpoint = getEndpointByType(request.type); // Logique de routing
    
    if (request.type === 'E' && request.nbreDevises === 0) {
      return; // RM-002: Skip si pas de devises
    }
    
    if (request.type === 'V' && request.montantProduits === 0) {
      return; // RM-004: Skip si pas de produits
    }
    
    await apiClient.post(endpoint, request);
  },
}));
```

#### 2. **Créer des types séparés par table**

```typescript
export interface ArticleDetailLog {
  societe: string;
  chronoSession: number;
  montantProduits: number;
  // ... champs spécifiques table article
}

export interface DeviseDetailLog {
  societe: string;
  chronoSession: number;
  nbreDevises: number;
  commentaireEcartDevise: string;
  // ... champs spécifiques table devise
}
```

#### 3. **Ajouter des tests unitaires pour les règles**

```typescript
describe('sessionDetailStore - Business Rules', () => {
  it('RM-001: should route Type E to devise endpoint', async () => {
    const request = { type: 'E', /* ... */ };
    await logSessionDetail(request);
    expect(apiClient.post).toHaveBeenCalledWith('/api/session-detail/devise', expect.any(Object));
  });
  
  it('RM-002: should skip devise detail if nbreDevises is 0', async () => {
    const request = { type: 'E', nbreDevises: 0 };
    await logSessionDetail(request);
    expect(apiClient.post).not.toHaveBeenCalled();
  });
});
```

### Conclusion

Le code généré fournit une **structure de base** (15% couverture) mais **manque complètement la logique métier critique** décrite dans la spec. Les 6 règles business sont toutes marquées N/A dans le contrat, créant une ambiguïté entre "backend-only" et "pas besoin de gérer frontend".

**Action immédiate** : Clarifier avec le PO si ce programme doit exposer des endpoints séparés (/article, /devise, /remise, /detail) ou un seul endpoint générique avec routing backend. Ensuite, implémenter les 6 règles business manquantes.

Rapport détaillé sauvegardé : `coverage-report-134.json`