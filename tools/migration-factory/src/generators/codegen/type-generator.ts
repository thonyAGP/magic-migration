/**
 * Generates TypeScript type definitions from a CodegenModel.
 * Follows adh-web pattern: interface for objects, type for unions, const as const for enums.
 */

import type { CodegenModel, CodegenEntity } from './codegen-model.js';
import type { EnrichmentData } from './enrich-model.js';

export const generateTypes = (model: CodegenModel): string => {
  const lines: string[] = [];

  lines.push(`// Types for ${model.domainPascal} (IDE ${model.programId})`);
  lines.push(`// Auto-generated by Migration Factory v8 - edit after generation`);
  lines.push('');

  // Entity interfaces from tables
  for (const entity of model.entities) {
    lines.push(generateEntityInterface(entity, model.enrichments));
    lines.push('');
  }

  // Main state interface
  lines.push(`export interface ${model.domainPascal}State {`);
  lines.push('  isLoading: boolean;');
  lines.push('  error: string | null;');
  for (const field of model.stateFields) {
    const enrichedType = model.enrichments?.stateFieldTypes[field.name];
    const tsType = enrichedType ?? (field.source === 'prop' ? 'string' : 'unknown');
    lines.push(`  ${field.name}: ${tsType}; // ${field.source}: ${field.description}`);
  }
  for (const entity of model.entities) {
    const suffix = entity.mode === 'R' ? '[]' : '[]';
    lines.push(`  ${entity.name}List: ${entity.interfaceName}${suffix};`);
  }
  lines.push('}');
  lines.push('');

  // Action union type from rules
  if (model.actions.length > 0) {
    lines.push(`export type ${model.domainPascal}Action =`);
    const actionTypes = model.actions.map(a => `  | '${a.id}'`);
    lines.push(actionTypes.join('\n') + ';');
    lines.push('');
  }

  // API response types
  if (model.apiCalls.length > 0) {
    for (const call of model.apiCalls) {
      lines.push(`export interface ${call.name.replace(/^call/, '')}Response {`);
      lines.push('  // TODO: define response shape');
      lines.push('  success: boolean;');
      lines.push('}');
      lines.push('');
    }
  }

  return lines.join('\n');
};

const generateEntityInterface = (entity: CodegenEntity, enrichments?: EnrichmentData): string => {
  const lines: string[] = [];
  lines.push(`export interface ${entity.interfaceName} {`);

  const enrichedFields = enrichments?.entityFields[entity.interfaceName];

  if (entity.fields.length > 0) {
    for (const field of entity.fields) {
      lines.push(`  ${field.name}: ${field.type};`);
    }
  } else if (enrichedFields && enrichedFields.length > 0) {
    for (const field of enrichedFields) {
      lines.push(`  ${field.name}: ${field.type};`);
    }
  } else {
    lines.push(`  id: string | number;`);
    lines.push(`  // TODO: add fields from table ${entity.name} (mode: ${entity.mode})`);
  }

  lines.push('}');
  return lines.join('\n');
};
