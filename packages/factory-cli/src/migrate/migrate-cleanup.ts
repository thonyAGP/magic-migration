/**
 * MVP-10: Cleanup / rollback command for migration artifacts.
 * Removes generated files for a batch while preserving contracts and tracker.
 */

import fs from 'node:fs';
import path from 'node:path';

export interface CleanupOptions {
  batchId: string;
  targetDir: string;
  migrationDir: string;
  contractSubDir: string;
  dryRun: boolean;
}

export interface CleanupResult {
  filesDeleted: number;
  dirsDeleted: number;
  files: string[];
  dryRun: boolean;
}

/** Known generated file patterns per program */
const GENERATED_PATTERNS = [
  'types/*.ts',
  'stores/*Store.ts',
  'services/api/*.ts',
  'pages/*Page.tsx',
  'components/**/*.tsx',
  '__tests__/*.test.ts',
  '__tests__/*.test.tsx',
];

/**
 * Find all files generated by migration for a specific batch.
 * Uses the tracker to identify which programs belong to the batch,
 * then collects files listed in the tracker.
 */
export const findBatchFiles = (options: CleanupOptions): string[] => {
  const trackerPath = path.join(options.migrationDir, options.contractSubDir, 'migration-tracker.json');
  if (!fs.existsSync(trackerPath)) return [];

  const tracker = JSON.parse(fs.readFileSync(trackerPath, 'utf8'));
  const batchPrograms = tracker.batches?.[options.batchId]?.programs;
  if (!batchPrograms) return [];

  const files: string[] = [];
  for (const progId of Object.keys(batchPrograms)) {
    const prog = batchPrograms[progId];
    if (prog.files && Array.isArray(prog.files)) {
      for (const f of prog.files) {
        const absPath = path.isAbsolute(f)
          ? f
          : path.join(options.targetDir, f);
        if (fs.existsSync(absPath)) {
          files.push(absPath);
        }
      }
    }
  }

  return files;
};

/**
 * Clean up (delete) all generated files for a batch.
 * Also removes empty parent directories.
 */
export const cleanupBatch = (options: CleanupOptions): CleanupResult => {
  const files = findBatchFiles(options);
  const result: CleanupResult = {
    filesDeleted: 0,
    dirsDeleted: 0,
    files: files.map(f => path.relative(options.targetDir, f)),
    dryRun: options.dryRun,
  };

  if (options.dryRun) return result;

  const parentDirs = new Set<string>();

  for (const file of files) {
    try {
      fs.unlinkSync(file);
      result.filesDeleted++;
      parentDirs.add(path.dirname(file));
    } catch {
      // Skip files that can't be deleted
    }
  }

  // Remove empty directories (deepest first)
  const sortedDirs = [...parentDirs].sort((a, b) => b.length - a.length);
  for (const dir of sortedDirs) {
    try {
      const entries = fs.readdirSync(dir);
      if (entries.length === 0) {
        fs.rmdirSync(dir);
        result.dirsDeleted++;
      }
    } catch {
      // Skip dirs that can't be removed
    }
  }

  return result;
};

/**
 * Reset tracker entries for a batch (mark programs as pending).
 */
export const resetBatchTracker = (options: CleanupOptions): number => {
  const trackerPath = path.join(options.migrationDir, options.contractSubDir, 'migration-tracker.json');
  if (!fs.existsSync(trackerPath)) return 0;

  const tracker = JSON.parse(fs.readFileSync(trackerPath, 'utf8'));
  const batchPrograms = tracker.batches?.[options.batchId]?.programs;
  if (!batchPrograms) return 0;

  let reset = 0;
  for (const progId of Object.keys(batchPrograms)) {
    batchPrograms[progId] = {
      status: 'pending',
      currentPhase: null,
      phases: {},
      files: [],
      errors: [],
    };
    reset++;
  }

  if (!options.dryRun) {
    fs.writeFileSync(trackerPath, JSON.stringify(tracker, null, 2), 'utf8');
  }

  return reset;
};
